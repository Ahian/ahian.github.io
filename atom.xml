<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Poetry&#39;s Blog</title>
  
  <subtitle>Choose a gesture to allow yourself to live irreplaceable.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.poetries.top/"/>
  <updated>2021-05-11T03:46:23.620Z</updated>
  <id>http://blog.poetries.top/</id>
  
  <author>
    <name>Poetry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端监控系统总结篇</title>
    <link href="http://blog.poetries.top/2021/05/11/fe-monitor-sys/"/>
    <id>http://blog.poetries.top/2021/05/11/fe-monitor-sys/</id>
    <published>2021-05-11T02:50:32.000Z</published>
    <updated>2021-05-11T03:46:23.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、性能优化方法论"><a href="#一、性能优化方法论" class="headerlink" title="一、性能优化方法论"></a>一、性能优化方法论</h2><p><img src="http://img-repo.poetries.top/images/20210502210714.png" alt></p><blockquote><p>首屏时间可以拆分为白屏时间、数据接口响应时间、图片加载资源等</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210502214539.png" alt></p><p><img src="http://img-repo.poetries.top/images/20210503212926.png" alt></p><h2 id="二、指标采集：首屏时间指标采集具体办法"><a href="#二、指标采集：首屏时间指标采集具体办法" class="headerlink" title="二、指标采集：首屏时间指标采集具体办法"></a>二、指标采集：首屏时间指标采集具体办法</h2><h3 id="手动采集办法及优缺点："><a href="#手动采集办法及优缺点：" class="headerlink" title="手动采集办法及优缺点："></a>手动采集办法及优缺点：</h3><ul><li>所谓手动采集，一般是通过埋点的方式进行， 比如在页面开始位置打上 <code>FMP.Start()</code>，在首屏结束位置打上 <code>FMP.End()</code>，利用 <code>FMP.End()-FMP.Start()</code> 获取到首屏时间。</li><li>手动采集的统计结果并不精确，因为依赖于人，每个人对首屏的理解有偏差，经常打错或者忘记打点。</li></ul><h3 id="自动化采集优势及办法"><a href="#自动化采集优势及办法" class="headerlink" title="自动化采集优势及办法"></a>自动化采集优势及办法</h3><blockquote><p>所谓自动化采集，即引入一段通用的代码来做首屏时间自动化采集，引入过程中，除了必要的配置不需要做其他事情。</p></blockquote><p>自动化采集的好处是独立性更强，接入过程更自动化。具体的自动化采集代码，可以由一个公共团队来开发，试点后，推广到各个业务团队。而且统计结果更标准化，同一段统计代码，标准更统一，业务侧同学也更认可这个统计结果。</p><p>当然，它也有缺点，最明显的是，有些个性化需求无法满足，毕竟在工作中，总会有一些特殊业务场景。所以，采用自动化采集方案必须做一些取舍。</p><h3 id="单页面（SPA）应用业务下的采集办法"><a href="#单页面（SPA）应用业务下的采集办法" class="headerlink" title="单页面（SPA）应用业务下的采集办法"></a>单页面（SPA）应用业务下的采集办法</h3><p>SPA 页面因为无法基于 <code>DOMContentLoaded</code> 做首屏指标采集，可以使用 <code>MutationObserver</code> 采集首屏时间。</p><blockquote><p><code>MutationObserver</code> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 <code>Mutation Events</code> 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p></blockquote><p>简单来说， 使用 <code>MutationObserver 能监控页面信息的变化</code>，当页面 <code>body</code> 变化最剧烈的时候，我们拿到的时间数据，就是<code>首屏时间</code>。</p><p>首先，在用户进入页面时，我们可以使用 <code>MutationObserver</code> 监控 <code>DOM</code> 元素 （Document Object Model，文档对象模型）。当 DOM 元素发生变化时，程序会标记变化的元素，记录时间点和分数，存储到数组中。数据的格式类似于 <code>[200ms,18.5]</code>。</p><p>为了提升计算的效率，我们认为首屏指标采集到某些条件时，首屏渲染已经结束，我们需要考虑首屏采集终止的条件，即计算时间超过 30 秒还没有结束；计算了 4 轮且 1 秒内分数不再变化；计算了 9 次且分数不再变化。</p><p>接下来，设定元素权重计算分数。</p><p>递归遍历 DOM 元素及其子元素，根据子元素所在层数设定元素权重，比如第一层元素权重是 1，当它被渲染时得 1 分，每增加一层权重增加 0.5，比如第五层元素权重是 3.5，渲染时给出对应分数。</p><p>为什么需要权重呢？</p><p>因为页面中每个 DOM 元素对于首屏的意义是不同的，越往内层越接近真实的首屏内容，如图片和文字，越往外层越接近 body 等框架层。</p><p>最后，根据前面的得分，计算元素的分数变化率，获取变化率最大点对应的分数。然后找到该分数对应的时间，即为首屏时间。</p><p>分数部分核心计算逻辑是递归遍历元素，将一些无用的标签排除，如果元素超过可视范围返回 0 分，每一层增加 0.5 的权重，具体请看下面代码示例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CScor</span>(<span class="params">el, tiers, parentScore</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> tagName = el.tagName;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"SCRIPT"</span> !== tagName &amp;&amp; <span class="string">"STYLE"</span> !== tagName &amp;&amp; <span class="string">"META"</span> !== tagName &amp;&amp; <span class="string">"HEAD"</span> !== tagName) &#123;</span><br><span class="line">      <span class="keyword">const</span> childrenLen = el.children ? el.children.length : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (childrenLen &gt; <span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">let</span> childs = el.children, len = childrenLen - <span class="number">1</span>; len &gt;= <span class="number">0</span>; len--) &#123;</span><br><span class="line">        score += calculateScore(childs[len], tiers + <span class="number">1</span>, score &gt; <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (score &lt;= <span class="number">0</span> &amp;&amp; !parentScore) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(el.getBoundingClientRect &amp;&amp; el.getBoundingClientRect().top &lt; WH)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      score += <span class="number">1</span> + <span class="number">.5</span> * tiers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>变化率部分核心计算逻辑是获取 DOM 变化最大时对应的时间，代码如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">calFinallScore() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.sendMark) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">const</span> time = <span class="built_in">Date</span>.now() - performance.timing.fetchStart;</span><br><span class="line">      <span class="keyword">var</span> isCheckFmp = time &gt; <span class="number">30000</span> || SCORE_ITEMS &amp;&amp; SCORE_ITEMS.length &gt; <span class="number">4</span> &amp;&amp; time - (SCORE_ITEMS &amp;&amp; SCORE_ITEMS.length &amp;&amp; SCORE_ITEMS[SCORE_ITEMS.length - <span class="number">1</span>].t || <span class="number">0</span>) &gt; <span class="number">2</span> * CHECK_INTERVAL || (SCORE_ITEMS.length &gt; <span class="number">10</span> &amp;&amp; <span class="built_in">window</span>.performance.timing.loadEventEnd !== <span class="number">0</span> &amp;&amp; SCORE_ITEMS[SCORE_ITEMS.length - <span class="number">1</span>].score === SCORE_ITEMS[SCORE_ITEMS.length - <span class="number">9</span>].score);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.observer &amp;&amp; isCheckFmp) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observer.disconnect();</span><br><span class="line">        <span class="built_in">window</span>.SCORE_ITEMS_CHART = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(SCORE_ITEMS));</span><br><span class="line">        <span class="keyword">let</span> fmps = getFmp(SCORE_ITEMS);</span><br><span class="line">        <span class="keyword">let</span> record = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> o = <span class="number">1</span>; o &lt; fmps.length; o++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fmps[o].t &gt;= fmps[o - <span class="number">1</span>].t) &#123;</span><br><span class="line">            <span class="keyword">let</span> l = fmps[o].score - fmps[o - <span class="number">1</span>].score;</span><br><span class="line">            (!record || record.rate &lt;= l) &amp;&amp; (record = &#123;</span><br><span class="line">              t: fmps[o].t,</span><br><span class="line">              rate: l</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.fmp = record &amp;&amp; record.t || <span class="number">30001</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.checkImgs(<span class="built_in">document</span>.body)</span><br><span class="line">          <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...this.imgs.map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="regexp">/^(\/\/)/</span>.test(element)) element = <span class="string">'https:'</span> + element;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> performance.getEntriesByName(element)[<span class="number">0</span>].responseEnd || <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;))</span><br><span class="line">          record &amp;&amp; record.t &gt; <span class="number">0</span> &amp;&amp; record.t &lt; <span class="number">36e5</span> ? <span class="keyword">this</span>.setPerformance(&#123;</span><br><span class="line">            fmpImg: <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.max(record.t , max))</span><br><span class="line">          &#125;) : <span class="keyword">this</span>.setPerformance(&#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setPerformance(&#123;&#125;);</span><br><span class="line">          <span class="comment">// console.error(error)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.calFinallScore();</span><br><span class="line">        &#125;, CHECK_INTERVAL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个就是首屏计算的部分流程。</p><p>看完前面的流程，不知道你有没有这样的疑问：<code>如果页面里包含图片，使用上面的首屏指标采集方案，结果准确吗</code>？</p><blockquote><p>结论是：不准确。上述计算逻辑主要是针对 DOM元素来做的，图片加载过程是异步，图片容器（图片的 DOM 元素）和内容的加载是分开的，当容器加载出来时，内容还没出来，一定要确保内容加载出来，才算首屏。</p></blockquote><p>这就需要增加一些策略了，以下是包含图片页面的首屏计算 demo。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"imgTest"</span> <span class="attr">src</span>=<span class="string">"https://www.baidu.com/img/bd_logo1.png?where=super"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"imgTest"</span> <span class="attr">src</span>=<span class="string">"https://www.baidu.com/img/bd_logo1.png?where=super"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">text/css</span>&gt;</span></span><br><span class="line">    background-image:url('https://www.baidu.com/img/dong_8f1d47bcb77d74a1e029d8cbb3b33854.gif);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> imgs = []</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> getImageDomSrc = &#123;</span></span><br><span class="line"><span class="javascript">    _getImgSrcFromBgImg: <span class="function"><span class="keyword">function</span> (<span class="params">bgImg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> imgSrc;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> matches = bgImg.match(<span class="regexp">/url\(.*?\)/g</span>);</span></span><br><span class="line">      if (matches &amp;&amp; matches.length) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> urlStr = matches[matches.length - <span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> innerUrl = urlStr.replace(<span class="regexp">/^url\([\'\"]?/</span>, <span class="string">''</span>).replace(<span class="regexp">/[\'\"]?\)$/</span>, <span class="string">''</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (((<span class="regexp">/^http/</span>.test(innerUrl) || <span class="regexp">/^\/\//</span>.test(innerUrl)))) &#123;</span></span><br><span class="line">          imgSrc = innerUrl;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> imgSrc;</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    getImgSrcFromDom: <span class="function"><span class="keyword">function</span> (<span class="params">dom, imgFilter</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!(dom.getBoundingClientRect &amp;&amp; dom.getBoundingClientRect().top &lt; <span class="built_in">window</span>.innerHeight))</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      imgFilter = [<span class="regexp">/(\.)(png|jpg|jpeg|gif|webp|ico|bmp|tiff|svg)/i</span>]</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (dom.nodeName.toUpperCase() == <span class="string">'IMG'</span>) &#123;</span></span><br><span class="line"><span class="javascript">        src = dom.getAttribute(<span class="string">'src'</span>);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> computedStyle = <span class="built_in">window</span>.getComputedStyle(dom);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bgImg = computedStyle.getPropertyValue(<span class="string">'background-image'</span>) || computedStyle.getPropertyValue(<span class="string">'background'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> tempSrc = <span class="keyword">this</span>._getImgSrcFromBgImg(bgImg, imgFilter);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (tempSrc &amp;&amp; <span class="keyword">this</span>._isImg(tempSrc, imgFilter)) &#123;</span></span><br><span class="line">          src = tempSrc;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> src;</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    _isImg: <span class="function"><span class="keyword">function</span> (<span class="params">src, imgFilter</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = imgFilter.length; i &lt; len; i++) &#123;</span></span><br><span class="line">        if (imgFilter[i].test(src)) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    traverse(e) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> _this = <span class="keyword">this</span></span></span><br><span class="line">        , tName = e.tagName;</span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="string">"SCRIPT"</span> !== tName &amp;&amp; <span class="string">"STYLE"</span> !== tName &amp;&amp; <span class="string">"META"</span> !== tName &amp;&amp; <span class="string">"HEAD"</span> !== tName) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> el = <span class="keyword">this</span>.getImgSrcFromDom(e)</span></span><br><span class="line">        if (el &amp;&amp; !imgs.includes(el))</span><br><span class="line">          imgs.push(el)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> len = e.children ? e.children.length : <span class="number">0</span>;</span></span><br><span class="line">        if (len &gt; 0)</span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">var</span> child = e.children, _len = len - <span class="number">1</span>; _len &gt;= <span class="number">0</span>; _len--)</span></span><br><span class="line">            _this.traverse(child[_len]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  getImageDomSrc.traverse(<span class="built_in">document</span>.body);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(imgs,<span class="string">'-imgs--'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> max = <span class="built_in">Math</span>.max(...imgs.map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">     <span class="keyword">if</span> (<span class="regexp">/^(\/\/)/</span>.test(element))</span></span><br><span class="line"><span class="javascript">      element = <span class="string">'https:'</span> + element;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> performance.getEntriesByName(element)[<span class="number">0</span>].responseEnd || <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="number">0</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ))</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(max);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">)()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它的计算逻辑是这样的。</p><p>首先，获取页面所有的图片路径。在这里，图片类型分两种，一种是带 IMG 标签的，一种是带 DIV 标签的。前者可以直接通过 src 值得到图片路径，后者可以使用 <code>window.getComputedStyle(dom)</code> 方式获取它的样式集合。</p><p>接下来，通过正则获取图片的路径即可。</p><p>然后通过 <code>performance.getEntriesByName(element)[0].responseEnd</code> 的方式获取到对应图片路径的下载时间，最后与使用 <code>MutationObserver</code> 获得的 DOM 首屏时间相比较，哪个更长，哪个就是最终的首屏时间。</p><blockquote><p>以上就是首屏采集的完整流程</p></blockquote><blockquote><p>注意：计算首屏时间用到的<code>getBoundingClientRect</code>和<code>getComputedStyle</code>会引起强制回流</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503151137.png" alt></p><h2 id="三、指标采集：白屏、卡顿、网络环境指标采集方法"><a href="#三、指标采集：白屏、卡顿、网络环境指标采集方法" class="headerlink" title="三、指标采集：白屏、卡顿、网络环境指标采集方法"></a>三、指标采集：白屏、卡顿、网络环境指标采集方法</h2><h3 id="白屏指标采集"><a href="#白屏指标采集" class="headerlink" title="白屏指标采集"></a>白屏指标采集</h3><blockquote><p>白屏时间是指从输入内容回车（包括刷新、跳转等方式）后，到页面开始出现第一个字符的时间。白屏时间的长短会影响用户对 App 或站点的第一印象</p></blockquote><p>白屏指标怎么采集呢？我们先来回顾一下浏览器的页面加载过程：</p><blockquote><p>客户端发起请求 -&gt; 下载 HTML 及 JS/CSS 资源 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt; 客户端解析 DOM 并渲染 -&gt; 下载渲染图片-&gt; 完成渲整体染</p></blockquote><p>在这个过程中，客户端解析 DOM 并渲染之前的时间，都算白屏时间。所以，<strong>白屏时间的采集思路如下</strong>：<code>白屏时间 = 页面开始展示时间点 - 开始请求时间点</code>。如果你是借助浏览器的 <code>Performance API</code> 工具来采集，那么可以使用公式：<code>白屏时间 FP</code> = <code>domLoading - navigationStart</code>。</p><p>这是浏览器页面加载过程，如果放在 App场景下，就不太一样了，App下的页面加载过程：</p><blockquote><p>初始化 WebView -&gt; 客户端发起请求 -&gt; 下载 HTML 及 JS/CSS 资源 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt; 服务端处理并返回数据 -&gt; 客户端解析 DOM 并渲染 -&gt; 下载渲染图片 -&gt; 完成整体渲染。</p></blockquote><p><code>App下的白屏时间，多了启动浏览器内核，也就是 Webview 初始化的时间</code>。这个时间必须通过手动采集的方式来获得，而且因为线上线下时间差别不大，线下采集即可。<strong>具体来说，在 App 测试版本中，程序在 App 创建 WebView 时打一个点，然后在开始建立网络连接打一个点，这两个点的时间差就是 Webview 初始化的时间</strong>。</p><h3 id="卡顿指标采集"><a href="#卡顿指标采集" class="headerlink" title="卡顿指标采集"></a>卡顿指标采集</h3><p><strong>所谓卡顿，简单来说就是页面出现卡住了的不流畅的情况</strong>。 提到它的指标，你是不是会一下就想到 FPS（Frames Per Second，每秒显示帧数）？FPS 多少算卡顿？网上有很多资料，大多提到 FPS 在 60 以上，页面流畅，不卡顿。但事实上并非如此，比如我们看电影或者动画时，素虽然 FPS 是 30 （低于60），但我们觉得很流畅，并不卡顿。</p><p>FPS 低于 60 并不意味着卡顿，那 FPS 高于 60 是否意味着一定不卡顿呢？比如前 60 帧渲染很快（10ms 渲染 1 帧），后面的 3 帧渲染很慢（ 20ms 渲染 1 帧），这样平均起来 FPS 为95，高于 60 的标准。这种情况会不会卡顿呢？实际效果是卡顿的。因为卡顿与否的关键点在于单帧渲染耗时是否过长。</p><blockquote><p>但难点在于，在浏览器上，我们没办法拿到单帧渲染耗时的接口，所以这时候，只能拿 FPS 来计算，只要 FPS 保持稳定，且值比较低，就没问题。<code>它的标准是多少呢？连续 3 帧不低于 20 FPS，且保持恒定</code>。</p></blockquote><p>以 H5 为例，<code>H5 场景下获取 FPS 方案如下</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fps_compatibility= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">        <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">var</span> fps_config=&#123;</span><br><span class="line">  lastTime:performance.now(),</span><br><span class="line">  lastFameTime : performance.now(),</span><br><span class="line">  frame:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fps_loop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _first =  performance.now(),_diff = (_first - fps_config.lastFameTime);</span><br><span class="line">    fps_config.lastFameTime = _first;</span><br><span class="line">    <span class="keyword">var</span> fps = <span class="built_in">Math</span>.round(<span class="number">1000</span>/_diff);</span><br><span class="line">    fps_config.frame++;</span><br><span class="line">    <span class="keyword">if</span> (_first &gt; <span class="number">1000</span> + fps_config.lastTime) &#123;</span><br><span class="line">        <span class="keyword">var</span> fps = <span class="built_in">Math</span>.round( ( fps_config.frame * <span class="number">1000</span> ) / ( _first - fps_config.lastTime ) );</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`time: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span> fps is：`</span>, fps);</span><br><span class="line">        fps_config.frame = <span class="number">0</span>;    </span><br><span class="line">        fps_config.lastTime = _first ;    </span><br><span class="line">    &#125;;           </span><br><span class="line">    fps_compatibility(fps_loop);   </span><br><span class="line">&#125;</span><br><span class="line">fps_loop();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBlocking</span>(<span class="params">fpsList, below=<span class="number">20</span>, last=<span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fpsList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fpsList[i] &amp;&amp; fpsList[i] &lt; below) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= last) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用 <code>requestAnimationFrame</code> 在一秒内执行 <code>60</code> 次（在不卡顿的情况下）这一点，假设页面加载用时 <code>X ms</code>，这期间 <code>requestAnimationFrame</code> 执行了 <code>N</code> 次，则帧率为 <code>1000* N/X</code>，也就是<code>FPS</code></p></blockquote><p>由于用户客户端差异很大，我们要考虑兼容性，在这里我们定义 <code>fps_compatibility</code> 表示兼容性方面的处理，在浏览器不支持 <code>requestAnimationFrame</code> 时，利用 <code>setTimeout</code> 来模拟实现，在 <code>fps_loop</code> 里面完成 FPS 的计算，最终通过遍历 <code>fpsList</code> 来判断是否连续三次 fps 小于20。</p><p>如果连续判断 3次 FPS 都小于20，就认为是卡顿。</p><p><img src="http://img-repo.poetries.top/images/20210503152718.png" alt></p><h2 id="四、工具实践：性能-SDK-及上报策略设计"><a href="#四、工具实践：性能-SDK-及上报策略设计" class="headerlink" title="四、工具实践：性能 SDK 及上报策略设计"></a>四、工具实践：性能 SDK 及上报策略设计</h2><p>由于性能 SDK 最终是给各个业务使用的，所以它的设计要满足在接入性能监控平台时，简单易用和运行平稳高效，这两个要求。</p><h3 id="SDK-接入设计"><a href="#SDK-接入设计" class="headerlink" title="SDK 接入设计"></a>SDK 接入设计</h3><p>要保证 <code>SDK</code> 接入简单，容易使用，<code>首先要把之前首屏、白屏和卡顿采集的脚本封装在一起，并让脚本自动初始化和运行</code>。</p><p><img src="http://img-repo.poetries.top/images/20210503152937.png" alt></p><ul><li>具体来说，首屏采集的<code>分数计算部分 API（calculateScore）</code>、<code>变化率计算的 API（calFinallScore）</code>和<code>首屏图片时间计算 API（fmpImg）</code>可以一起封装成 FMP API。其中首屏图片计算 API 因为比较独立，可以专门抽离成一个 util，供其他地方调用。白屏和卡顿采集也类似，可以封装成 <code>FP API</code> 和 <code>BLOCK API</code>。</li><li>还有一个 <code>ExtensionAPI</code> 接口，用来封装一些后续需要使用的数据，比如加载瀑布流相关的数据（将首屏时间细分为DNS、TCP连接等时间），这些数据可以通过浏览器提供的 <code>performance</code> 接口获得。</li></ul><blockquote><p>为了进行首屏、白屏、卡顿的指标采集，我们可以封装 <code>Perf API</code>，调用 <code>FMP、FP、BLOCK、ExtensionAPI</code> 四个 API 来完成。因为是调用 <code>window.performance</code> 接口，所以先做环境兼容性的判断，即看看浏览器是否支持 <code>window.performance</code></p></blockquote><p>最终我们接入时只要安装一个 <code>npm</code> 包，然后初始化即可，具体代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install @common/Perf -S;</span><br><span class="line"><span class="keyword">import</span> &#123; perfInit &#125; <span class="keyword">from</span> <span class="string">'@common'</span>;</span><br><span class="line">perfInit ();</span><br></pre></td></tr></table></figure><p>或者以外链的形式接入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;https:<span class="comment">//s1.static.com/common/perf/static/js/1.0.0/perf.min.js&lt;/script&gt;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  perfInit ();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了性能 SDK 自身的方案设计之外，提供帮助文档（如示例代码、 QA 列表等），也可以提高性能 SDK 的易用性。</p><p>具体来说，我们可以搭建一个简单的性能 SDK 网站，进入站点后，前端工程师可以看到使用文档，包括各种平台下如何接入，接入的示例代码是怎样的，接入性能 SDK 后去哪个 URL 看数据，遇到异常问题时怎么调试，等等。</p><h3 id="SDK-运行设计"><a href="#SDK-运行设计" class="headerlink" title="SDK 运行设计"></a>SDK 运行设计</h3><p>SDK 如果想运行高效，必须有好的兼容性策略、容错机制和测试方案。</p><p>所谓兼容性策略，就是性能 SDK 可以在各个业务下都可以稳定运行。</p><p><strong>我们知道，前端性能优化会面临的业务场景大致有：</strong></p><ul><li>各类页面，如平台型页面、3C 类页面、中后台页面；</li><li>一些可视化搭建的平台，如用于搭建天猫双十一会场页这种用于交易运行页面的魔方系统；</li><li>各个终端，如 PC 端，移动端，小程序端等。</li></ul><p>这就要求性能 SDK 要能适应这些业务，及时采集性能指标并进行上报。那具体怎么做呢？</p><p>一般不同页面和终端，它们的技术栈也会不同，如 PC端页面使用 React，移动端页面使用 VUE 。这个时候，<code>我们可以尽可能用原生 JavaScript 去做性能指标的采集，从而实现跨不同技术栈的采集</code>。</p><blockquote><p>不同终端方面，我设计了一个适配层来抹平采集方面的差异。<code>具体来说，小程序端可以用有自己的采集 API，如 minaFMP</code>，<code>其他端可以直接用 FMP</code>，这样在性能 SDK 初始化时，<code>根据当前终端类型的不同，去调用各自的性能指标采集 API</code>。</p></blockquote><p>容错方面怎么做呢？</p><blockquote><p>如果是性能 SDK 自身的报错，可以通过 <code>try catch</code> 的方式捕获到，然后上报异常监控平台。注意，不要因为 SDK 的报错而影响引入性能 SDK 页面的正常运行。</p></blockquote><h3 id="日志数据过滤"><a href="#日志数据过滤" class="headerlink" title="日志数据过滤"></a>日志数据过滤</h3><p>我的建议是，在采集性能指标之后，最好先对异常数据进行过滤。</p><p>异常数据分一般有两类，第一类是计算错误导致的异常数据，比如负值或者非数值数据，第二类是合法异常值、极大值、极小值，属于网络断掉或者超时形成的数值，比如 15s 以上的首屏时间。</p><p>负值的性能指标数据影响很大，它会严重拖低首屏时间，也会把计算逻辑导致负值的问题给掩盖掉。</p><h3 id="数据抽样策略"><a href="#数据抽样策略" class="headerlink" title="数据抽样策略"></a>数据抽样策略</h3><p>性能 SDK 上报数据是全量还是抽象，需要根据本身 App 或者网站的日活来确定，如果日活10万以下，那抽样就没必要了。如果是一款日活千万的 App，那就需要进行数据抽样了，因为如果上报全量日志的话，会耗费大量用户的流量和请求带宽。</p><h3 id="上报机制选择"><a href="#上报机制选择" class="headerlink" title="上报机制选择"></a>上报机制选择</h3><p>一般，为了节省流量，性能 SDK 也会根据网络能力，选择合适的上报机制。在强网环境（如 <code>4G/WIFI</code>），直接进行上报；在弱网（<code>2G/3G</code>）下，将日志存储到本地，延时到强网下再上报。</p><p>除了网络能力，我们还可以让 SDK 根据 App 忙碌状态，选择合适的上报策略。如果 App 处于空闲状态，直接上报；如果处于忙碌状态，等到闲时（比如凌晨 2-3 点）再进行上报。</p><p>除此之外，还有一些其他的策略，如批量数据上报，默认消息数量达到 30 条才上报，或者只在 App 启动时上报等策略，等等。你可以根据实际情况进行选择。</p><p><img src="http://img-repo.poetries.top/images/20210503153920.png" alt></p><blockquote><p>采集到数据后，先对数据进行校验，如果发现数据异常则直接上报到数据异常平台（通过邮件或者钉钉通知的方式发送给开发者），反之如果数据是正常范围内的，则结合采样率来看是否需要上报。</p></blockquote><h2 id="五、平台实践：如何从-0-到-1-搭建前端性能平台"><a href="#五、平台实践：如何从-0-到-1-搭建前端性能平台" class="headerlink" title="五、平台实践：如何从 0 到 1 搭建前端性能平台"></a>五、平台实践：如何从 0 到 1 搭建前端性能平台</h2><p>前端性能平台是一个 Web 系统，主要包括后台的性能数据处理和前台的可视化展示两部分</p><p>其中，数据处理后台主要是对 SDK 上报后的性能指标进行处理和运算，具体包括数据入库、数据清洗、数据计算，做完这些后，前台会对结果进行可视化展现，我们借助它就可以实时监督前端的性能情况。下图是性能平台大盘页的效果，主要对当前用户关注的性能模块进行展示，内容包括首屏时间、秒开率和采样PV。</p><p><img src="http://img-repo.poetries.top/images/20210503154327.png" alt></p><p>那么，我们该如何搭建这样一个性能平台呢？</p><p><img src="http://img-repo.poetries.top/images/20210503154342.png" alt></p><p><strong>这是具体的技术架构图，从底层到前台大致情况如下：</strong></p><ul><li>数据接入层，主要是接收 <code>SDK</code> 上报的性能数据，做数据处理后入库，包含的技术有 <code>Node.js、Node-sechdule、Node-mailer</code>；</li><li>数据计算层，会对性能数据做计算处理，需要的技术有 <code>Kafka、Spark、Hive、HDFS</code></li><li>存储层，包括 <code>MySQL + MongoDB</code> ，性能平台需要的数据会来这里</li><li>平台层，也就是展示给用户的部分，需要的技术有 <code>React、Ant design、Antv、Less</code></li></ul><h3 id="性能数据处理后台"><a href="#性能数据处理后台" class="headerlink" title="性能数据处理后台"></a>性能数据处理后台</h3><p>想要搭建性能平台，我们先来看它的性能处理后台情况。<strong>一般性能 SDK 上报数据的处理过程是这样的</strong>：</p><ul><li>客户端借助 <code>SDK</code> 上报性能数据指标，数据接入层（图中绿色部分）接收相应数据，并做协议转换等简单处理后，作为生产者向 Kafka 写入数据；</li><li>数据计算层（图中橙色部分）作为消费者，从 Kafka 读数据存入 Hive（Hadoop平台的存储表），Hadoop 平台借助 Spark 做数据分析计算；</li><li>借助 Hive 提供的接口，数据计算层使用 SQL 语句从 Hive 拉取计算后的数据到数据库平台（MongoDB），平台层取出数据，准备数据可视化展现的数据。</li></ul><p><strong>上述数据流程，对应的性能数据后台的搭建过程如下</strong>：</p><ol><li>第一步是入库，客户端借助 SDK 上报性能数据指标后，需要后端服务层的处理，这里我们选取的是 NodeJS 做后端，利用 Controller 层对数据做处理。</li></ol><p>为了避免数据库出现“脏数据”（如空数据、异常数据），影响后续数据处理，我们将 SDK 上报的数据通过 URL 解析成 key-value 格式的数据，对数据进行空数据删除，异常数据舍弃等操作。然后我们让数据写进消息队列 Kafka。</p><p><strong>为什么不是直接存入 Hive 呢？</strong></p><p>因为客户端上报的性能数据量和用户规模有关。如果直接入库到 Hive，遇到高并发的时候，会因为服务器扛不住而导致数据丢失。与此同时，因为数据下游（数据的使用方，如数据清洗计算平台，性能预警模块）会有多个数据接收端，直接入库的话也会造成数据重复。</p><p>所以最好我们选择 Kafka，先让数据写进消息队列。Kafka 能通过缓存，慢慢接收这些数据，降低流量洪峰压力。同时，消息队列还有接收数据后将其删除的特点，可以避免数据重复的问题。</p><ol start="2"><li>第二步，<code>对 Kafka 中的数据，做数据清洗和数据计算</code></li></ol><p><strong>数据清洗，是指针对性能上报单条数据进行核对校验的过程。所清洗的数据包括：</strong></p><ul><li>对重复数据的处理，即同一个用户网络出错时，多次重试导致上传了好几条首屏时间相关的数据；</li><li>对缺失数据的处理，虽然上报了首屏时间，但白屏时间或者卡顿时间计算时没能给出；</li><li>对错误数据的处理，即数据超出正常范围，出现负值或者超出极大值的情况。</li></ul><p>这几种类型数据问题如果不处理，最终会影响计算结果的准确性。那么该怎么处理呢？</p><ul><li>遇到重复数据，直接去重删除即可。</li><li>遇到缺失数据，我们在 Spark 平台上，先根据上报的 Performance 数据进行计算补全，如果无法补全的，就直接舍弃掉，不然会出现后续无法入库的情况。</li><li>遇到超出正常范围的数据，如负值或者超过 10 秒以上的数据，把它当作无效数据，直接舍弃掉。</li></ul><blockquote><p>做完数据清洗之后，我们还需要<code>使用 Spark 做数据计算，为可视化展现准备数据</code>。具体需要做以下数据计算：</p></blockquote><ul><li>首屏时间分布的计算，<code>1s ～ 2s</code> 占比多少，<code>2s ～ 4s</code> 占比多少；</li><li>秒开率的计算，首屏时间小于等于 1 秒的数据占比；</li><li>页面瀑布流时间的计算。</li></ul><p>其中，页面瀑布流时间是对首屏时间的细分，<code>包括 DNS 查询、TCP链接、请求耗时、内容传输、资源解析、DOM 解析和资源加载的时间</code>。这些细分时间点，是我们根据 SDK 上报的 Performance 接口数据指标计算出来的，前端工程师根据页面瀑布流时间，可以快速定位性能瓶颈点出现在哪个环节。</p><ol start="3"><li>第三步，准备性能前台所需的可视化数据</li></ol><p>为了完成前台展现，性能平台需要登录功能，还需要做一些用户关注的模块信息，比如前端开发者添加关注的业务模块。我们可以用关系数据库去存储这些数据，具体可以选择 MySQL完成账号权限系统和关注业务模块对应的数据表。</p><p>而性能数据，因为都是单条性能信息，相互之间并没有什么关系，可以用 MongoDB 做存储。具体来说，我们可以用 NodeJS 提供的定时脚本（Node-sechdule）从 Spark 取到数据导入到 MongoDB 中。</p><h3 id="前端数据可视化展示前台"><a href="#前端数据可视化展示前台" class="headerlink" title="前端数据可视化展示前台"></a>前端数据可视化展示前台</h3><p>前端数据可视化展现前台，整体上只有两个页面，大盘页和详情页。</p><p>大盘页包括一个个业务的性能简图。每一个性能简图包括首屏时间、秒开率、采样 PV 数据。点击性能简图上的“进入详情”链接，就可以进入详情页。初次进入大盘页的时候，需要你登录并关注相关的业务，然后就可以在大盘首页看到相关的性能情况。</p><p>详情页的设计的初衷是为了对性能简图做进一步的补充，除了展示对应性能简图的秒开率、性能均值细节、白屏均值细节之外，还会展示终端信息，比如多少比例在IOS端，多少比例在Android端，以方便用户根据不同场景去做优化。</p><p><img src="http://img-repo.poetries.top/images/20210503160942.png" alt></p><blockquote><p>同时，为了解秒开率不达标原因或者首屏时间变慢的细节在哪里，我们会给出页面加载瀑布流，前面数据处理阶段已经提到可以使用的数据（包括 DNS 查询、TCP链接、请求耗时、内容传输、资源解析、DOM 解析和资源加载的时间），套用 AntV （阿里巴巴集团的数据可视化方案）的瀑布流模板即可完成数据展现。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503161021.png" alt></p><p><strong>那么，大盘页和详情页如何实现的呢？</strong></p><p>首先是前端展示技术栈的选择，对应技术架构图中的淡黄色部分，因为这两个页面都属于 PC 端后台页面，主要给公司前端开发者使用，功能上更多是数据可视化展示，非常适合用 React 技术栈做开发。</p><p>为了更好实现首屏时间、秒开率和采用 PV 的功能效果，我们使用 AntdPro 的模板，相关的配套的数据可视化方案，我推荐 Antv，因为它能够满足我们在首屏时间、秒开率等性能指标的展示需求，用起来比较简单（开箱即用），功能灵活且扩展性强（比如秒开率部分，要自定义一些图形，能够较好满足）。</p><p>大盘页和详情页的数据展示效果比较丰富多样，相应的 CSS 代码逻辑就比较复杂，为了让 CSS代码更容易维护和扩展，CSS 方面可以选用 Less 框架。</p><p>接下来是前后端交互方面，为了让前后台更独立，大盘页、详情页与后端的通信通过 HTTP 接口来实现，使用 nginx 作为 Web Server。为了让传输更高效，我们采用 compression 对 HTTP 传输内容进行 GZip 压缩处理。</p><p>最后是后台服务部分，为了让性能平台开发过程更简单，效率更高，同时平台本身的性能体验更流畅，后台服务方面可以选用 Egg.js（基于 NodeJS 的开发框架）做开发，进行数据处理和存储服务。</p><p>为了解决监控预警的问题，我们借助 <code>Node-schedule</code> 做调度和定时任务的处理，通过 <code>node-mailer</code> 进行邮件报警</p><p><img src="http://img-repo.poetries.top/images/20210503161251.png" alt></p><h2 id="六、诊断清单：如何实现监控预警并进行问题诊断"><a href="#六、诊断清单：如何实现监控预警并进行问题诊断" class="headerlink" title="六、诊断清单：如何实现监控预警并进行问题诊断"></a>六、诊断清单：如何实现监控预警并进行问题诊断</h2><h3 id="监控预警"><a href="#监控预警" class="headerlink" title="监控预警"></a>监控预警</h3><p>监控预警部分，我们借助 Node-schedule 做调度和定时任务的处理，通过 node-mailer 进行邮件报警。具体来说我们通过以下几步来实现。</p><p><strong>第一步，准备预警数据</strong></p><p>在做完数据清洗之后，一个分支使用 <code>Spark</code> 做计算，另外一个分支使用 <code>Flink</code> 实时数据计算。这两者的区别在于后者的数据是实时处理的，因为监控预警如果不实时的话，就没有意义了。有关数据的处理，我是这样做的：超过 2s 的数据，或者认定为卡顿的数据，直接标记为预警数据。实际当中你也可以根据情况去定义和处理。</p><p><strong>第二步，我们借助 Node-schedule</strong>，用一批定时任务将预警数据通过 Node.js，拉取数据到 MongoDB 的预警表中。</p><p><strong>第三步，预警的展示流程</strong>。根据预警方式不同，样式展示也不同。具体来说，预警的方式有三种：企业微信报警通知、邮件报警通知、短信报警通知。</p><p>以手机列表页为例，性能标准是首屏时间 1.5s，秒开率 90%，超过这个标准就会在性能平台预警模块展示，按照严重程度倒序排列展示。如果超出 10%，平台上会标红展示，并会发企业微信报警通知；如果超过 20%，会发借助 <code>node-mailer</code> 做邮件报警；如果超出 30%，会发短信报警通知。</p><p>注意，预警通知需要用到通信资源，为了避免数据量太大而浪费资源，一般对 App 首页核心的导航位进行页面监控即可。</p><h3 id="问题诊断"><a href="#问题诊断" class="headerlink" title="问题诊断"></a>问题诊断</h3><p>当预警功能做好后，前端性能平台就可以对重要指标进行实时监督了。当发现性能问题——不论是我们自己发现还是用户反馈，都需要先对问题进行诊断，然后看情况是否需要进一步采取措施。</p><p>一般问题诊断时需要先确认是共性问题还是个例问题。如果是共性问题，那接下来我们就开始诊断和优化；如果是个例问题，是因为偶发性因素导致的（如个人的网络抖动、手机内存占用太多、用户连了代理等），则不需要进行专门优化。</p><p><img src="http://img-repo.poetries.top/images/20210503161715.png" alt></p><h2 id="七、优化手段：首屏秒开的-4-重保障"><a href="#七、优化手段：首屏秒开的-4-重保障" class="headerlink" title="七、优化手段：首屏秒开的 4 重保障"></a>七、优化手段：首屏秒开的 4 重保障</h2><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载是性能优化的前头兵。什么叫懒加载呢？懒加载是指在长页面加载过程时，先加载关键内容，延迟加载非关键内容。比如当我们打开一个页面，它的内容超过了浏览器的可视窗口大小，我们可以先加载前端的可视区域内容，剩下的内容等它进入可视区域后再按需加载。</p><p>具体怎么做呢？我们可以先根据手机的可视窗口，估算需要多少条数据，比如京东 App 列表页是 4 条数据，这时候，先从后端拉取 4 条数据进行展现，然后超出首屏的内容，可以在页面下拉或者滚动时再发起加载。</p><p>那么如果首页当中图片比较多，比如搜索引擎产品的首页，如何保证首屏秒开呢？同样也可以采用懒加载。以百度图片列表页为例，可视区域范围内的图片先请求加载，一般会根据不同手机机型估算一个最大数据，比如 ihone12 Pro 屏幕比较大， 4 行 8 条数据，我们就先请求 8 条数据，用来在可视区域展示，其他位置采用占位符填充，在滑动到目标区域位置后，才使用真实的图片填充。这样，通过使用懒加载，可以最大限度降低了数据接口传输阶段的时间。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>如果说懒加载本质是提供首屏后请求非关键内容的能力，那么缓存则是赋予二次访问不需要重复请求的能力。在首屏优化方案中，接口缓存和静态资源缓存起到中流砥柱的作用。</p><h3 id="接口缓存"><a href="#接口缓存" class="headerlink" title="接口缓存"></a>接口缓存</h3><p>接口缓存的实现，如果是端内的话，所有请求都走 Native 请求，以此来实现接口缓存。为什么要这么做呢？</p><p>App 中的页面展现有两种形式，使用 Native 开发的页面展现和使用 H5 开发的页面展现。如果统一使用 Native 做请求的话，已经请求过的数据接口，就不用请求了。而如果使用 H5 请求数据，必须等 WebView 初始化之后才能请求（也就是串行请求），而 Native 请求时，可以在 WebView 初始化之前就开始请求数据（也就是并行请求），这样能有效节省时间。</p><p>那么，如何通过 Native 进行接口缓存呢？<strong>我们可以借助 SDK 封装来实现，即修改原来的数据接口请求方法，实现类似 Axios 的请求方法。</strong>具体来说就是，把包括 post、Get 和 Request 功能的接口，封装进 SDK 中。</p><p>这样，客户端发起请求时，程序会调用 SDK.axios 方法，WebView 会拦截这个请求，去查看 App 本地是否有数据缓存，如果有的话，就走接口缓存，如果没有的话，先向服务端请求数据接口，获取接口数据后存放到 App 缓存中。</p><h3 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h3><p>数据接口的请求一般来说较少，只有几个，而静态资源（如 JS、CSS、图片和字体等）的请求就太多了。以京东首页为例，177 个请求中除了 1 个文档和 1 个数据接口外，其余都是静态资源请求。</p><p>那么，如何做静态缓存方案呢？这里有两种情况，一种是静态资源长期不需要修改，还有一种是静态资源修改频繁的</p><p>资源长期不变的话，比如 1 年都不怎么变化，我们可以使用强缓存，如 Cache-Control 来实现。具体来说可以通过设置 Cache-Control:max-age=31536000，来让浏览器在一年内直接使用本地缓存文件，而不是向服务端发出请求。</p><p>至于第二种，<strong>如果资源本身随时会发生改动的，可以通过设置 Etag 实现协商缓存</strong> 具体来说，在初次请求资源时，设置 Etag（比如使用资源的 md5 作为 Etag），并且返回 200 的状态码，之后请求时带上 <code>If-none-match</code> 字段，来询问服务器当前版本是否可用。如果服务端数据没有变化，会返回一个 304 的状态码给客户端，告诉客户端不需要请求数据，直接使用之前缓存的数据即可</p><h3 id="离线化"><a href="#离线化" class="headerlink" title="离线化"></a>离线化</h3><p>离线化是指线上实时变动的资源数据静态化到本地，访问时走的是本地文件的方案。说到这里，你是不是想到了离线包？离线包是离线化的一种方案，是将静态资源存储到 App 本地的方案，不过，在这里，我重点讲的是离线化的另一个方案——把页面内容静态化到本地。</p><p>离线化一般适合首页或者列表页等不需要登录页面的场景，同时能够支持 SEO 功能。那么，如何实现离线化呢？其实，打包构建时预渲染页面，前端请求落到 index.html 上时，已经是渲染过的内容。此时，可以通过 Webpack 的 <code>prerender-spa-plugin</code>来实现预渲染，进而实现离线化。Webpack 实现预渲染的代码示例如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> PrerenderSpaPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PrerenderSpaPlugin(</span><br><span class="line">      <span class="comment">// 编译后的html需要存放的路径</span></span><br><span class="line">      path.join(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">      <span class="comment">// 列出哪些路由需要预渲染</span></span><br><span class="line">      [ <span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/contact'</span> ]</span><br><span class="line">    )</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h3><p>懒加载、缓存和离线化都是在请求本身上下功夫，想尽办法减少请求或者推迟请求，并行化则是在请求通道上功夫，解决请求阻塞问题，进而减少首屏时间。 这就像解决交通阻塞一样，除了限号减少车辆，还可以增加车道数量，我们在处理请求阻塞时，也可以加大请求通道数量——借助于HTTP 2.0 的多路复用方案来解决。</p><p>HTTP 1.1 时代，有两个性能瓶颈点，串行的文件传输和同域名的连接数限制（6个），到了HTTP 2.0 时代，因为提供了多路复用的功能，传输数据不再使用文本传输（文本传输必须按顺序传输，否则接收端不知道字符的顺序），而是采用二进制数据帧和流的方式进行传输。</p><p>其中，帧是数据接收的最小单位，流是连接中的一个虚拟通道，它可以承载双向信息。每个流都会有一个唯一的整数 ID 对数据顺序进行标识，这样接收端收到数据后，可以按照顺序对数据进行合并，不会出现顺序出错的情况。所以，在使用流的情况下，不论多少个资源请求，只要建立一个连接即可。</p><p>文件传输环节问题解决后，同域名连接数限制问题怎么解决呢？以 Nginx 服务器为例，原先因为每个域名有 6 个连接数限制，最大并发就是 100 个请求，采用 HTTP 2.0 之后，现在则可以做到 600，提升了 6倍。</p><p>你一定会问，这不是运维侧要做的事情吗，我们前端开发需要做什么？我们要改变静态文件合并（JS、CSS、图片文件）和静态资源服务器做域名散列这两种开发方式。</p><p>具体来说，使用 HTTP 2.0 多路复用之后，单个文件可以单独上线，不需要再做 JS 文件合并了。因为原先遇到由 A 和 B 组成的 C 文件，其中 A 文件稍微有点修改，整个C 文件就需要重新加载的情况，如今由于没有同域名连接数限制了，也就不需要了。</p><p><img src="http://img-repo.poetries.top/images/20210503162414.png" alt></p><h2 id="八、优化手段：白屏-300ms-和界面流畅优化技巧"><a href="#八、优化手段：白屏-300ms-和界面流畅优化技巧" class="headerlink" title="八、优化手段：白屏 300ms 和界面流畅优化技巧"></a>八、优化手段：白屏 300ms 和界面流畅优化技巧</h2><h3 id="白屏优化"><a href="#白屏优化" class="headerlink" title="白屏优化"></a>白屏优化</h3><p>现在我们假设一个场景，有一天你想要在某电商 App 上买个手机，于是你搜索后进入商品列表页，结果屏幕一片空白，过了好久还是没什么内容出现，这时候你是不是会退出来，换另外一个电商 App 呢？这就是白屏时间过长导致用户跳出的情形。</p><p>作为前端开发者，我们遇到这种问题如何解决呢？首先去性能平台上查看白屏时间指标，确认是否是白屏问题。问题确认后，我们可以基于影响白屏时间长短的两个主要因素来解决——DNS 查询和首字符展示。</p><h3 id="DNS-查询优化"><a href="#DNS-查询优化" class="headerlink" title="DNS 查询优化"></a>DNS 查询优化</h3><p>DNS 查询是指浏览器发起请求时，需要将用户输入的域名地址转换为 IP 地址的过程，这个转换时间长短就会影响页面的白屏时间。</p><p>那么如何对 DNS 查询进行优化呢？根据 DNS 查询过程，我们可以从前端和客户端这两部分采取措施。</p><p>前端侧，可以通过在页面中加入 <code>dns-prefetch</code>，在静态资源请求之前对域名进行解析，从而减少用户进入页面的等待时间。如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://s.google.com/&quot; &gt;</span><br></pre></td></tr></table></figure><p>其中第一行中的 <code>x-dns-prefetch-control</code> 表示开启 <code>DNS</code> 预解析功能，第二行 <code>dns-prefetch</code> 表示强制对 <code>s.google.com</code> 的域名做预解析。这样在 <code>s.google.com</code> 的资源请求开始前，<code>DNS</code> 解析完成，后续请求就不需要重复做解析了。不要小看这个标签哦，它可以为你减少 <code>150ms</code> 左右的 DNS 解析时间。</p><p>客户端侧呢？可以在启动 App 时，同步创建一个肉眼不可见的 WebView（例如 1*1 像素的 webview），将常用的静态资源路径写入这个 WebView 中，然后对它做域名解析并放入缓存中。这样后面需要使用 WebView 打开真正所需的页面时，由于已经做过域名解析了，客户端直接从缓存中获取即可。</p><p>当然如果是端外页面，因为没在 App 里面，就没法使用 <code>1*1 WebView</code> 的策略了，我们可以使用 <code>iframe</code> ，也能达到类似效果。</p><p>以上是一个轻量级的方案，通过它可以将 DNS 解析时间控制在 <code>400ms</code> 以内（这个算是比较快的）。如果你想要将耗时进一步压缩，比如控制在 200ms，此时就需要一个重量级的方案了。具体来说，可以采用 IP 直连方式，原来是请求 <code>www.google.com</code>，现在我们通过调用 SDK 进行域名解析，拿到对应的 IP（如 6.6.6.6），然后直接请求这个 IP 地址拿到数据。</p><p>当然，这个实现起来需要避过许多坑，比如，HTTPS 证书和配置文件。</p><p><code>Https</code> 证书是指当客户端使用 IP 直连时，请求 URL 中的 host 会被替换成对应的 IP，所以在证书验证时，会出现 domain 不匹配的情况，导致 SSL/TLS 握手不成功。</p><p>怎么解决呢？在非 SNI（Server Name Indication，表示单 IP多域名）的场景下，可以把证书验证环节独立出来 （如 Hook证书校验环节），然后将 IP 替换为原来的域名。在 SNI 场景下，可以定制 <code>SSLSocketFactory</code>，在 createSocket 时替换为 IP，并进行 SNI/HostNameVerify 配置。</p><p>而配置文件方面，一般在域名只有两三个的情况时，我们可以用到它来做 IP 和域名的映射。但随着机房的扩大，每次扩机器都要升级配置文件，后续会非常麻烦。</p><p>对此我们可以采用 httpDNS 来解决。这是因为 httpDNS 可以准确调度到对应区域的服务器 IP 地址给用户，同时还可以避免运行商 DNS 劫持。具体来说， SDK 会通过发报文（类似系统向 DNS 运营商发的报文）向 httpDNS 做一个 HTTP 请求（也是通过 IP 直接请求），请求通过后拿到对应域名，然后进行 IP 直连，完成资源或者数据接口请求。</p><h3 id="首字符展示优化"><a href="#首字符展示优化" class="headerlink" title="首字符展示优化"></a>首字符展示优化</h3><p>所谓首字符展示，通常我们会在页面加载过程中出现一个 loading 图，用来告诉用户页面内容需要加载，请耐心等待。但这样一个 loading 图既无法让用户感受到页面加载到什么程度，也无法给用户视觉上一个焦点，让人们的注意力集中在上面。</p><p>如何解决这个问题呢？我们可以使用骨架屏。骨架屏（Skeleton Screen）是指在页面数据加载完成前，先给用户展示出页面的大致结构（灰色占位图），告诉用户页面正在渐进式地加载中，然后在渲染出实际页面后，把这个结构替换掉。骨架屏并没有真正减少白屏时间，但是给了用户一个心理预期，让他可以感受到页面上大致有什么内容。</p><p>那么，如何构建骨架屏呢？因为考虑到每次视觉修改或者功能迭代，骨架屏都要配合修改，我建议采用自动化方案，而不是手动骨架屏方案（也就是自己编写骨架屏代码）。骨架屏的实现方法有以下三个步骤。</p><ul><li>步骤一，确定生成规则，遍历所有的 DOM 元素。针对特定区块（如视频、音频）生成相应的代码块，获取原始页面中 DOM 节点的宽度、高度和距离视窗的位置，计算出当前设备快高对应的大小，转换成相应的百分比，然后来适配不同的设备。</li><li>步骤二，基于上述规则结合 CLI 工具可以通过脚手架自动生成骨架屏</li><li>步骤三，将骨架屏自动化注入页面，再利用 Puppeteer 把骨架屏代码注入页面中自动运行。整个过程比较复杂，且有不少坑</li></ul><p>以上就是白屏时间优化方面相关的内容，但即便首屏展示比较快，如果有卡顿的现象，用户操作也会很不流畅，那怎么解决这个问题呢。下面我们就讲聊聊卡顿治理。</p><h3 id="卡顿治理"><a href="#卡顿治理" class="headerlink" title="卡顿治理"></a>卡顿治理</h3><p>卡顿现象，一般可以通过用户反馈或性能平台来发现。比如我们接到用户说某页面比较卡，然后在性能平台上查看卡顿指标后，发现页面出现连续 5 帧超过 50ms ，这就属于严重卡顿。如何处理呢？</p><p>首先也还是问题的定位，先通过 charles 等工具抓包看一下数据接口，如果是和数据相关的问题，找后端同事，或者用数据缓存的方式解决。如果问题出在前端，一般和以下两种情形有关：<code>浏览器的主线程与合成线程调度不合理，以及计算耗时操作</code>。</p><h3 id="浏览器的主线程与合成线程调度不合理"><a href="#浏览器的主线程与合成线程调度不合理" class="headerlink" title="浏览器的主线程与合成线程调度不合理"></a>浏览器的主线程与合成线程调度不合理</h3><p>比如，在某电商 App 页面点击抽奖活动时，遇到一个红包移动的效果，在红包位置变化时，页面展现时特别卡，这就是主线程和合成线程调度的问题。怎么解决呢？</p><p>一般来说，主线程主要负责运行 JavaScript，计算 CSS 样式，元素布局，然后交给合成线程，合成线程主要负责绘制。当使用 height、width、margin、padding 等作为 transition 值时，会让主线程压力很大。此时我们可以使用 transform 来代替直接设置 margin 等操作。</p><p>比如红包元素从 margin-left:-10px 渲染到 margin-left:0，主线程需要计算样式 margin-left:-9px，margin-left:-8px，一直到 margin-left:0，每一次主线程计算样式后，合成线程都需要绘制到 GPU 再渲染到屏幕上，来来回回需要进行 10 次主线程渲染，10 次合成线程渲染，这给浏览器造成很大压力，从而出现卡顿。</p><p>如何解决呢？我们可以利用 transform 来做，比如 tranform:translate(-10px,0) 到 transform:translate(0,0)，主线程只需要进行一次tranform:translate(-10px,0) 到 transform:translate(0,0)，然后合成线程去一次将 -10px 转换到 0px。这样的话，总计 11 次计算，可以减少 9 步操作，假设一次 10ms，将减少 90ms。</p><h3 id="计算耗时操作"><a href="#计算耗时操作" class="headerlink" title="计算耗时操作"></a>计算耗时操作</h3><p>除了主线程和合成线程调度不合理导致的卡顿，还有因为计算耗时过大导致的卡顿。遇到这类问题，一般有两种解法：空间换时间和时间换空间。</p><p>空间换时间方面，比如你需要频繁增加删除很多 DOM 元素，这时候一定会很卡，在对 DOM 元素增删的过程中最好先在 DocumentFragment （DOM文档碎片）上操作，而不是直接在 DOM上操作。只在最后一步操作完成后，将所有 DocumentFragment 的变动更新到 DOM上，从而解决频繁更新 DOM 带来的卡顿问题。</p><p>至于时间换空间，一般是通过将一个复杂的操作细分成一个队列，然后通过多次操作解决复杂操作的问题。</p><p><img src="http://img-repo.poetries.top/images/20210503163046.png" alt></p><h2 id="九、JS-SDK-设计"><a href="#九、JS-SDK-设计" class="headerlink" title="九、JS SDK 设计"></a>九、JS SDK 设计</h2><p><img src="http://img-repo.poetries.top/images/20210503170316.png" alt></p><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>网站的性能怎么样。不能单单是靠某种工具去检测，就能得出的结果。因为影响它的因素有很多（dns解析、网络、缓存…）</p><blockquote><p><code>Performance</code>是一个做前端性能监控离不开的<code>API</code>，最好在页面完全加载完成之后再使用，因为很多值必须在页面完全加载之后才能得到。最简单的办法是在<code>window.onload</code>事件中读取各种数据。</p></blockquote><p><strong>1. 页面加载</strong></p><blockquote><p>一个页面的请求到响应再到显示出来，需要经过下面一些重要过程，当我们在浏览器输入一个<code>URL</code>或者说点击一个<code>URL</code>开始，会出现如下流程</p></blockquote><ul><li>页面准备</li><li>重定向：在<code>header</code>定义了重定向才会有这个过程，如果没有重定向，不会产生这个过程。</li><li><code>app cache</code>：会先检查这个域名是否有缓存，如果有缓存就不需要DNS解析域名。这里的<code>app</code>是值应用程序<code>application</code>，不指手机<code>app</code>。</li><li><code>DNS</code>解析：把域名解析成<code>IP</code>，如果直接用<code>ip</code>地址访问，不产生这个过程。</li><li><code>TCP</code>连接：<code>http</code>协议是经过<code>TCP</code>来传输的，所以产生一个<code>http</code>请求就会有<code>TCP connect</code>，但是依赖于长连接，不会产生这个过程。</li><li><code>request header</code>：请求头信息。</li><li><code>request body</code>：请求体信息，比如<code>get</code>请求是没有请求体信息的，所以没有这个过程，这就是为什么把头跟体分开写的原因。</li><li><code>response header</code>：响应头信息。</li><li><code>response body</code>：响应体信息。</li><li>解析<code>HTML</code>结构</li><li>加载外部脚本和样式表文件：正常来说<code>JS</code>、<code>css</code>都是外部加载的，当然有不正常的人啊，比如我。</li><li>解析并执行脚本代码</li><li>构建与解析<code>HTML DOM</code>树：这个过程可以去了解下<code>DOM</code>树是怎样的就明白啦。</li><li>加载外部图片</li><li>页面加载完成，显示出来啦</li></ul><p><strong>2. 重定向分析</strong></p><ul><li><code>app cach</code></li><li><code>DNS</code>解析</li><li><code>TCP</code>连接</li><li><code>request header</code></li><li>重定向</li><li><code>app cach</code></li><li><code>DNS</code>解析</li><li><code>TCP</code>连接</li><li><code>request header</code></li></ul><p><strong>3. performance.timing</strong></p><blockquote><p>这个API能帮我们得到整个页面请求的时间，如下图，在<code>Chrome</code>的<code>Console</code>是可以直接运行的</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503170506.png" alt></p><p>先解释下这些时间都是代表什么</p><p><strong>timing 对象里边的数据比较多，梳理如下几个关键性的节点</strong></p><ul><li><code>fetchStart</code>：发起获取当前文档的时间点，我的理解是浏览器收到发起页面请求的时间点；</li><li><code>domainLookupStart</code>：返回浏览器开始<code>DNS</code>查询的时间，如果此请求没有<code>DNS</code>查询过程，如长连接、资源<code>cache</code>、甚至是本地资源等，那么就返回<code>fetchStart</code>的值；</li><li><code>domainLookupEnd</code>：返回浏览器结束<code>DNS</code>查询的时间，如果没有<code>DNS</code>查询过程，同上；</li><li><code>connectStart</code>：浏览器向服务器请求文档，开始建立连接的时间，如果此连接是一个长连接，或者无需与服务器连接（命中缓存），则返回<code>domainLookupEnd</code>的值；</li><li><code>connectEnd</code>：浏览器向服务器请求文档，建立连接成功的时间；</li><li><code>requestStart</code>：开始请求文档的时间（注意没有<code>requestEnd</code>）;</li><li><code>responseStart</code>：浏览器开始接收第一个字节数据的时间，数据可能来自于服务器、缓存、或本地资源；</li><li><code>unloadEventStart</code>：卸载上一个文档开始的时间；</li><li><code>unloadEventEnd</code>：卸载上一个文档结束的时间；</li><li><code>domLoading</code>：浏览器把<code>document.readyState</code>设置为<code>“loading”</code>的时间点，开始构建<code>dom</code>树的时间点；</li><li><code>responseEnd</code>：浏览器接收最后一个字节数据的时间，或连接被关闭的时间；</li><li><code>domInteractive</code>：浏览器把<code>document.readyState设</code>置为<code>“interactive”</code>的时间点，<code>DOM</code>树创建结束；</li><li><code>domContentLoadedEventStart</code>：文档发生<code>DOMContentLoaded</code>事件的时间；</li><li><code>domContentLoadedEventEnd</code>：文档的<code>DOMContentLoaded</code>事件结束的时间；</li><li><code>domComplete</code>：浏览器把<code>document.readyState</code>设置为<code>“complete”</code>的时间点；</li><li><code>loadEventStart</code>：文档触发<code>load</code>事件的时间；</li><li><code>loadEventEnd</code>：文档出发<code>load</code>事件结束后的时间</li></ul><blockquote><p>再来一张图，表示各阶段的开始与结束对应的时间</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503170539.png" alt></p><blockquote><p>从以上的分析，我们就可以得到一些时间的计算</p></blockquote><ul><li>准备新页面耗时：<code>fetchStart - navigationStart</code></li><li>重定向时间：<code>redirectEnd - redirectStart</code></li><li><code>App Cache</code>时间：<code>domainLookupStart - fetchStart</code></li><li><code>DNS</code>解析时间：<code>domainLookupEnd -domainLookupStart</code></li><li><code>TCP</code>连接时间：<code>connectEnd - connectStart</code></li><li><code>request</code>时间：<code>responseEnd - requestStart</code>这个计算是代表请求响应加起来的时间</li><li>请求完毕到<code>DOM</code>树加载：<code>domInteractive -responseEnd</code></li><li>构建与解析<code>DOM</code>树，加载资源时间：<code>domCompleter -domInteractive</code></li><li><code>load</code>时间：<code>loadEventEnd - loadEventStart</code></li><li>整个页面加载时间：<code>loadEventEnd -navigationStart</code></li><li>白屏时间：<code>responseStart-navigationStart</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> timing = performance.timing</span><br><span class="line"></span><br><span class="line"><span class="comment">// DNS 解析耗时</span></span><br><span class="line">timing.domainLookupEnd - timing.domainLookupStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP 连接耗时</span></span><br><span class="line">timing.connectEnd - timing.connectStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSL 安全连接耗时</span></span><br><span class="line">timing.connectEnd - timing.secureConnectionStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络请求耗时</span></span><br><span class="line">timing.responseStart - timing.requestStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据传输耗时</span></span><br><span class="line">timing.responseEnd - timing.responseStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM 解析耗时</span></span><br><span class="line">timing.domInteractive - timing.responseEnd</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源加载耗时</span></span><br><span class="line">timing.loadEventStart - timing.domContentLoadedEventEnd </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关键性能指标 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首包时间</span></span><br><span class="line">timing.responseStart - timing.domainLookupStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白屏时间</span></span><br><span class="line">timing.responseStart - timing.navigationStart </span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次可交互时间</span></span><br><span class="line">timing.domInteractive - timing.requestStart </span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML 加载完成时间， 即 DOM Ready 时间</span></span><br><span class="line">timing.domContentLoadedEventEnd - timing.navigationStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面完全加载时间</span></span><br><span class="line">timing.loadEventStart - timing.navigationStart</span><br></pre></td></tr></table></figure><p><strong>4. performance.getEntries()</strong></p><blockquote><p>这个API能帮我们获得资源的请求时间，包括JS、CSS、图片等</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503170603.png" alt></p><blockquote><p>如上图可以看到这个API请求返回的是一个数组，这个数组包括整个页面所有的资源加载，上图打开了一个其中一个资源，可以看到如下信息</p></blockquote><ul><li><code>entryType</code>：类型为<code>resource</code></li><li><code>name</code>：资源的<code>url</code></li><li><code>initiatorType</code>：资源是<code>link</code></li><li>资源时间：<code>duration</code>的值，是<code>responseEnd - startTime</code>得到的</li></ul><p><strong>performance.memory</strong></p><blockquote><p>这个API主要是得到浏览器内存情况</p></blockquote><ul><li><code>jsHeapSizeLimit</code>：内存大小限制</li><li><code>totalJSHeapSize</code>：可使用的内容</li><li><code>userdJSHeapSize</code>：已使用的内容</li></ul><blockquote><p><code>userdJSHeapSize</code>表示所有被使用的JS堆栈内存，<code>totalJSHeapSize</code>可使用的JS堆栈内存，如果<code>userdJSHeapSize</code>的值大于<code>totalJSHeapSize</code>，就可能出现内存泄漏</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503170616.png" alt></p><p><strong>5. getEntriesByType</strong></p><p>这个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType" target="_blank" rel="noopener">API</a> 可以让我们通过传入 <code>type</code> 获取一些相应的信息：</p><ul><li>frame：事件循环中帧的时间数据。</li><li>resource：加载应用程序资源的详细网络计时数据</li><li>mark：<code>performance.mark</code> 调用信息</li><li>measure：<code>performance.measure</code> 调用信息</li><li>longtask：长任务（执行时间大于 50ms）信息。这个类型已被废弃（文档未标注，但是在 Chrome 中使用会显示已废弃），我们可以通过别的方式来拿</li><li>navigation：浏览器文档事件的指标的方法和属性</li><li>paint：获取 FP 和 FCP 指标</li></ul><p>最后两个 <code>type</code> 是性能检测中获取指标的关键类型。当然你如果还想分析加载资源相关的信息的话，那可以多加上 <code>resource</code> 类型。</p><p><strong>6. PerformanceObserver</strong></p><p><code>PerformanceObserver</code>也是用来获取一些性能指标的 API，用法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> perfObserver = <span class="keyword">new</span> PerformanceObserver(<span class="function">(<span class="params">entryList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 信息处理</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 传入需要的 type</span></span><br><span class="line">perfObserver.observe(&#123; <span class="attr">type</span>: <span class="string">'longtask'</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>结合 <code>getEntriesByType</code> 以及 <code>PerformanceObserver</code>，我们就能获取到所有需要的指标了。</p></blockquote><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><p><strong>js 运行时报错</strong></p><blockquote><p>为了更好的保证网站正常的运行，我们会通过<code>window.onerror</code>捕获，js具体的堆栈信息和错误行和列。一般我们的js都是打包压缩、混淆后上传到cdn的（无法定位到具体错误）。因此在打包时，同时生产<code>.map</code>文件，用 <code>sourcemap</code> js库（nodejs）来还原具体错误信息</p></blockquote><p><strong>资源加载出错</strong></p><blockquote><p>为了防止加载资源失败，而导致网站打不开。一般我们会通过 <code>window.addEventListener(&#39;error&#39;)</code> 对资源加载进行监控。</p></blockquote><p><strong>后端api接口监控</strong></p><blockquote><p>一般对于小公司而言，可能连后端都很少会有接口方面的监控。一旦出现问题，却又不好排查问题，因此我们可以通过对浏览器底层的xhr对象进行拦截，上报相关调用数据和接口耗时。一方面可以检测到接口的实时调用情况，同时也方便后期对接口的数据统计。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503175341.png" alt></p><h3 id="数据处理和展示"><a href="#数据处理和展示" class="headerlink" title="数据处理和展示"></a>数据处理和展示</h3><p>用到 <code>es（elasticsearch）</code>来对数据进行实时查询和分析。可是怎么把数据推到es里面呢？这对于前端同学来说，这又是一个难点。别急，“logstash” 了解一下。logstash主要对数据进行采集、分析、过滤的工具，然后推送到es里面。数据既然有了，那么怎么展示呢？这时候 Kibana 出来了，来作为数据展示的承托。这就是后端开源届的日志分析系统“ELK”。</p><p><img src="http://img-repo.poetries.top/images/20210503175506.png" alt></p><p>其实对于数据的展示，可以不用kibana或者其他开源的产品进行展示，也可以自己通过es的restful接口，来搭建数据展示</p><p><img src="http://img-repo.poetries.top/images/20210503175531.png" alt></p><h2 id="十、前端监控系统实战"><a href="#十、前端监控系统实战" class="headerlink" title="十、前端监控系统实战"></a>十、前端监控系统实战</h2><h3 id="没有前端监控下的痛点有哪些"><a href="#没有前端监控下的痛点有哪些" class="headerlink" title="没有前端监控下的痛点有哪些"></a>没有前端监控下的痛点有哪些</h3><ul><li>用户反馈点击某个按钮没有任何反应。（没办法知道用户点了按钮，为什么没反应呢？是js报错导致，还是其它原因导致？）</li><li>用户反馈打开页面很慢。（没办法感知用户慢在什么地方）</li><li>调用后端api接口出错，无法第一时间感知。（只能被动等待用户告诉和自己去发现）</li><li>网站静态资源加载出错，导致网站打不开。</li><li>上报的js错误信息，怎么反解析出源代码报错位置。</li></ul><p><img src="http://img-repo.poetries.top/images/20210503175936.png" alt></p><h3 id="手动搭建一个前端监控系统"><a href="#手动搭建一个前端监控系统" class="headerlink" title="手动搭建一个前端监控系统"></a>手动搭建一个前端监控系统</h3><p>在搭建前端监控系统开始之前，我们先来了解下整个系统的架构是怎么样的。因为你只有了解到流程是怎样走的，才清楚每个步骤我们该做些什么事情。</p><p><img src="http://img-repo.poetries.top/images/20210503180034.png" alt></p><h3 id="JS-SDK-功能设计"><a href="#JS-SDK-功能设计" class="headerlink" title="JS SDK 功能设计"></a>JS SDK 功能设计</h3><p><strong>1. 监控js错误信息上报</strong></p><p>通过<code>window.onerror</code>方法，对页面js错误进行监控。上报具体的错误信息和堆栈信息（如下图），利用<code>webpack/gulp打包出来的.map文件</code>，来解析出具体的错误信息。</p><p><img src="http://img-repo.poetries.top/images/20210503180112.png" alt></p><p>nodejs通过上传.map文件，解析出具体错误信息。代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sourceMap = <span class="built_in">require</span>(<span class="string">'source-map'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _sourceMap = fs.readFileSync(resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>`</span>), <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过sourceMap库转换为sourceMapConsumer对象  </span></span><br><span class="line"><span class="keyword">let</span> consumer = <span class="keyword">await</span> <span class="keyword">new</span> sourceMap.SourceMapConsumer(_sourceMap);</span><br><span class="line"><span class="comment">// 传入要查找的行列数，查找到压缩前的源文件及行列数  </span></span><br><span class="line"><span class="keyword">let</span> sm = consumer.originalPositionFor(&#123;</span><br><span class="line">    line: line, <span class="attr">column</span>: column</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩前的所有源文件列表  </span></span><br><span class="line"><span class="keyword">let</span> sources = consumer.sources;</span><br><span class="line"><span class="comment">// 根据查到的source，到源文件列表中查找索引位置  </span></span><br><span class="line"><span class="keyword">let</span> smIndex = sources.indexOf(sm.source);</span><br><span class="line"><span class="comment">// 到源码列表中查到源代码  </span></span><br><span class="line"><span class="keyword">let</span> smContent = consumer.sourcesContent[smIndex];</span><br><span class="line"><span class="comment">// 将源代码串按"行结束标记"拆分为数组形式  </span></span><br><span class="line"><span class="keyword">const</span> rawLines = smContent.split(<span class="regexp">/\r?\n/g</span>);</span><br><span class="line"><span class="comment">// 输出源码行，因为数组索引从0开始，故行数需要-1  </span></span><br><span class="line"><span class="keyword">let</span> errInfo = []</span><br><span class="line">errInfo.push(&#123;</span><br><span class="line">    line: sm.line - <span class="number">2</span>,</span><br><span class="line">    text: rawLines[sm.line - <span class="number">2</span>]</span><br><span class="line">&#125;)</span><br><span class="line">errInfo.push(&#123;</span><br><span class="line">    line: sm.line - <span class="number">1</span>,</span><br><span class="line">    text: rawLines[sm.line - <span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line">errInfo.push(&#123;</span><br><span class="line">    line: sm.line,</span><br><span class="line">    text: rawLines[sm.line]</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ctx.body = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  code: <span class="number">1</span>,</span><br><span class="line">  data: errInfo,</span><br><span class="line">  msg: <span class="string">'success'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先在管理后台，上传对应错误js的map文件，最终还原效果图如下：</p><p><img src="http://img-repo.poetries.top/images/20210503180234.png" alt></p><p>通过上图，我们可以快速定位错误的具体位置，大大节省了排查错误的时间。</p><p><strong>2. api接口调用请求上报</strong></p><blockquote><p>可能有些朋友会好奇，怎么去实时监听ajax异步接口请求情况呢？其实很简单：首先我们先通过代理XMLHttpRequest对象，来实现对ajax异步请求进行数据劫持。如下图：</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503180304.png" alt></p><p>通过上图不难发现，我们通过xhr对象的<code>onreadystatechange</code>事件进行劫持，针对后端api接口返回的数据，进行处理上报接口的调用情况，因此达到实时监控接口调用情况，是不是觉得很神奇！</p><p>如有同学想了解这块内容具体的代码，github社区有开源的模块，可自行查看： <a href="https://github.com/wendux/Ajax-hook" target="_blank" rel="noopener">https://github.com/wendux/Ajax-hook</a></p><p>根据需要统计哪些数据进行上报，比如<code>:page query</code>参数、api接口请求数据…方便后续出错，定位问题。如下图：</p><p><img src="http://img-repo.poetries.top/images/20210503180352.png" alt></p><p><strong>3. 页面性能数据上报</strong></p><blockquote><p>关于页面性能数据，我们一般通过浏览器<code>performance.timingAPI</code>来进行上报</p></blockquote><p><strong>各阶段耗时图</strong></p><p><img src="http://img-repo.poetries.top/images/20210503180431.png" alt></p><p><strong>关键性能指标图</strong></p><p><img src="http://img-repo.poetries.top/images/20210503180455.png" alt></p><p><strong>4. 能支持自定义数据上报</strong></p><blockquote><p>上述一般都是自动进行错误采集进行上报，但有些情况是需要我们手动调用进行上报（自定义数据的埋点）。因此sdk的设计，最好支持手动调用上报。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> report = <span class="keyword">new</span> Reort(&#123;</span><br><span class="line">    参数配置...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// get 上报</span></span><br><span class="line">report.getRport(&#123;<span class="attr">xxx</span>: <span class="number">111</span>&#125;, (data) =&gt; &#123;</span><br><span class="line">    Consoel.log(<span class="string">'上报回调的数据：'</span>, data)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// post 上报</span></span><br><span class="line">report.postRport(&#123;<span class="attr">xxx</span>: <span class="number">111</span>&#125;, (data) =&gt; &#123;</span><br><span class="line">    Consoel.log(<span class="string">'上报回调的数据：'</span>, data)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>关于SDK设计的时候，需要注意的以下几点：</strong></p><ul><li>SDK上报采用哪种方式比较好。一般来说采用<code>get</code>（<code>image</code>方式上报，因为它避免的跨域的限制，目前也是业界主流的上报方式）</li><li>在SDK上报方式，最好设计<code>get</code>和<code>post</code>两种方式上报。因为有些复杂的数据结构，采用post上报，在服务端解析会比较方便。</li><li>当网站每天的pv很大时，要支持抽样上报，减少服务器资源。（一般做法，通过每次随机一个数值，来跟预设定的值做比较）</li><li>如有想对一些错误信息不需要上报，要支持排查哪些错误信息上报。</li><li>如果针对<code>get</code>上报时，一般是在<code>xx.gif</code>后带参数，一定要对参数进行转义，不然在某些场景下会报错！</li><li>针对采集<code>page</code>参数时，也要进行<code>encodeURIComponent</code>进行转义，不然在某些场景下会报错！</li><li>要支持站点级别的功能，因为你想要接入不同的项目。就得根据不同的做区分和报警设置。思路很简单通过增加一个站点id值，来作为后续数据的筛选条件。比如：<code>pid</code></li></ul><h3 id="服务端接收数据，并记录日志"><a href="#服务端接收数据，并记录日志" class="headerlink" title="服务端接收数据，并记录日志"></a>服务端接收数据，并记录日志</h3><blockquote><p>sdk设计好了，上报数据也有了。现在我们开始设计服务怎么接收和处理数据。以Nodejs为例：</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503180707.png" alt></p><blockquote><p>通过上图不难发现，我们通过接收到参数，然后通过decode解析出参数，并对参数进行处理。利用 nodejs <code>file-stream-rotator</code> 这个库，把数据写入本地到日志中。(不过在写入日志的时候，记得对一些数据进行校检。</p></blockquote><p>比如：不存在站点id，不给写入。对于外部网站的接口请求，不给写入。通过实战来看，有些情况，竟然会把UC浏览器部分请求给抓上来，所以需要过滤处理)</p><h3 id="数据收集与过滤"><a href="#数据收集与过滤" class="headerlink" title="数据收集与过滤"></a>数据收集与过滤</h3><blockquote><p>当数据写入日志文件中，通过Logstash监测日志变化，收集到数据并对数据进行格式化和过滤处理，并收集推送到ES（数据存储）。</p></blockquote><p>比如利用<code>geoip</code>和<code>useragent</code>插件，分别对ip和浏览器的UA进行解析，分别得到对应的地理位置信息和浏览器相关距离信息。如下图：</p><p><img src="http://img-repo.poetries.top/images/20210503180802.png" alt></p><p>关于<code>logstash</code>的安装和配置，在这里不多说啦，可自行google安装配置。（建议使用docker版本，简单省事）</p><h3 id="数据存储（ES）提供分析和查询能力"><a href="#数据存储（ES）提供分析和查询能力" class="headerlink" title="数据存储（ES）提供分析和查询能力"></a>数据存储（ES）提供分析和查询能力</h3><blockquote><p>通过ES（elasticsearch）提供对应的restful api，手动搭建数据大盘（或者用kibana）。对于es数据管理，前期可以先安装一个es-head的插件，来查看数据情况。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503180831.png" alt></p><blockquote><p>关于修改<code>es header 5.0 request content-type</code> 不对的情况。可以对 <code>/usr/src/app/_site/ vendor.js</code> 文件进行修改。以docker镜像为例：</p></blockquote><ol><li>从从镜像<code>copy vendor.js</code>文件出来，如：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp elasticsearch-head:/usr/src/app/_site/vendor.js /Users/duanliang/logstash</span><br></pre></td></tr></table></figure><ol start="2"><li>修改ajax 请求<code>content-type</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大约在6886行</span><br><span class="line">/contentType: &quot;application/x-www-form-urlencoded</span><br><span class="line">改成</span><br><span class="line">contentType: &quot;application/json;charset=UTF-8&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>把文件copy回容器</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp /Users/duanliang/logstash/vendor.js elasticsearch-head:/usr/src/app/_site/vendor.js</span><br></pre></td></tr></table></figure><ol start="4"><li>重启镜像</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart elasticsearch-head</span><br></pre></td></tr></table></figure><p>你可能用到的 docker 镜像地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">es：docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.4</span><br><span class="line"></span><br><span class="line">es-headder: docker pull mobz/elasticsearch-head:5 </span><br><span class="line"></span><br><span class="line">logstash: docker.elastic.co/logstash/logstash:6.5.4</span><br></pre></td></tr></table></figure><h3 id="告警配置"><a href="#告警配置" class="headerlink" title="告警配置"></a>告警配置</h3><blockquote><p>通过后台配置自定义报警规则，来告警开发人员。原理：通过nodejs启动定时任务来读取配置表，根据不同的规则去读取es里面的数据（一分钟查询一次），如果有错误，则通知报警。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210503181001.png" alt></p><p><img src="http://img-repo.poetries.top/images/20210503181010.png" alt></p><p><img src="http://img-repo.poetries.top/images/20210503181017.png" alt></p><p><img src="http://img-repo.poetries.top/images/20210503181025.png" alt></p><p>最终以：首页 Dashboard为例</p><p><img src="http://img-repo.poetries.top/images/20210503181035.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、性能优化方法论&quot;&gt;&lt;a href=&quot;#一、性能优化方法论&quot; class=&quot;headerlink&quot; title=&quot;一、性能优化方法论&quot;&gt;&lt;/a&gt;一、性能优化方法论&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://img-repo.poetries.top/ima
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="前端监控" scheme="http://blog.poetries.top/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>小程序插件总结</title>
    <link href="http://blog.poetries.top/2021/04/20/wx-weapp-plugin/"/>
    <id>http://blog.poetries.top/2021/04/20/wx-weapp-plugin/</id>
    <published>2021-04-20T12:01:24.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、小程序插件功能介绍"><a href="#一、小程序插件功能介绍" class="headerlink" title="一、小程序插件功能介绍"></a>一、小程序插件功能介绍</h2><blockquote><p>插件的开发和使用自小程序基础库版本 <code>1.9.6</code> 开始支持</p></blockquote><ul><li>插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用</li><li>插件不能独立运行，必须嵌入在其他小程序中才能被用户使用</li><li>第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用</li><li>会受到一些限制，如一些 API 无法调用或功能受限。还有个别特殊的接口，虽然插件不能直接调用，但可以使用 插件功能页 来间接实现</li><li>框架会对小程序和小程序使用的每个插件进行数据安全保护，保证它们之间不能窃取其他任何一方的数据（除非数据被主动传递给另一方）。</li></ul><blockquote><p>插件，是可被添加到小程序内直接使用的功能组件。开发者可以像开发小程序一样开发一个插件，供其他小程序使用。同时，小程序开发者可直接在小程序内使用插件，无需重复开发，为用户提供更丰富的服务</p></blockquote><p>插件可以是</p><ul><li>提供查询快递信息的服务</li><li>提供查询天气的服务</li><li>提供打车（滴滴）的服务 - 可以使用滴滴提供的组件，直接嵌入自己的小程序，实现打车功能）</li><li>提供外卖（美团外卖）的服务 - 例如每个餐厅需要的小程序风格都不一样，但他都需要外卖功能，那这时就可以给餐厅都定制一个小程序，在外卖部分的功能可以直接使用美团外卖提供的外卖插件（*后面发现插件居然不能微信支付）</li></ul><blockquote><p>除了可以做这些方面还有很多很多，但小程序插件目前限制了开放范围及服务类目（<a href="https://developers.weixin.qq.com/miniprogram/introduction/plugin.html#%E5%BC%80%E6%94%BE%E8%8C%83%E5%9B%B4%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%B1%BB%E7%9B%AE" target="_blank" rel="noopener">开放类目</a>）</p></blockquote><p><strong>开放范围</strong>：企业、媒体、政府及其他组织主体</p><p>开发者可选择当前小程序帐号已选类目中的一个，作为插件的服务类目。以下为当前已开放的插件服务类目，将逐步开放更多类目。</p><table><thead><tr><th>一级类目</th><th>二级类目</th><th>特殊说明</th></tr></thead><tbody><tr><td>快递业与邮政</td><td>所有二级类目</td><td></td></tr><tr><td>医疗</td><td>就医服务、互联网医院</td><td>仅医疗类小程序可使用</td></tr><tr><td>政务民生</td><td>所有二级类目</td><td></td></tr><tr><td>金融业</td><td>征信业务</td><td></td></tr><tr><td>出行与交通</td><td>所有二级类目</td><td></td></tr><tr><td>生活服务</td><td>票务、生活缴费</td><td></td></tr><tr><td>IT科技</td><td>所有二级类目</td><td></td></tr><tr><td>餐饮</td><td>点评与推荐、菜谱、餐厅排队、点餐平台、外卖平台</td><td></td></tr><tr><td>旅游</td><td>所有二级类目</td><td></td></tr><tr><td>文娱</td><td>视频、FM/电台、音乐、有声读物、动漫</td><td></td></tr><tr><td>工具</td><td>记账、投票、日历、天气、备忘录、办公、字典、计算类、报价/比价、发票查询、企业管理</td><td></td></tr><tr><td>电商平台</td><td>电商平台</td><td></td></tr><tr><td>商业服务</td><td>招聘/求职</td><td></td></tr><tr><td>汽车</td><td>所有二级类目</td></tr></tbody></table><p><strong>开发小程序插件的流程</strong></p><ol><li>开通入口：<code>小程序管理后台-小程序插件</code></li><li>开通插件功能 条件：企业、媒体、政府及其他组织主体的小程序，个人小程序不行 个数：一个小程序只能开通一个插件</li><li>填写开发信息并开发 限制：填写了小程序插件基本信息和头像就不能修改</li><li>提交审核、发布 限制：在开发类目内才能提交 官方文档说“插件发布后才可以被其他小程序搜索并添加”，但实际上不是，没有发布的也可以搜索到和添加</li></ol><h2 id="二、创建插件项目"><a href="#二、创建插件项目" class="headerlink" title="二、创建插件项目"></a>二、创建插件项目</h2><p>小程序的 AppID 可以创建小程序插件项目，插件是独立于小程序之外的，但是 AppID 是公用的，所以<code>不要使用原有的小程序项目进行插件开发</code>。 在创建项目页面，选择一个空文件夹作为项目路径，可以选择创建小程序插件快速启动模板</p><blockquote><p>没有插件appId的，我们需要去申请一个，用来开发插件</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210419092828.png" alt></p><ul><li><code>miniprogram</code> 目录：放置一个小程序，用于调试插件。<ul><li>文件夹是一个普通小程序项目，用来编写小程序插件的使用 Demo，上传插件代码时这个 Demo 会一起上传，并作为小程序插件的发布的审核依据.</li></ul></li><li><code>plugin</code> 文件就是小程序插件项目，用来编写小程序插件的代码。</li><li><code>project.config.json</code> 需要关注 <code>compileType</code> 字段，<code>compileType == &#39;plugin&#39;</code> 时才能正常的使用插件项目。详情</li><li><code>doc 目录</code>：插件文档必须放置在插件项目根目录中的 doc 目录下<ul><li>插件文档的入口文件是 <code>doc/README.md</code>，在 <code>README.md</code> 中引用到的图片资源不能是网络图片，且必须放在这个目录下。</li><li>文档中的链接只能链接到<ul><li>微信开发者社区（developers.weixin.qq.com）</li><li>微信公众平台（mp.weixin.qq.com）</li><li>GitHub（github.com）</li></ul></li><li>编辑 <code>README.md</code> 之后，可以在开发者工具左侧资源管理器的文件栏中右键单击<code>README.md</code>，并选择上传文档。发布上传文档后，文档不会立刻发布。此时可以使用帐号和密码登录 管理后台 ，在 <code>小程序插件 &gt; 基本设置</code> 中预览、发布插件文档</li><li>插件文档<code>总大小不能大于 2M</code>，超过时上传将返回错误码 80051<br><img src="http://img-repo.poetries.top/images/20210419093822.png" alt></li></ul></li></ul><h3 id="2-1-插件目录结构"><a href="#2-1-插件目录结构" class="headerlink" title="2.1 插件目录结构"></a>2.1 插件目录结构</h3><p>一个插件可以包含若干个自定义组件、页面，和一组 js 接口。插件的目录内容如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugin</span><br><span class="line">├── components</span><br><span class="line">│   ├── hello-component.js   <span class="comment">// 插件提供的自定义组件文件夹， 中自定义组件可以有多个</span></span><br><span class="line">│   ├── hello-component.json</span><br><span class="line">│   ├── hello-component.wxml</span><br><span class="line">│   └── hello-component.wxss</span><br><span class="line">├── pages</span><br><span class="line">│   ├── hello-page.js        <span class="comment">// 插件提供的页面（可以有多个，自小程序基础库版本 2.1.0 开始支持）</span></span><br><span class="line">│   ├── hello-page.json</span><br><span class="line">│   ├── hello-page.wxml</span><br><span class="line">│   └── hello-page.wxss</span><br><span class="line">├── index.js                 <span class="comment">//  插件入口文件，可以在这里 export 一些 js 接口，供插件使用者使用</span></span><br><span class="line">└── plugin.json              <span class="comment">//  插件的配置文件，主要说明有哪些自定义组件可以供插件外部调用，并标识哪个js文件是插件的js接口文件，默认的配置形式如下：</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"publicComponents"</span>: &#123;</span><br><span class="line">    <span class="string">"list"</span>: <span class="string">"components/list/list"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-插件配置文件"><a href="#2-2-插件配置文件" class="headerlink" title="2.2 插件配置文件"></a>2.2 插件配置文件</h3><blockquote><p>提供给使用者小程序使用的自定义组件必须在配置文件的 publicComponents 段中列出</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"publicComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"hello-component"</span>: <span class="string">"components/hello-component"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"pages"</span>: &#123;</span><br><span class="line">    <span class="attr">"hello-page"</span>: <span class="string">"pages/hello-page"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件将向使用者小程序开放一个自定义组件 <code>hello-component</code>，一个页面 <code>hello-page</code> 和 <code>index.js</code> 下导出的所有 js 接口。</p><h3 id="2-3-插件预览、上传和发布"><a href="#2-3-插件预览、上传和发布" class="headerlink" title="2.3 插件预览、上传和发布"></a>2.3 插件预览、上传和发布</h3><ul><li>插件可以像小程序一样预览和上传，但<code>插件没有体验版</code>。</li><li>插件会同时有多个线上版本，由使用插件的小程序决定具体使用的版本号。</li><li>手机预览和提审插件时，会使用一个特殊的小程序来套用项目中 miniprogram 文件夹下的小程序，从而预览插件。</li></ul><p><strong>在开发版小程序中测试</strong></p><ul><li>通常情况下，可以将 <code>miniprogram</code> 下的代码当做使用插件的小程序代码，来进行插件的调试和测试</li><li>但有时，<code>需要将插件的代码放在实际运行的小程序中进行调试、测试</code>。此时，<code>可以使用开发版的小程序直接引用开发版插件</code>。方法如下：</li></ul><ol><li>在开发者工具的插件项目中上传插件，此时，在上传成功的通知信息中将包含这次上传获得的插件开发版 ID （一个英文、数字组成的随机字符串）；</li><li>点击开发者工具右下角的通知按钮，可以打开通知栏，看到<code>新生成的 ID</code> ；</li><li>在需要使用开发版本插件的小程序项目中，将插件 <code>version</code> 设置为 <code>&quot;version&quot;: &quot;dev-[开发版 ID]&quot;</code> 的形式，如 <code>&quot;version&quot;: &quot;dev-abcdef0123456789abcdef0123456789&quot;</code> 即可。</li></ol><blockquote><p>如果开发版小程序引用了开发版插件，此时这个小程序就不能上传发布了。必须要将插件版本设为正式版本之后，小程序才可以正常上传、发布</p></blockquote><p><strong>注意事项：</strong></p><ul><li><code>每次上传插件所生成的 ID 不一定相同</code>，即使是同一个插件和同一个开发者，<code>多次上传也可能会改变 ID</code>；</li><li>每个开发者在每个插件中只会同时存在一个有效的开发版插件，即只有最新上传的开发版 ID 有效（使用旧的 ID 会提示失效）；</li><li>同一个插件不同开发者上传的开发版互不影响，可以同时有效；</li><li>开发版插件没有时间限制，长期有效。</li></ul><h2 id="三、使用插件"><a href="#三、使用插件" class="headerlink" title="三、使用插件"></a>三、使用插件</h2><ul><li><strong>添加插件</strong><ul><li>在使用插件前，首先要在小程序管理后台的<code>“设置-第三方服务-插件管理”</code>中添加插件。开发者可登录小程序管理后台，通过 appid 查找插件并添加。如果插件无需申请，添加后可直接使用；否则需要申请并等待插件开发者通过后，方可在小程序中使用相应的插件。<br><img src="http://img-repo.poetries.top/images/20210416164731.png" alt></li></ul></li><li><p><strong>引入插件代码包</strong></p><ul><li><p>使用插件前，使用者要在 <code>app.json</code> 中声明需要使用的插件，例如</p><ul><li><p><strong>在主包中使用插件</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: &#123;</span><br><span class="line">    <span class="attr">"myPlugin"</span>: &#123;</span><br><span class="line">      <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">      <span class="attr">"provider"</span>: <span class="string">"wxidxxxxxxxxxxxxxxxx"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>plugins</code> 定义段中可以包含多个插件声明，每个插件声明以一个使用者自定义的插件引用名作为标识，并指明插件的 appid 和需要使用的版本号。其中，引用名（如上例中的 myPlugin）由使用者自定义，无需和插件开发者保持一致或与开发者协调。在后续的插件使用中，该引用名将被用于表示该插件</li></ul></li><li><p><strong>在分包内引入插件代码包</strong></p><ul><li><p>如果插件只在一个分包内用到，可以将插件仅放在这个分包内，例如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"subpackages"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"root"</span>: <span class="string">"packageA"</span>,</span><br><span class="line">      <span class="attr">"pages"</span>: [</span><br><span class="line">        <span class="string">"pages/cat"</span>,</span><br><span class="line">        <span class="string">"pages/dog"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"plugins"</span>: &#123;</span><br><span class="line">        <span class="attr">"myPlugin"</span>: &#123;</span><br><span class="line">          <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">          <span class="attr">"provider"</span>: <span class="string">"wxidxxxxxxxxxxxxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在分包内使用插件有如下限制：</p><ul><li>仅能在这个分包内使用该插件</li><li>同一个插件不能被多个分包同时引用</li></ul></li></ul></li></ul></li></ul></li></ul><p><strong>使用插件方式</strong></p><blockquote><p>使用插件时，插件的代码对于使用者来说是不可见的。阅读由插件开发者提供的插件开发文档，通过文档来明确插件提供的自定义组件、页面名称及提供的 js 接口规范等。</p></blockquote><ul><li><p><strong>使用插件提供的自定义组件</strong></p><ul><li>使用插件提供的自定义组件，和 使用普通自定义组件 的方式相仿。在 json 文件定义需要引入的自定义组件时，使用 <code>plugin:// 协议指明插件的引用名和自定义组件名</code>，例如</li><li><p>插件跳转到自身页面时， url 应设置为这样的形式：<code>plugin-private://PLUGIN_APPID/PATH/TO/PAGE</code> 。需要跳转到其他插件时，也可以这样设置 url 。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"hello-component"</span>: <span class="string">"plugin://myPlugin/hello-component"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出于对插件的保护，插件提供的自定义组件在使用上有一定的限制：</p><ul><li>默认情况下，页面中的 <code>this.selectComponent</code> 接口无法获得插件的自定义组件实例对象；</li><li><code>wx.createSelectorQuery</code> 等接口的 &gt;&gt;&gt; 选择器无法选入插件内部</li></ul></li></ul></li><li><p><strong>使用插件提供的页面</strong></p><ul><li>需要跳转到插件页面时，url 使用 <code>plugin:// 前缀</code>，形如 <code>plugin://PLUGIN_NAME/PLUGIN_PAGE</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"plugin://myPlugin/hello-page"</span>&gt;</span></span><br><span class="line">  Go to pages/hello-page!</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>js 接口</strong></p><ul><li><p>使用插件的 js 接口时，可以使用 <code>requirePlugin</code> 方法。例如，插件提供一个名为 hello 的方法和一个名为 world 的变量，则可以像下面这样调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myPluginInterface = requirePlugin(<span class="string">'myPlugin'</span>);</span><br><span class="line"></span><br><span class="line">myPluginInterface.hello();</span><br><span class="line"><span class="keyword">var</span> myWorld = myPluginInterface.world;</span><br></pre></td></tr></table></figure></li><li><p>基础库 <code>2.14.0</code> 起，也可以通过<code>插件的 AppID 来获取接口</code>，如：<code>var myPluginInterface = requirePlugin(&#39;wxidxxxxxxxxxxxxxxxx&#39;)</code></p></li></ul></li><li><p><strong>使用插件的小程序可以导出内容到插件中共享</strong></p><ul><li>在声明使用插件时，可以通过 <code>export</code> 字段来指定一个文件<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"myPlugin": &#123;</span><br><span class="line">  "version": "dev",</span><br><span class="line">  "provider": "",</span><br><span class="line">  "export": "exportToPlugin.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://img-repo.poetries.top/images/20210419141729.png" alt></p><ul><li>导出的内容可以被这个插件用全局函数获得。例如，在上面的文件中，使用插件的小程序做了如下导出：<br><img src="http://img-repo.poetries.top/images/20210419141948.png" alt></li></ul></li></ul><p><strong>为插件提供小程序自定义组件</strong></p><blockquote><p>在插件中可以将一部分区域交给使用的小程序来渲染</p></blockquote><p>给插件名为 <code>plugin-index</code> 的页面中的抽象节点 <code>mp-view</code> 指定小程序的自定义组件 <code>components/comp-from-miniprogram</code> 作为实现的话</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"myPlugin"</span>: &#123;</span><br><span class="line">    <span class="attr">"provider"</span>: <span class="string">"wxAPPID"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"genericsImplementation"</span>: &#123;</span><br><span class="line">      <span class="attr">"plugin-index"</span>: &#123;</span><br><span class="line">        <span class="attr">"mp-view"</span>: <span class="string">"components/comp-from-miniprogram"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- miniprogram/page/index.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin-view</span> <span class="attr">generic:mp-view</span>=<span class="string">"comp-from-miniprogram"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、插件的一些限制"><a href="#四、插件的一些限制" class="headerlink" title="四、插件的一些限制"></a>四、插件的一些限制</h2><h3 id="4-1-调用-API-的限制"><a href="#4-1-调用-API-的限制" class="headerlink" title="4.1 调用 API 的限制"></a>4.1 调用 API 的限制</h3><ul><li>插件的请求域名列表与小程序相互独立；</li><li>一些 API 不允许插件调用（这些函数不存在于 wx 对象下）。</li><li>有些接口虽然在插件中不能使用，但可以通过插件功能页来达到目的，请参考插件功能页。</li></ul><p><strong>小程序插件中不能使用API</strong></p><table><thead><tr><th>wx.login</th><th>登录</th></tr></thead><tbody><tr><td>wx.getUserInfo</td><td>获取用户信息</td></tr><tr><td>wx.chooseAddress</td><td>获取用户收货地址</td></tr><tr><td>wx.requestPayment</td><td>【发起微信支付】</td></tr><tr><td>wx.addCard</td><td>添加卡券</td></tr><tr><td>wx.openCard</td><td>打开卡券</td></tr><tr><td>wx.saveFile</td><td>保存文件</td></tr><tr><td>wx.getSavedFileList</td><td>获取已保存的文件列表</td></tr><tr><td>wx.getSavedFileInfo</td><td>获取已保存的文件信息</td></tr><tr><td>wx.removeSavedFile</td><td>删除已保存的文件信息</td></tr><tr><td>wx.openDocument</td><td>打开文件</td></tr><tr><td>wx.getStorageInfo</td><td>获取本地缓存的相关信息</td></tr><tr><td>wx.getStorageInfoSync</td><td>获取本地缓存的相关信息</td></tr><tr><td>wx.clearStorage</td><td>清理本地数据缓存</td></tr><tr><td>wx.clearStorageSync</td><td>清理本地数据缓存</td></tr><tr><td>wx.setNavigationBarTitle</td><td>设置当前页面标题</td></tr><tr><td>wx.showNavigationBarLoading</td><td>显示导航条加载动画</td></tr><tr><td>wx.hideNavigationBarLoading</td><td>隐藏导航条加载动画</td></tr><tr><td>wx.navigateTo</td><td>新窗口打开页面</td></tr><tr><td>wx.redirectTo</td><td>原窗口打开页面</td></tr><tr><td>wx.switchTab</td><td>切换到 tabbar 页面</td></tr><tr><td>wx.navigateBack</td><td>退回上一个页面</td></tr><tr><td>wx.stopPullDownRefresh</td><td>停止下拉刷新动画</td></tr></tbody></table><h3 id="4-2-使用组件的限制"><a href="#4-2-使用组件的限制" class="headerlink" title="4.2 使用组件的限制"></a>4.2 使用组件的限制</h3><p>在插件开发中，以下组件不能在插件页面中使用：</p><ul><li>开放能力（open-type）为以下之一的 button： contact（打开客服会话） getPhoneNumber（获取用户手机号） getUserInfo（获取用户信息）</li><li>open-data</li><li>web-view 以下组件的使用对基础库版本有要求</li><li>navigator 需要基础库版本 2.1.0</li><li>live-player 和 live-pusher 需要基础库版本 2.3.0</li></ul><h3 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h3><ul><li><strong>插件间互相调用</strong><ul><li>插件不能直接引用其他插件。但如果小程序引用了多个插件，插件之间是可以互相调用的。</li><li>一个插件调用另一个插件的方法，与插件调用自身的方法类似。可以使用 <code>plugin-private://APPID 访问插件的自定义组件、页面</code>（暂不能使用 plugin:// ）。</li><li>对于 js 接口，可使用 <code>requirePlugin</code> ，但目前尚不能在文件一开头就使用 <code>requirePlugin</code> ，因为被依赖的插件可能还没有初始化，请考虑在更晚的时机调用 <code>requirePlugin</code> ，如接口被实际调用时、组件 attached 时</li></ul></li></ul><h2 id="五、插件功能页"><a href="#五、插件功能页" class="headerlink" title="五、插件功能页"></a>五、插件功能页</h2><h3 id="5-1-插件功能页"><a href="#5-1-插件功能页" class="headerlink" title="5.1 插件功能页"></a>5.1 插件功能页</h3><p>插件功能页从小程序基础库版本 <code>2.1.0</code> 开始支持。</p><blockquote><p>某些接口不能在插件中直接调用（如 <code>wx.login</code>），但插件开发者可以使用插件功能页的方式来实现功能。目前，插件功能页包括</p></blockquote><ul><li>获取用户信息，包括 <code>openid</code>和昵称等（相当于 <code>wx.login</code> 和 <code>wx.getUserInfo</code>的功能），详见用户信息功能页</li><li>支付（相当于 <code>wx.requestPayment</code>），详见支付功能页；</li><li>获取收货地址（相当于 <code>wx.chooseAddress</code>），详见收货地址功能页。</li></ul><blockquote><p>要使用插件功能页，需要先激活功能页特性，配置对应的功能页函数，再使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/functional-page-navigator.html" target="_blank" rel="noopener">functional-page-navigator</a> 组件跳转到插件功能页，从而实现对应的功能</p></blockquote><ul><li>激活功能页特性<ul><li>要在插件中调用插件功能页，需要先激活插件所有者小程序的功能页特性</li><li><code>app.json</code> 文件中添加 <code>functionalPages</code> 定义段<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"functionalPages"</span>: &#123;</span><br><span class="line">    <span class="attr">"independent"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-2-跳转到功能页"><a href="#5-2-跳转到功能页" class="headerlink" title="5.2 跳转到功能页"></a>5.2 跳转到功能页</h3><blockquote><p>功能页不能使用 <code>wx.navigateTo</code> 来进行跳转，而是需要一个名为 <code>functional-page-navigator</code> 的组件。以获取用户信息为例，可以在插件中放置如下的 <code>functional-page-navigator</code></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">functional-page-navigator</span> <span class="attr">name</span>=<span class="string">"loginAndGetUserInfo"</span> <span class="attr">args</span>=<span class="string">""</span> <span class="attr">version</span>=<span class="string">"develop"</span> <span class="attr">bind:success</span>=<span class="string">"loginSuccess"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录到插件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">functional-page-navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>用户在点击这个 <code>navigator</code> 时，会自动跳转到插件所有者小程序的对应功能页。功能页会提示用户进行登录或其他相应的操作。操作结果会以组件事件的方式返回。</li><li>从小程序基础库版本 2.4.0 开始，支持插件所有者小程序跳转到自己的功能页。在基础库版本低于 2.4.0 时，点击跳转到自己的功能页的 <code>functional-page-navigator</code> 将没有任何反应</li></ul><blockquote><p>注意：<code>functional-page-navigator</code> 的 <code>version=develop</code> 仅用于调试，因此在插件提审前，需要：</p></blockquote><ul><li>确保已发布设置了 <code>&quot;functionalPages&quot;: true</code> 的插件所有者小程序；</li><li>确保所有的 <code>functional-page-navigator</code> 组件属性设置为 <code>version=&quot;release&quot;</code></li></ul><h3 id="5-4-小程序部分功能页"><a href="#5-4-小程序部分功能页" class="headerlink" title="5.4 小程序部分功能页"></a>5.4 小程序部分功能页</h3><p><strong>1. 用户信息功能页</strong></p><blockquote><p>用户信息功能页用于帮助插件获取用户信息，包括 openid 和昵称等，相当于 wx.login 和 wx.getUserInfo 的功能。</p></blockquote><p>此外，自基础库版本 2.3.1 起，用户在这个功能页中授权之后，插件就可以直接调用 <code>wx.login 和 wx.getUserInfo</code> 。无需再次进入功能页获取用户信息。自基础库版本 2.6.3 起，可以使用 <code>wx.getSetting</code> 来查询用户是否授权过</p><p><strong>2. 支付功能页</strong></p><ul><li>支付功能页用于帮助插件完成支付，相当于 <code>wx.requestPayment</code> 的功能。</li><li>需要注意的是：插件使用支付功能，需要进行额外的权限申请，申请位置位于管理后台的<code>“小程序插件 -&gt; 基本设置 -&gt; 支付能力”</code>设置项中。另外，无论是否通过申请，主体为个人小程序在使用插件时，都无法正常使用插件里的支付功能。</li></ul><p><strong>3. 收货地址功能页</strong></p><p>收货地址功能页用于展示用户的收货地址列表，用户可以选择其中的收货地址。自基础库版本 2.4.0 开始支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、小程序插件功能介绍&quot;&gt;&lt;a href=&quot;#一、小程序插件功能介绍&quot; class=&quot;headerlink&quot; title=&quot;一、小程序插件功能介绍&quot;&gt;&lt;/a&gt;一、小程序插件功能介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;插件的开发和使用自小程序基础库版本 &lt;co
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="小程序" scheme="http://blog.poetries.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序反编译</title>
    <link href="http://blog.poetries.top/2021/04/20/wx-compile-summary/"/>
    <id>http://blog.poetries.top/2021/04/20/wx-compile-summary/</id>
    <published>2021-04-20T07:30:41.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>安装node</li><li>微信开发者工具</li><li>安装pc端模拟器工具选择<a href="http://mumu.163.com" target="_blank" rel="noopener">网易MuMu</a>，简单易操作</li></ol><p>需要安装以下两个软件，搜索框直接搜索即可</p><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/23931618899946_.pic_hd.jpg" alt></p><ul><li>微信：登录上模拟器微信打开需要下载的小程序</li><li>RE文件管理器：需要设置root权限，设置-权限（查看小程序压缩包）</li></ul><ol start="4"><li><a href="https://github.com/xuedingmiaojun/wxappUnpacker" target="_blank" rel="noopener">下载反编译工具</a></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> wxappUnpacker</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="获取小程序压缩包"><a href="#获取小程序压缩包" class="headerlink" title="获取小程序压缩包"></a>获取小程序压缩包</h2><ul><li>打开模拟器的微信并登录</li><li>在模拟器微信的下拉小程序找到小程序</li><li>打开小程序等待加载之后就可以去找源码包了（注意：每个页面都浏览一遍，确保子包都加载下载下来）</li><li>打开RE文件管理器,进入到以下路径查找源码包(可以根据下载时间区分出你想要的源码包)</li></ul><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/23941618900725_.pic_hd.jpg" alt></p><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/23951618900849_.pic_hd.jpg" alt></p><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/23961618900932_.pic_hd.jpg" alt></p><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/23971618901001_.pic_hd.jpg" alt></p><p>选择压缩文件发送给好友保存到电脑上</p><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/23981618901112_.pic_hd.jpg" alt></p><h2 id="编译主包"><a href="#编译主包" class="headerlink" title="编译主包"></a>编译主包</h2><p><strong>执行命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _-1215506245_427.wxapkg 主包</span></span><br><span class="line">$ ./bingo.sh 小程序压缩包/_-1215506245_427.wxapkg</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/2221618902029_.pic_hd.jpg" alt><br><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/2231618902381_.pic_hd.jpg" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node /Users/poetry/Downloads/小程序反编译工具/wuWxapkg.js</span><br><span class="line">Unpack file 小程序压缩包/_-1215506245_427.wxapkg...</span><br><span class="line"></span><br><span class="line">Header info:</span><br><span class="line">  firstMark: 0xbe</span><br><span class="line">  unknownInfo:  0</span><br><span class="line">  infoListLength:  15360</span><br><span class="line">  dataLength:  2960164</span><br><span class="line">  lastMark: 0xed</span><br><span class="line"></span><br><span class="line">File list info:</span><br><span class="line">  fileCount:  375</span><br><span class="line">Saving files...</span><br><span class="line">Unpack done.</span><br><span class="line">Split app-service.js and make up configs &amp; wxss &amp; wxml &amp; wxs...</span><br><span class="line">deal config ok</span><br><span class="line">deal js ok</span><br><span class="line">deal wxss.js ok</span><br><span class="line">deal css ok</span><br><span class="line">=======================================================</span><br><span class="line">这个小程序采用了分包</span><br><span class="line">子包个数为:  6</span><br><span class="line">=======================================================</span><br><span class="line">Decompile ./components/articlelist/articlelist.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/bigplate/bigplate.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/chart/chart.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/collect/collect.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/community/community.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/emptycart/emptycart.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/f2-canvas/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/findSell/findSell.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/footer/footer.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/formtea/formtea.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/goodList/goodList.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/guideList/guideList.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/hotplate/hotplate.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/icons/icons.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/navSimple/navSimple.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/newProductList/newProductList.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/newRetail/newRetail.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/newSellList/newSellList.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/popup/popup.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/productlist/productlist.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/publish/publish.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/reload/reload.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/retail/retail.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/searchcommunity/searchcommunity.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/searchretail/searchretail.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/tarBar/tarbar.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/tea/tea.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/teaLarge/teaLarge.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/tealist/tealist.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./components/theme/theme.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/action-sheet/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/area/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/button/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/calendar/calendar.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/calendar/components/header/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/calendar/components/month/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/calendar/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/card/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/cell-group/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/cell/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/checkbox-group/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/checkbox/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/circle/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/col/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/collapse-item/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/collapse/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/count-down/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/datetime-picker/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/dialog/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/divider/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/dropdown-item/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/dropdown-menu/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/empty/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/field/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/goods-action-button/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/goods-action-icon/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/goods-action/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/grid-item/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/grid/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/icon/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/image/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/index-anchor/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/index-bar/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/info/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/loading/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/nav-bar/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/notice-bar/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/notify/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/overlay/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/panel/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/picker-column/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/picker/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/picker/toolbar.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/popup/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/progress/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/radio-group/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/radio/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/rate/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/row/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/search/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/share-sheet/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/share-sheet/options.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/sidebar-item/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/sidebar/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/skeleton/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/slider/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/stepper/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/steps/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/sticky/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/submit-bar/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/swipe-cell/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/switch/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/tab/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/tabbar-item/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/tabbar/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/tabs/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/tag/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/toast/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/transition/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/tree-select/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/@vant/weapp/uploader/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./miniprogram_npm/wechat-miniprogram-rate/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/community/community.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/efamily/efamily.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/homepage/homepage.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/index/index.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/my2/my2.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/retailnew/retailnew.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./wxParse/wxParse.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Guess wxss(first turn)...</span><br><span class="line">splitJs: /Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427/app-service.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 address.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 aes.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 ajaxMethods/ajax.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 api.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 apiFunctions.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 common/canvas.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 common/chart.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 common/common.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 common/const.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/f2-canvas/miniprogram_npm/@antv/wx-f2/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/calendar/utils.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/circle/canvas.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/common/color.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/common/component.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/common/utils.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/common/version.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/count-down/utils.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/definitions/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/definitions/weapp.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/dialog/dialog.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/field/props.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/mixins/basic.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/mixins/button.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/mixins/link.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/mixins/open-type.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/mixins/page-scroll.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/mixins/touch.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/mixins/transition.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/notify/notify.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/picker/shared.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/toast/toast.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/uploader/shared.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/uploader/utils.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/flyio/engine-wrapper.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/flyio/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/jsbn/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/miniprogram-sm-crypto/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/address.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/ads.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/article.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/average.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/cart.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/chat.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/common.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/community.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/customer.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/edit.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/login.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/order.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/plate.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/postage.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/product.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/profession.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/publish.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/rate.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/recommend.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/register.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/reply.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/require.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/retail.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/search.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/settings.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/shop.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/statistics.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/stock.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/tea.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 module/vouchercenter.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 public.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 qqmap-wx-jssdk1.0/qqmap-wx-jssdk.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 qqmap-wx-jssdk1.0/qqmap-wx-jssdk.min.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 request.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 server.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 settings.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 tools.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 util.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 utils/log.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 utils/md5.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 utils/util.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 utils/wxcharts.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 wxParse/html2json.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 wxParse/htmlparser.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 wxParse/showdown.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 wxParse/wxDiscode.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 wxParse/wxParse.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 app.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/articlelist/articlelist.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/bigplate/bigplate.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/chart/chart.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/collect/collect.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/community/community.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/emptycart/emptycart.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/f2-canvas/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/findSell/findSell.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/footer/footer.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/formtea/formtea.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/goodList/goodList.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/guideList/guideList.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/hotplate/hotplate.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/icons/icons.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/navSimple/navSimple.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/newProductList/newProductList.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/newRetail/newRetail.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/newSellList/newSellList.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/popup/popup.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/productlist/productlist.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/publish/publish.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/reload/reload.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/retail/retail.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/searchcommunity/searchcommunity.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/searchretail/searchretail.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/tarBar/tarbar.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/tea/tea.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/teaLarge/teaLarge.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/tealist/tealist.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 components/theme/theme.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/action-sheet/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/area/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/button/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/calendar/components/header/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/calendar/components/month/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/calendar/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/card/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/cell-group/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/cell/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/checkbox-group/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/checkbox/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/circle/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/col/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/collapse-item/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/collapse/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/count-down/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/datetime-picker/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/dialog/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/divider/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/dropdown-item/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/dropdown-menu/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/empty/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/field/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/goods-action-button/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/goods-action-icon/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/goods-action/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/grid-item/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/grid/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/icon/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/image/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/index-anchor/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/index-bar/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/info/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/loading/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/nav-bar/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/notice-bar/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/notify/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/overlay/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/panel/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/picker-column/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/picker/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/popup/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/progress/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/radio-group/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/radio/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/rate/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/row/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/search/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/share-sheet/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/share-sheet/options.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/sidebar-item/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/sidebar/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/skeleton/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/slider/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/stepper/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/steps/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/sticky/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/submit-bar/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/swipe-cell/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/switch/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/tab/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/tabbar-item/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/tabbar/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/tabs/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/tag/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/toast/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/transition/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/tree-select/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/@vant/weapp/uploader/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 miniprogram_npm/wechat-miniprogram-rate/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 pages/index/index.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 pages/community/community.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 pages/my2/my2.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 pages/homepage/homepage.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 pages/efamily/efamily.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427 pages/retailnew/retailnew.js</span><br><span class="line">Splitting &quot;/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427/app-service.js&quot; done.</span><br><span class="line">Regard /Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427/miniprogram_npm/@vant/weapp/area/index.wxss as pure import file.</span><br><span class="line">Import count info: &#123;&quot;./miniprogram_npm/@vant/weapp/common/index.wxss&quot;:69&#125;</span><br><span class="line">Guess wxss(first turn) done.</span><br><span class="line">Generate wxss(second turn)...</span><br><span class="line">Generate wxss(second turn) done.</span><br><span class="line">Save wxss...</span><br><span class="line">saveDir: /Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_-1215506245_427</span><br><span class="line">Split and make up done.</span><br><span class="line">Delete files...</span><br><span class="line">Deleted.</span><br><span class="line"></span><br><span class="line">File done.</span><br><span class="line">Total use: 17898.449ms</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure><h2 id="编译分包"><a href="#编译分包" class="headerlink" title="编译分包"></a>编译分包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式： ./bingo.sh 分包.wxapkg -s=主包目录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./bingo.sh 小程序压缩包/_1462998946_427.wxapkg -s=test</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node /Users/poetry/Downloads/小程序反编译工具/wuWxapkg.js</span><br><span class="line">Unpack file 小程序压缩包/_1462998946_427.wxapkg...</span><br><span class="line"></span><br><span class="line">Header info:</span><br><span class="line">  firstMark: 0xbe</span><br><span class="line">  unknownInfo:  0</span><br><span class="line">  infoListLength:  2070</span><br><span class="line">  dataLength:  512073</span><br><span class="line">  lastMark: 0xed</span><br><span class="line"></span><br><span class="line">File list info:</span><br><span class="line">  fileCount:  32</span><br><span class="line">Saving files...</span><br><span class="line">Unpack done.</span><br><span class="line">now dir: /Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427</span><br><span class="line">param of mainDir: test</span><br><span class="line">sub package word dir: /Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/pages/subPackage/retail</span><br><span class="line">real mainDir: /Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test</span><br><span class="line">Split app-service.js and make up configs &amp; wxss &amp; wxml &amp; wxs...</span><br><span class="line">deal js ok</span><br><span class="line">deal sub html ok</span><br><span class="line">splitJs: /Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/pages/subPackage/retail/app-service.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/confirmorder/confirmorder.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/retaildetail/retaildetail.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/retailsearch/retailsearch.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/product/product.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/cart/cart.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/addresslist/addresslist.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/newaddress/newaddress.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/morerecommend/morerecommend.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/website/website.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/writecomment/writecomment.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/comment/comment.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/vouchercenter/vouchercenter.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/faq/faq.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/faqdetail/faqdetail.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/hotlist/hotlist.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/dwhindex/dwhindex.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/addTeaCommnet/addTeaCommnet.js</span><br><span class="line">/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test pages/subPackage/retail/pages/rule/rule.js</span><br><span class="line">Splitting &quot;/Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/pages/subPackage/retail/app-service.js&quot; done.</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/addTeaCommnet/addTeaCommnet.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/addresslist/addresslist.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/cart/cart.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/comment/comment.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/confirmorder/confirmorder.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/dwhindex/dwhindex.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/faq/faq.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/faqdetail/faqdetail.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/hotlist/hotlist.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/morerecommend/morerecommend.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/newaddress/newaddress.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/product/product.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/retaildetail/retaildetail.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/retailsearch/retailsearch.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/rule/rule.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/vouchercenter/vouchercenter.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/website/website.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Decompile ./pages/subPackage/retail/pages/writecomment/writecomment.wxml...</span><br><span class="line">Decompile success!</span><br><span class="line">Guess wxss(first turn)...</span><br><span class="line">Import count info: &#123;&#125;</span><br><span class="line">Guess wxss(first turn) done.</span><br><span class="line">Generate wxss(second turn)...</span><br><span class="line">Generate wxss(second turn) done.</span><br><span class="line">Save wxss...</span><br><span class="line">saveDir: /Users/poetry/Downloads/小程序反编译工具/小程序压缩包/_1462998946_427/test</span><br></pre></td></tr></table></figure><p>将分包内容拷贝至主包相应目录</p><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/2241618902951_.pic_hd.jpg" alt></p><blockquote><p>重复以上过程，把所有的分包都拷贝到主包对应的目录</p></blockquote><h2 id="导入微信开发者工具"><a href="#导入微信开发者工具" class="headerlink" title="导入微信开发者工具"></a>导入微信开发者工具</h2><ul><li>打开微信开发者工具，导入项目，选择随机appId测试</li><li>注意在项目设置中勾选不校验合法域名</li></ul><p><img src="https://hyzmj.oss-cn-shenzhen.aliyuncs.com/compile/2251618903031_.pic_hd.jpg" alt></p><p><strong>注意</strong></p><p><code>miniprogram_npm</code>包可能下载源码的时候没有完整合并，具体看报错提示处理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装node&lt;/li&gt;
&lt;li&gt;微信开发者工具&lt;/li&gt;
&lt;li&gt;安装pc端模拟器工具选择&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="小程序" scheme="http://blog.poetries.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发实践</title>
    <link href="http://blog.poetries.top/2021/04/18/wx-weapp-summary/"/>
    <id>http://blog.poetries.top/2021/04/18/wx-weapp-summary/</id>
    <published>2021-04-18T12:01:20.000Z</published>
    <updated>2021-05-11T03:46:23.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、双线程模型"><a href="#一、双线程模型" class="headerlink" title="一、双线程模型"></a>一、双线程模型</h2><h3 id="渲染线程和逻辑线程"><a href="#渲染线程和逻辑线程" class="headerlink" title="渲染线程和逻辑线程"></a>渲染线程和逻辑线程</h3><p>小程序的双线程指的就是渲染线程和逻辑线程，这两个线程分别承担UI的渲染和执行 JavaScript 代码的工作</p><p><img src="http://img-repo.poetries.top/images/20210418200413.png" alt></p><blockquote><p>渲染线程使用 Webview 进行 UI 的渲染呈现。Webview 是一个完整的类浏览器运行环境，本身具备运行 JavaScript 的能力，但是小程序并不是将逻辑脚本放到 Webview 中运行，而是将逻辑层独立为一个与 Webview 平行的线程，使用客户端提供的 JavaScript 引擎运行代码，iOS 的JavaScriptCore、安卓是腾讯 X5 内核提供的 JsCore 环境以及 IDE 工具的 nwjs </p></blockquote><p>并且逻辑线程是一个只能够运行 <code>JavaScript 的沙箱环境</code>，不提供 DOM 操作相关的 API，所以不能直接操作 UI，只能够通过 setData 更新数据的方式异步更新 UI</p><h3 id="事件驱动的通信方式"><a href="#事件驱动的通信方式" class="headerlink" title="事件驱动的通信方式"></a>事件驱动的通信方式</h3><blockquote><p>你要注意上图渲染线程和逻辑线程之间的通信方式，与 Vue/React 不同的是，小程序的渲染层与逻辑层之间的通信并不是在两者之间直接传递数据或事件，而是由 Native 作为中间媒介进行转发。</p></blockquote><p><strong>整个过程是典型的事件驱动模式：</strong></p><ul><li>渲染层（也可以称为视图层）通过与用户的交互触发特定的事件 event；</li><li>然后 event 被传递给逻辑层；</li><li>逻辑层继而通过一系列的逻辑处理、数据请求、接口调用等行为将加工好的数据 data 传递给渲染层；</li><li>最后渲染层将 data 渲染为可视化的 UI。</li></ul><blockquote><p>总的来说，跟浏览器的线程模型相比，小程序的双线程模型解决了或者说规避了 <code>Web Worker</code> 堪忧的性能同时又实现了与 <code>Web Worker</code> 相同的线程安全，从性能和安全两个角度实现了提升。可以概括地说，双线程模式是受限于浏览器现有的进程和线程管理模式之下，在小程序这一具体场景之内的一种改进的架构方案。</p></blockquote><blockquote><p>注意：浏览器中Worker 内的 JavaScript 代码不能操作 DOM，可以将其理解为线程安全的</p></blockquote><h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h3><ul><li>在保证功能的前提下尽量使用结构简单的 UI；</li><li>尽量降低 JavaScript 逻辑的复杂度；</li><li>尽量减少 setData 的调用频次和携带的数据体量。</li></ul><h2 id="二、-小程序的用户体系与-OAuth-规范"><a href="#二、-小程序的用户体系与-OAuth-规范" class="headerlink" title="二、 小程序的用户体系与 OAuth 规范"></a>二、 小程序的用户体系与 OAuth 规范</h2><p>微信小程序完整的登录流程</p><p><img src="http://img-repo.poetries.top/images/20210418202857.png" alt></p><blockquote><p>整个登录流程中描述了三种角色和六个术语，了解它们的定位和作用，是理解小程序登录流程的基础。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418202914.png" alt></p><p><strong>登录流程里的三个角色</strong></p><p>客户端在整个登录流程中主要承担两种行为：</p><ul><li>作为整个流程的发起者，获取临时登录凭证 code；</li><li>作为整个流程的终结者，存储登录态令牌 token。</li></ul><blockquote><ul><li>不过客户端的所有信息和网络请求几乎都是可以被破解或拦截的，所以出于安全的考虑，小程序登录流程中的一些接口被限制不能在客户端中直接调用，而是需要在服务端发起，开发者服务的工作便是处理这些安全敏感的网络请求，体现为上图中使用code 获取 openid 和 session_key的请求，这个请求使用了微信提供的 auth.code2Session 接口。</li><li>而微信接口服务的工作对于开发者来说是不透明的，你需要做的仅仅是根据接口的规范，组装网络请求发送给它，然后根据返回的接口执行分发逻辑。微信服务器会验证网络请求的合法性，对于合法请求下发密钥 session_key 和用户 openid</li></ul></blockquote><p><strong>登录流程的六个术语</strong></p><ul><li><strong>code</strong><ul><li>它是在客户端（即小程序）内通过 wx.login API 获取的，然后通过 HTTP 请求发送给开发者服务器。code 的作用体现在“临时”两字上，它的有效期限仅有 5 分钟，并且仅能够使用一次（即请求一次 auth.code2Session 接口）。</li></ul></li><li><strong>appid</strong><ul><li>每个微信小程序在创建之后（即在微信公众平台注册并初始化完成）便同时生成了一appid，这个 ID 标记了小程序的唯一性，等同于网站的URL（经过备案的）、App 的包名等标记应用唯一性的信息</li></ul></li><li><strong>appsecret</strong><ul><li>它是小程序的密钥，可以在微信公众平台的后台管理系统中获取。appsecret　是非常私密的信息，所以微信在制定小程序登录的流程时，将携带此信息的网络请求限制在只能通过开发者服务器发送给微信接口服务，这样对于客户端来说是不可见的，进而降低了被泄露的可能性。与appid 不同的是，appsecret 可以被重置，但每次重置之后，历史的 appsecret 便会失效，所以请谨慎操作。</li></ul></li><li><strong>openid</strong><ul><li><strong>这里你要注意，很多开发者容易走入一个误区：</strong> 误将 openid 理解为用户的唯一 ID。这句话如果放在某个小程序的特定语境下是没有问题的，但是如果放在微信生态的全局角度上是错误的。为什么呢？</li><li>微信对于用户 openid 的定义是：微信号在某个应用程序中的唯一 ID。这里的“某个应用程序”指的是小程序、公众号、接入开放平台的应用。微信生态中目前有公众平台和开放平台两种，其中公众平台又细分为小程序和公众号，开放平台可以接入网站、移动应用等。同一个微信号在不同的应用程序中有不同的 openid。</li><li>在微信生态下另外有一个标记微信号的唯一 ID：UnionId。这个 ID 跟应用程序无关。所以，可以简单地理解为 UnionId 与 appid 综合加密后的结果，见下图：<br><img src="http://img-repo.poetries.top/images/20210418203102.png" alt></li><li><code>UnionId 通常用来关联在不同应用程序中各个 openid</code>，比如同一个微信号在小程序和公众号内需要配置同样的权限，仅通过 openid 无法实现，便需要获取此微信号的 UnionId。虽然获取 UnionId 的流程并不在这节课的讨论范围之内，但我相信你在后续工作中一定会遇到处理 UnionId 和 openid 的场景，所以先了解一下没啥坏处</li></ul></li><li><strong>session_key</strong><ul><li>session_key 是对用户数据进行加密签名的密钥，微信服务器使用它将用户的数据进行加密和解密。你可以简单地将 session_key 理解为获取用户数据的“绿卡”，登录之后所有涉及访问微信服务器的请求一般都需要带上它，微信服务器会校验 session_key 的合法性。</li><li>其实到这一步（即拿到了 openid 和 session_key）已经完成了小程序的登录流程，但对于一个应用程序来说，用户进行登录操作应该是“一劳永逸”的，即登录过一次之后在一定时间之内的后续操作都不需要再次登录，用技术语言描述就是应该保存用户的登录态。这个时候就需要用到接下来的一个术语：token。</li></ul></li><li><p><strong>token</strong></p><ul><li>登录态是个逻辑词汇，token 可以理解为登录态的具象化、数据化。在小程序的登录流程图中，你可以看出，token是由开发者服务器创建的一个字符串，而且需要跟 openid 和 session_key 相关联。其实这里并不是强制关联 openid，因为 openid 并不算是私密信息，可以放心地下发到客户端（即小程序）。但是 session_key 是非常私密的信息，一旦泄露有很大的安全隐患，所以强烈建议不要把它下发到客户端。</li><li><p>在获取到 openid 和 session_key 之后，开发者服务器创建一个 token，然后与 openid 和session_key 进行关联，具体的方法根据服务器编程语言的不同有多种实现方案。咱们以JavaScript 语言作为示例，可以创建一个对象，对象的 key 是 token 的值，value 是一个包含 openid 和 session_key 的对象，如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"token_1"</span>: &#123;</span><br><span class="line">        <span class="attr">"openid"</span>: <span class="string">"获取到的openid 1"</span>,</span><br><span class="line">        <span class="attr">"session_key"</span>: <span class="string">"获取到的session_key 1"</span></span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="string">"token_2"</span>: &#123;</span><br><span class="line">        <span class="attr">"openid"</span>: <span class="string">"获取到的openid 2"</span>,</span><br><span class="line">        <span class="attr">"session_key"</span>: <span class="string">"获取到的session_key 2"</span></span><br><span class="line">    &#125;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关联完成之后开发者服务器将 token下发到客户端，客户端保存在本地，后续的所有请求均需要携带此 token，携带的方法并没有既定的规范，可以通过 URL Query、HTTP Body、Header 等，但通常建议通过 Header 传递，这样相对来说更安全一些。</p></li></ul></li></ul><p><strong>OAuth 2.0 规范中的角色划分</strong></p><p>咱们先思考一个问题：小程序登录之后如果需要访问用户的数据（比如昵称、地域、性别等）需要得到谁的授权？是微信？还是用户？</p><blockquote><p>答案是用户。用户的数据虽然存放在微信的服务器之上，但是这些数据的所有权属于用户自己，而不是微信。这里其实引出了 OAuth 2.0 规范中的两个基本概念。</p></blockquote><ul><li><code>Resource Owner</code>：资源所有者，即用户；</li><li><code>Resource Server</code>：资源服务器，即微信。</li></ul><p>而小程序在获取用户数据中的角色是作为微信平台的第三方应用程序，在 OAuth 2.0 规范中的术语为 Third-party application。</p><h2 id="三、自定义组件"><a href="#三、自定义组件" class="headerlink" title="三、自定义组件"></a>三、自定义组件</h2><p><strong>自定义组件的资源管理</strong></p><blockquote><p>创建微信小程序自定义组件需要使用 Component 构造器，这是微信小程序结构体系内最小粒度的构造器，外层是 Page 构造器，最外层的是 App 构造器，三者的关系如下图：</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418203745.png" alt></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  behaviors:[],</span><br><span class="line">  properties:&#123;&#125;,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  lifetimes: &#123;&#125;,</span><br><span class="line">  pageLifetimes: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>我们可以对照 Vue 和 React 讲解 Component 构造器的几个属性，这样更容易理解：</p></blockquote><ul><li><code>behaviors</code> 类似于 Vue 和 React 中的 <code>mixins</code>，用于定义多个组件之间的共享逻辑，可以包含一组 properties、data、lifetimes 和 methods 的定义；</li><li><code>properties</code> 类似于 Vue 和 React 中的 props ，用于接收外层（父组件）传入的数据；</li><li>data 类似于 Vue 中的 data 以及 React 中的 state ，用于描述组件的私用数据（状态）；</li><li>lifetimes 用于定义组件自身的生命周期函数，这种写法是从小程序基础库 2.2.3 版本引入的，原本的写法与 Vue 和 React 类似，都是直接挂载到组件的一级属性上</li><li>pageLifetimes 是微信小程序自定义组件独创的一套逻辑，用于监听此组件所在页面的生命周期。一般用于在页面特定生命周期时改变组件的状态，比如在页面展示时（show）把组件的状态设置为 A，在页面隐藏时（hide）设置为 B；</li><li>methods 与 Vue 的 methods 类似，用于定义组件内部的函数</li></ul><p><strong>自定义组件的生命周期</strong></p><p><img src="http://img-repo.poetries.top/images/20210418204017.png" alt></p><p><strong>组件间的通信流程</strong></p><p>与 Vue/React 不同，小程序没有类似 Vuex 或 Redux 数据流管理模块，所以<code>小程序的自定义组件之间的通信流程采用的是比较原始的事件驱动模式，即子组件通过抛出事件将数据传递给父组件，父组件通过 properties 将数据传递给子组件</code></p><p>假设小程序的某个页面中存在两个组件，两个组件均依赖父组件（Page）的部分属性，这部分属性通过 properties 传递给子组件</p><p><img src="http://img-repo.poetries.top/images/20210418204124.png" alt></p><p>当组件 A 需要与组件 B 进行通信时，会抛出一个事件通知父组件 Page，父组件接收到事件之后提取事件携带的信息，然后通过 properties 传递给组件 B。这样便完成了子组件之间的消息传递。</p><p>除了事件驱动的通信方式以外，小程序还提供了一种更加简单粗暴的方法：<code>父组件通过selectComponent 方法直接获取某个子组件的实例对象，然后就可以访问这个子组件的任何属性和方法了</code>。随后将这个子组件的某个属性通过 properties传递个另外一个子组件。相较而言，<code>事件驱动的方法更加优雅，在流程上也更加可控</code>，所以通常建议使用事件驱动的通信方式。</p><h2 id="四、性能优化"><a href="#四、性能优化" class="headerlink" title="四、性能优化"></a>四、性能优化</h2><blockquote><p>微信 IDE 的小程序评分功能位于<code>调试器-&gt; Audits 面板中</code></p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418204322.png" alt></p><blockquote><p>点击“运行”之后，微信 IDE 会对当前的小程序项目进行评测（包括代码层面的检测、通过记录用户交互行为的体验检测）。最终从性能、体验和最佳实践三个维度分别打分以及综合分：</p></blockquote><ul><li>性能评分是通过对页面渲染、网络、JS 脚本等方面的评估综合得来的；</li><li>体验评分是从设计和交互等方面的评估而来，由于设计和交互存在一定的主观因素，所以体验的评分权当建议；</li><li>最佳实践涉及的方面更宽泛，除了代码编写方面的建议</li></ul><p><strong>小程序性能优化的具体维度</strong></p><p>微信 IDE 对小程序性能进行评分有以下几个维度</p><ul><li>避免过大的 WXML 节点数目</li><li>避免执行脚本的耗时过长的情况</li><li>避免首屏时间太长的情况</li><li>避免渲染界面的耗时过长的情况</li><li>对网络请求做必要的缓存以避免多余的请求</li><li>所有请求的耗时不应太久</li><li>避免 setData 的调用过于频繁</li><li>避免 setData 的数据过大</li><li>避免短时间内发起太多的图片请求</li><li>避免短时间内发起太多的请求</li></ul><p><strong>1. 避免过大的 WXML 节点数目</strong></p><blockquote><p>WXML 是基于 HTML 的一种 DSL（Domain Specific Language，领域专属语言），除了原生组件（比如 Camera 相机组件）以外，常规组件最终会被小程序的渲染线程通过 WebView 渲染为 HTML ，所以<code>从性能优化的角度上，HTML 的大部分性能优化方案均适用于 WXML，尽量减少节点数目就是方案之一</code></p></blockquote><p><code>节点数目会影响渲染性能</code>，要理解这句话，你要对浏览器的渲染流程有大概了解，来看下面这张图：</p><p><img src="http://img-repo.poetries.top/images/20210418204601.png" alt></p><blockquote><ul><li>HTML 是 XML 的变体，在渲染的时候首先会被浏览器内核解析为 DOM 树，这是一种树形结构，然后会解析每个节点标签的类型、属性等要素，最后与 JavaScript 脚本和 CSS 结合起来进而在经过布局和绘制完成整个渲染流程</li><li>理论上 HTML 的节点数目和深度是没有限制的，但是从浏览器的渲染流程中不难看出，DOM 树的结构越复杂，渲染的管线就会越慢</li><li>降低节点数目对于性能优化的另外一个原因，是与小程序 /Vue/React 这种 MVVM 框架的 DOM更新机制有关。这类框架在更新 UI 时不直接操作 DOM ，而是使用 VDOM（ Virtual DOM，虚拟 DOM ）技术来实现，VDOM 的高性能来源于高效的 Diff 算法，在内存中对 VDOM 树结构进行对比后提取差异点再映射到真实 DOM 中。</li></ul></blockquote><p><strong>2. 避免执行脚本的耗时过长</strong></p><p>执行脚本的耗时过长对于性能的不良影响主要体现在两个时期：</p><ul><li>第一是在小程序加载完成后的首次渲染期间；</li><li>第二是小程序运行过程中的处理用户交互时期。</li></ul><blockquote><p>JavaScript 脚本对小程序首次渲染的影响与浏览器环境下 <code>&lt;script&gt;</code> 标签对 HTML 渲染的影响类似，虽然小程序中不允许使用 <code>&lt;script&gt;</code> 标签，双线程模型下 JavaScript 脚本也并不会完全阻塞 UI 线程的行为，但是<code>逻辑线程执行 JavaScript 代码时仍旧是单线程的</code>，通过任务队列管理代码的有序执行。如果某一段 JavaScript 代码<code>逻辑占时太长，造成任务队列过长</code>，最终会影响小程序在<code>响应用户交互行为上的长延时或卡顿</code></p></blockquote><p><strong>3. 避免首屏时间太长</strong></p><blockquote><p>影响首屏时间的因素非常多（比如 DNS 解析耗时、TCP 链接的建立耗时……）对于小程序开发者来说，有些因素是不可控的（比如 DNS 解析），那么在可控的众多因素当中，<code>最核心的两个优化方向是</code>：</p></blockquote><ul><li>代码优化；</li><li>网络优化。</li></ul><p>代码方向的优化措施重点关注这样几点：</p><ul><li>降低 WXML 的结构复杂度，比如节点个数和深度；</li><li>降低首次渲染的数据规模，首次渲染只包含核心数据，非核心数据的渲染可推迟到首屏渲染完成之后进行；</li><li>从设计和交互的角度出发，在实际内容被渲染之前展示友好的 loading 效果。</li></ul><p>而网络方向的优化核心是为了降低 <code>RTT</code>（ Road-Trip Time，往返时延），也就是微信 IDE 给出的“6.所有请求的耗时不应太多”这条建议。由于小程序的所有资源均托放在微信的服务器，所以不存在 CDN 和 DNS 优化问题，对于开发者来说，降低 RTT 最有效的两个措施是：</p><ul><li>减少网络请求所携带的数据体积，这是最直观的网络优化方案；</li><li>提高服务器处理网络请求的速度，这一点是对服务端的要求，除了服务端代码本身的性能以外，当用户量上升到一定规模之后，还需要服务器有处理高并发的能力。对于专注于端侧的传统前端和小程序开发者来说，这些知识是相对陌生的，往往需要后端的同学配合完成。这也是云开发相较于传统开发模式的主要优势之一，<code>使用云开发可以让端侧的开发者也能够开发出弹性伸缩、高并发、高 QPS 处理的服务层</code></li></ul><p><strong>4. 避免渲染界面的耗时过长的情况</strong></p><p>这是一条综合性能指标，渲染主要包括两个角度：</p><ul><li>一是首屏的渲染时间；</li><li>二是小程序运行期间的界面更新所需的渲染时间，我们不妨称之为动态渲染。</li></ul><blockquote><p>动态渲染是由 JavaScript 脚本中调用 setData 更新数据所触发，所以优化动态渲染的切入点便一目了然：优化 setData。至于具体的优化方案，便是微信 IDE 给出的<code>两点建议</code>：</p></blockquote><ul><li><strong>避免 setData 的调用过于频繁</strong>。<ul><li>频繁调用 setData 会造成逻辑线程与渲染线程之间过多的通信，01讲我们提到双线程之间的通行需要借助微信原生平台作转发，中间必然是有一定的性能损耗和时延。除此之外，渲染线程在接收到逻辑线程传递的数据之后，需要进行解析、VDOM 对比、更新 UI 等一套管线流程，在前一条流程执行完结之前，后面的数据只能排队等待执行。所以频繁调用 setData 就会造成队列加长，用户交互行为触发的 UI 更新就会缓慢甚至可能由于计算量太大造成卡顿。</li></ul></li><li><strong>避免 setData 的数据量太大</strong>。<ul><li>频繁调用 setData 会造成队列中的任务太多，而如果 setData 的数据量太大，则会造成单个任务的处理耗时加长。与上一条相比，一个是任务数量过多，一个是单个任务过重，两者最终对于性能产生的负面影响是一致的。此外，由于双线程之间需要借助微信原生平台转发，所以 setData 数据量过大也会造成通信时延的加长。</li></ul></li></ul><p><strong>5. 对网络请求做必要的缓存以避免多余的请求</strong></p><blockquote><p>小程序的资源文件托管在微信的服务器，所以小程序开发者不需要关注前端开发领域中对于静态资源的 HTTP 缓存策略，这件事情微信会帮助开发者完成。</p></blockquote><p>这一条建议所指的是在代码层面，将部分重复使用的网络请求结果在代码或 storage 中进行合理缓存以实现复用，对于使用同一个网络请求结果的代码可以直接从缓存中读取，进而减少了不必要的网络请求个数。每次网络请求不论时间长短，均需要用户等待，减少网络请求的个数相当于减少了用户等待时间，提升了用户体验</p><p><strong>6. 避免短时间内发起太多的图片请求</strong></p><ul><li>这一条与微信 IDE 给出的另一条建议“10.避免短时间内发起太多的请求”的方向是一致的，均是为了解决过多 HTTP 请求造成用户等待时间过长的问题。图片资源相对特殊的一个特点是体积较大，前端领域最早的懒加载方案便是主要针对图片资源，所以图片资源的请求对性能的影响更加直观一些。</li><li>目前前端和小程序领域中<code>使用的仍旧是 HTTP 1.1 协议，一个 TCP 链接同时只能处理一个 HTTP 请求</code>，在前一个请求得到服务器的响应之后才会发起第二个请求，如果同一时间的 HTTP 请求太多就会产生排队。</li><li>浏览器为了应对这种问题，提供了建立多个 TCP 连接以实现并行发送 HTTP 请求的目的，目前市面上的浏览器最多支持同时建立 <code>4~8 个 TCP 连接</code>。也就是说，最多可以同时处理 <code>4~8 个HTTP 请求</code>。如果同一时刻需要发送的 HTTP 请求数量远大于这个数字，那么还是会产生排队。前面的内容我们重复地提到了“排队”一词，不论是线程间的通信排队、任务队列的排队、还是 HTTP 请求的排队，这些行为都是需要用户等待的，对于用户的切身体验来说，便是响应缓慢甚至卡顿</li></ul><h2 id="五、使用-Webpack-提升小程序研发效率"><a href="#五、使用-Webpack-提升小程序研发效率" class="headerlink" title="五、使用 Webpack 提升小程序研发效率"></a>五、使用 Webpack 提升小程序研发效率</h2><p><strong>管理第三方 npm 模块</strong></p><p>微信小程序的早期版本不支持使用第三方 npm 包，在基础库 <code>2.2.1 版本</code>才开始支持。但是微信小程序使用 npm 模块的方式与 Node.js 的并不完全相同，虽然同样可以用包管理工具（<code>npm/yarn</code>）安装 npm 模块，但是在小程序源码中引入（require）npm 模块的路径并不是<code>node_modules</code>，而是 <code>miniprogram_npm</code> 目录。</p><p>开发者在使用 npm 模块之前必须使用微信 IDE 菜单栏中的“工具”-“构建 npm”，将原始的 npm 模块（即node_modules 目录中的模块）进行一次预构建，预构建的产出目录便是 <code>miniprogram_npm</code> ，最后才可以在小程序源码中引入（流程如下图所示）</p><p><img src="http://img-repo.poetries.top/images/20210418205903.png" alt></p><p>而且，小程序预构建 npm 模块的过程并不是简单地将原始模块从拷贝 <code>node_modules 目录到miniprogram_npm 目录</code>，而是会<code>将原始模块的所有散列文件打包成一个单 js 文件</code>，然后再将这个 <code>js 文件作为模块入口暴露出去</code></p><p><strong>整个预编译的流程如下：</strong></p><ul><li>读取小程序项目的 <code>package.json</code> 文件（位于 <code>miniprogram/package.json</code>）中有哪些依赖（<code>dependencies</code>）</li><li>在 <code>node_modules</code> 目录内依次寻找这些依赖的原始 npm 模块，读取模块的 <code>package.json</code> 文件，搜寻 <code>main</code> 字段指定的入口 js 文件</li><li>分析模块的入口 js 文件引用了哪些子文件</li><li>将所有文件打包为一个单 js 文件</li></ul><p><img src="http://img-repo.poetries.top/images/20210418210030.png" alt></p><p>你要注意，在执行第四步时，微信 IDE 并不会将原始 npm 模块所依赖的其他 npm 模块一并打包。 比如，现实工作中的网络请求模块 axios ，这个基础模块可能被某个 npm 模块（假设为模块 A）依赖，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &apos;axios&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>那么微信 IDE 在编译 A 的时候并不会将 axios 的代码一起打包为单 js 文件，而是会保留代码中对于 axios 模块的引用。同时会根据依赖关系寻找 axios 模块的 package.json 文件，然后执行上述的 2~3 步骤，也就是把 axios 模块也编译为单 js 文件</p></blockquote><p>最终的效果就是 miniprogram_npm 目录中存在模块 A 和模块 axios 两个子目录。这样就存在一个很严重的问题： <code>通常我们的代码中只使用了第三方 npm 模块的一个或几个 API 而不是全部</code>，微信 IDE 方式却始终会把 npm 模块内的全部代码进行打包，最终造成的后果是代码体积增大</p><p>又因为小程序对于代码体积有严格的限制（目前是 2M），使用微信 IDE 打包后很可能会超过上限。虽然在前端开发领域内，一些构建工具（比如 Webpack）会通过 Tree Shaking 机制在打包过程中将没有用到的代码片段舍弃，减少打包后的文件体积，但微信 IDE 目前却并没有这种特性</p><p>那么对于习惯了标准 npm 使用方式的前端开发者来说，微信小程序这种 npm 模块的管理和打包方案是很难接受的，单纯从研发效率的角度出发，这个方案也几乎没有可取之处。</p><p>所以，<code>业内普遍的做法就是：放弃微信 IDE 的 npm 管理方案，使用前端构建工具打造一套构建体系</code></p><p>一个未经修改的微信小程序源码目录如下图所示：</p><p><img src="http://img-repo.poetries.top/images/20210418210229.png" alt></p><p>其中 cloudfunctions 是云函数的根目录，miniprogram 中的文件是小程序本体的源码，包括小程序的业务代码和 npm 模块</p><blockquote><p>使用 Webpack 打造的构建体系通常会另外建立一个与 <code>cloudfunctions 和 miniprogram</code> 平行的目录用于管理源码，然后将 miniprogram 目录作为构建产出目录，如下：</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418210317.png" alt></p><blockquote><p>同时禁用微信 IDE 编译相关的功能，把这些工作全部交给 Webpack：</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418210334.png" alt></p><blockquote><p>这样一来，在自建的构建体系下，我们不仅可以使用标准的 npm 模块管理方式，同时可以发挥 Webpack 对于研发效率的加持，比如 Tree-Shaking 减小打包文件体积、结合 Babel 使用最新的 ECMAScript 特性、结合 Lint 工具统一代码规范等。这是接下来我们要讨论使用 Webpack 完成的几项具体工作的基础</p></blockquote><h2 id="六、数据监控"><a href="#六、数据监控" class="headerlink" title="六、数据监控"></a>六、数据监控</h2><h3 id="数据建模：性能、用户和异常"><a href="#数据建模：性能、用户和异常" class="headerlink" title="数据建模：性能、用户和异常"></a>数据建模：性能、用户和异常</h3><p><strong>1. 性能数据</strong></p><p>优化性能的目标主要有两个：</p><ul><li>减少用户打开小程序（或某个页面）后的等待时间，这部分的性能称为启动性能；</li><li>提高用户操作小程序的流畅度，这部分的性能称为运行时性能。</li></ul><p><img src="http://img-repo.poetries.top/images/20210418210634.png" alt></p><p><strong>2. 用户数据</strong></p><blockquote><p>用户的数据可以分为两种类型：一是静态数据，包括用户的年龄、性别、地域等信息，这些数据叫“用户画像”；二是动态数据，或者称为用户行为数据，这是一个比较宽泛的概念，可以细分为很多子项，比如：</p></blockquote><ul><li>用户在使用小程序期间的一些交互操作数据，比如点击某个按钮，从页面A切换到页面B；</li><li>用户的行为踪迹，比如先点击页面A的某个按钮然后点击另一个按钮最后切换到页面B；</li><li>用户在某个页面的停留时长；</li><li>用户的留存率；</li></ul><p><img src="http://img-repo.poetries.top/images/20210418210728.png" alt></p><p><strong>3. 异常数据</strong></p><p>异常数据有三种类型：</p><ul><li>端侧的代码异常，比如小程序 JavaScript 脚本的某段逻辑执行报错；</li><li>服务异常，不过这类异常情况不仅仅是小程序服务端的问题，也可能是用户设备所在网络环境造成的 HTTP 请求失败；</li><li>行为异常，最常见的一种就是爬虫脚本频繁地请求某个服务接口。</li></ul><p><img src="http://img-repo.poetries.top/images/20210418210758.png" alt></p><p>性能数据、用户数据和异常数据三者相对独立，而我们统计数据的目的并不是收集这些独立的数据，而是希望将它们综合在一起进行分析，这样才能从多维度、多方面获取数据隐藏的信息。也就是将所有数据通过一定的联系归属到在更上一层的领域内分析</p><blockquote><p>在小程序场景下，把这三种类型数据联系到一起的上层领域就是小程序的每个页面-Page。页面再上一层的领域就是小程序的运行环境（包括用户设备信息和小程序的版本信息）。由此我们可以总结出小程序的数据统计所使用的的数据模型，如下图所示</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418210837.png" alt></p><p>确定了数据模型，接下来就是制定针对每种数据的采集方案。</p><h3 id="采集方案：自动化工具和-API-劫持"><a href="#采集方案：自动化工具和-API-劫持" class="headerlink" title="采集方案：自动化工具和 API 劫持"></a>采集方案：自动化工具和 API 劫持</h3><p><strong>1. 性能数据采集</strong></p><blockquote><p>性能数据的采集通常会放在小程序发布前的研发或测试阶段，将其作为自动化测试的一部分。当然这并不是说采集小程序线上的性能数据没价值，而是必要性不足，因为影响线上性能数据的外界因素太多了，用户的网络情况、设备状态等都有可能造成某一时刻（甚至某一时间段之内）的性能数据波动，这种情况下统计的数据大多是没有实际价值的。而在研发或测试阶段往往是在固定的外界环境中进行性能数据的采集，多次抽样取期望值，然后与历史数据进行对比和评估</p></blockquote><p>具体到性能数据的采集方法上，主流的有两种：</p><ul><li>截图+图片比对。<ul><li>在对小程序进行仿真操作的过程中按照一定的频率进行截图，然后使用工具进行图片比对，从而获取到一些性能数据，比如小程序启动耗时、首屏渲染耗时等等。通过这种方法获取到的性能数据有一个特点，数据的精细度与截图的频率和图片比对工具的准确性成正比，实施的成本相对比较高。</li></ul></li><li>使用官方提供的性能 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tools.html" target="_blank" rel="noopener">Trace 工具</a>导出数据。<ul><li>直接获取到各项性能指标的数值，包括启动耗时、下载耗时、渲染耗时……比第一种方法实施的成本低很多，而且数据精准度更高。但目前只能在 Android 手机上拿到 Trace 工具的数据，iPhone 暂时不支持。</li></ul></li></ul><p><strong>2. 异常数据和用户数据采集</strong></p><ul><li>行为异常比如爬虫，在端侧是无法知悉的，防爬防刷是服务器安全保障的一部分，所以行为异常的监控一般都是由服务端承担，你可以把这项工作交给服务端的同事。</li><li>服务异常的数据来源有两种，一种是用户网络原因导致的请求失败或超时，一种是服务器本身出了问题。第二种与行为异常同样是属于服务端的职责，而在小程序端侧只能够介入第一种异常数据的采集，在采集方案上与代码异常是一致的。</li></ul><p>异常数据的采集也可以称为异常监控，采集到异常本身并不是主要目标，更重要的是能够采集到引起异常的用户行为路径。 比如对于电商小程序典型的购买商品的链路：用户点击了商品详情页的“购买”按钮，首先跳转到“购物车”页面，然后继续点击“下单”跳转到订单页面，最后点击“支付”调起微信支付。这个过程用户一共需要四个步骤：</p><p><img src="http://img-repo.poetries.top/images/20210418211347.png" alt></p><p>假如在这条链路中的“购物车”页面出现了异常，我们要采集的并不仅仅是当前页面脚本抛出的异常本身，而是要同时获取到引起异常的前序路径，即“商品页”信息。</p><p>用户行为数据的采集同样如此。 我们要获取的并不仅仅是用户点击了哪个按钮，还需要采集到这个按钮所在的页面，如果此页面是由其他页面跳转而来还需要采集前序页面的路径信息</p><p>还是以刚才的商品购买链路为例，点击商品页的“购买”按钮会触发跳转购物车，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  gotoCart()&#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: <span class="string">'pages/cart?id=xxx'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后在购物车页面中获取 URL 中携带的商品 ID：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  onLoad(query)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = query;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果使用最原始的代码埋点，需要在两个页面的函数中手动填写埋点代码，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 商品页</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  gotoCart()&#123;</span><br><span class="line">    reportClientLog(&#123;</span><br><span class="line">      <span class="comment">// ...上报商品页数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: <span class="string">'pages/cart?id=xxx'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 购物车页面</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad(query)&#123;</span><br><span class="line">    reportClientLog(&#123;</span><br><span class="line">      <span class="comment">// ...上报购物车页面数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = query;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这种方式既费时、费力又难以维护，因为如果在后续迭代中不需要统计某个函数的行为，就要找到这个函数的埋点代码手动删除。所以我们要来解决这样的问题，这里需要用到 ES 6 的一些新特性：<code>Proxy 和 Reflect</code> 。目前小程序运行时还不支持这些特性，你可以借助 Babel 将其转化为 ES 5 语法</p></blockquote><p>用 Proxy 和 Reflect 实现埋点的思路非常简单：<code>代理（也可以称为劫持）小程序的 API ，在调用 API 的同时采集数据</code>。以上述案例中用到的小程序 Page 对象为例，<code>使用 Proxy 和 Reflect 实现 API 代理</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Page, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target,key,context)&#123;</span><br><span class="line">    <span class="keyword">const</span> originHandler = <span class="built_in">Reflect</span>.get(target,key,context);</span><br><span class="line">    <span class="comment">// 只代理函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> originHandler === <span class="string">'function'</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        reportClientLog(&#123;</span><br><span class="line">          <span class="comment">// ...上报数据</span></span><br><span class="line">        &#125;);</span><br><span class="line">        originHandler.call(context,...args);</span><br><span class="line">      &#125;.bind(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originHanlder;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将以上代码封装为一个独立的 JavaScript 文件，假设名称为 <code>report.js</code> ，然后在小程序中引入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./report.js'</span>);</span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>经过以上改造，每当调用 Page 的 API 时都会上报数据。但是当调用 Page 的任何一个 API 都会上报数据，而大多数情况下只需要统计有限的几个 API ，所以要为 <code>report.js 引入一种白名单机制：只有在名单之内的 API 上报数据</code>。改造的方式也很简单</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">report</span>(<span class="params">obj,apilist</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target,key,context)&#123;</span><br><span class="line">    <span class="keyword">const</span> originHandler = <span class="built_in">Reflect</span>.get(target,key,context);</span><br><span class="line">    <span class="comment">// 只代理列表内的函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> originHandler === <span class="string">'function'</span> &amp;&amp; apiList.includes(key))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        reportClientLog(&#123;</span><br><span class="line">          <span class="comment">// ...上报数据</span></span><br><span class="line">        &#125;);</span><br><span class="line">        originHandler.call(context,...args);</span><br><span class="line">      &#125;.bind(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originHanlder;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你应该也注意到了，上面这段代码不仅加入了白名单机制，而且还把被代理的对象改成了动态的参数，这样便可以适用于任何对象，比如小程序的 App 和 Page 对象：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="built_in">require</span>(<span class="string">'./report.js'</span>);</span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line">App = report(App, [</span><br><span class="line">  <span class="string">'onShow'</span>,</span><br><span class="line">  <span class="string">'onLoad'</span>,</span><br><span class="line">  <span class="string">'onLaunch'</span></span><br><span class="line">]);</span><br><span class="line">App(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// page.js</span></span><br><span class="line">Page = report(Page, [</span><br><span class="line">  <span class="string">'onShow'</span>,</span><br><span class="line">  <span class="string">'onHide'</span>,</span><br><span class="line">  <span class="string">'onLoad'</span>,</span><br><span class="line">  <span class="string">'gotoCart'</span></span><br><span class="line">]);</span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>到目前为止，我们完成了数据采集的实施方案，当然我们肯定会根据现实业务的需求做出调整和改造，比如制定上报数据的格式规范、上报时机、处理离线数据等细节（这些内容与业务有强关联性）</p></blockquote><p><strong>3. 采集到所需数据之后，然后就是根据这些数据做分析、决策了</strong></p><ul><li>性能数据能够帮助技术研发人员发现影响应用程序性能的不良因素，然后进行专项优化。</li><li>异常数据主要的作用是监控线上环境存在的问题，然后根据问题影响面的大小制定告警策略，比如当监控到影响功能逻辑的严重脚本错误，后台监控服务会通过邮件、短信、电话的方式通知责任人督促尽快解决</li></ul><p>整体的数据监控体系可以简化为下面这张图：</p><p><img src="http://img-repo.poetries.top/images/20210418212057.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>数据不仅仅对产品和运营有价值，对于研发同样意义非凡，你需要明确这一点，在以后的工作中将数据重视起来；</li><li>性能的评估通常作为自动化测试的一部分，而异常监控则是针对生产环境的。作为一名研发，你需要时刻关注这两种数据，并且有针对性地进行改善；</li><li>采集小程序的异常数据和用户数据可以通过<code>劫持小程序 SDK 的 API ，这样能够减轻代码埋点的工作量，并且降低后续维护的成本</code>。</li></ul><h2 id="七、小程序的更新策略"><a href="#七、小程序的更新策略" class="headerlink" title="七、小程序的更新策略"></a>七、小程序的更新策略</h2><blockquote><p>小程序的资源可以笼统地分为前端和后端资源：前端资源也可以被称为端侧资源（包括脚本、样式文件等），后端资源指的是小程序的一些服务接口。</p></blockquote><h3 id="端侧更新策略"><a href="#端侧更新策略" class="headerlink" title="端侧更新策略"></a>端侧更新策略</h3><ul><li>网站的前端资源可以分为动态资源和静态资源， 静态的资源包括 js、css、图片等文件，为了提高性能通常会将这些文件尽量缓存到本地。动态的资源只有 HTML 文件</li><li>网站的HTML 文件最初是由服务端通过模板引擎渲染出来的，比如 freemarker、smarty 等，现在仍然有很多网站使用这种方式，不过更流行的是用 React/Vue SSR 以及 SPA 的静态 HTML。</li><li>虽然在 SPA 架构中，HTML 文件与 js 文件、css文件一样作为静态资源部署，但跟 js 和 css 不同的是，我们并不会让浏览器缓存 HTML 文件，而是通过服务器配置将 HTML 文件的 HTTP 请求的 Cache-Control Header 设置为 no-cache 。这是为了保证用户每次打开网站都会得到最新版的 HTML 文件，而其他静态资源都要通过 HTML 文件才会被引入，这保证了HTML 文件的实时性，也保证了网站所有静态资源的实时性</li></ul><blockquote><ul><li>跟网站不同的是，小程序的“所有”端侧资源都是静态的</li><li>小程序的资源是托管在微信服务器上的，跟网站不同，微信不会在用户每次打开小程序时，从服务器拉取最新的小程序资源，而是尽可能地发挥缓存的优势</li></ul></blockquote><p><img src="http://img-repo.poetries.top/images/20210418212807.png" alt></p><blockquote><p>当用户打开小程序时，微信客户端会先从缓存中拉取小程序的端侧资源，有的话就展示给用户，没有的话会从微信服务器拉取，这时，拉取的肯定是最新版本，然后放入缓存并展示给用户。</p></blockquote><p>以上就是小程序的端侧资源的管理机制。从这套流程里你会发现一个问题：既然优先使用缓存中的资源，那么当我发布了小程序新版本之后，怎么保证用户尽可能快地更新为新版本呢？这就是我们要讨论的重点：小程序的端侧资源更新机制。</p><blockquote><p>本地没有缓存会触发是最简单的一种时机，除此之外还有两种时机。</p></blockquote><ul><li>未启动时： 指的是小程序处于非活跃状态时（比如处于后台），但是请注意，这种状态是用户已经用过小程序后才会产生的，如果用户从来都没有用过你的小程序，就不存在状态的概念了，因为对于这个用户来说，你的小程序是无状态的。</li><li>冷启动时： 小程序被销毁重新打开后会进入冷启动状态</li></ul><blockquote><p>当你在小程序管理后台发布新版本的小程序之后，微信会根据用户设备上小程序的状态实施不同的更新策略</p></blockquote><p><code>如果小程序处于未启动状态</code>， 微信客户端会在“若干个时机”去检查缓存中的小程序有没有新版本，如果有会默默把新版本资源拉取到本地缓存中</p><p><img src="http://img-repo.poetries.top/images/20210418212955.png" alt></p><p><code>如果小程序处于冷启动状态</code>，微信客户端会主动检查是否有新版本，同时会向用户展示缓存中的旧版本。有新版本的话会默默地拉取到本地，然后在用户再次触发小程序冷启动时展示给用户。也就是说，需要两次冷启动才能将最新版本的小程序展示给用户。整个流程如下图所示：</p><p><img src="http://img-repo.poetries.top/images/20210418213042.png" alt></p><blockquote><p>从上述内容中，你可以得出一个结论：<code>当你发布一个新版本后，用户并不能“立即”获得更新。</code></p></blockquote><p>小程序未启动时最慢 24 小时可以覆盖全部用户，或者需要经历两次冷启动，这对一些紧急的版本更新来说太慢了，所以在现实工作中往往要将小程序的更新提速，让用户尽可能快地获取到新版本。具体实施方法是通过小程序的 <code>UpdateManager</code> 对象，在代码里主动检查并应用更新信息。我们对照流程图和代码讲解，来看下面这张图：</p><p><img src="http://img-repo.poetries.top/images/20210418213144.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="keyword">const</span> updateManager = wx.getUpdateManager()</span><br><span class="line">updateManager.onCheckForUpdate(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将是否有新版本信息挂载到全局对象上</span></span><br><span class="line">  <span class="keyword">this</span>.globalData.hasUpdate = res.hasUpdate</span><br><span class="line">&#125;)</span><br><span class="line">updateManager.onUpdateReady(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">this</span>.globalData.hasUpdate)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; miniProgram &#125; = wx.getAccountInfoSync()</span><br><span class="line">  <span class="comment">// 获取当前小程序的版本号</span></span><br><span class="line">  <span class="keyword">const</span> currVersion = miniProgram.version</span><br><span class="line">  <span class="comment">// 从你的开发者服务器接口中获取是否有紧急版本需要更新</span></span><br><span class="line">  axios.get(<span class="string">`<span class="subst">$&#123;&lt;your-url?&#125;</span>?currVersion=<span class="subst">$&#123;currVersion&#125;</span>`</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.needUpdate)&#123;</span><br><span class="line">      <span class="comment">// 紧急版本立即重启小程序应用更新</span></span><br><span class="line">      updateManager.applyUpdate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>首先在代码中创建一个 <code>UpdateManager</code> 对象，然后添加 <code>onCheckForUpdate</code> 和<code>onUpdateReady</code> 监听，当微信客户端从微信服务器中获取到小程序的更新信息后会触发 <code>onCheckForUpdate</code> 函数，入参携带 <code>hasUpdate</code> 属性标记是否有新版本未更新。我们将这个信息挂载到全局对象上以便后续使用。</li><li>当微信客户端从微信服务器中将最新版本的小程序端侧资源拉取到本地之后，会触发 <code>onUpdateReady</code>函数，此时需要你的开发者服务器提供一个接口，对应上述代码中的 your-url。这个接口的入参是用户当前使用的小程序版本，然后根据这个版本号判断当前用户的小程序版本是否存在严重 Bug 需要更新到最新版本。你需要在小程序的脚本代码中，当 <code>onUpdateReady</code> 函数被触发时调用这个接口，如果需要更新则通过调用 <code>updateManager.applyUpdate()</code> 强制重启小程序应用更新。</li></ul><blockquote><p>上述这套更新机制相比较需要两次冷启动的默认更新机制来说，能够减少一次冷启动的时间，能更快速地令用户获取最新版本的小程序，对于一些修复紧急 Bug 的版本是一种行之有效的方案。当然，我们只展示了端侧的调用流程，在后端发布小程序时，你需要记录每次发布版本的详细信息，包括是否有紧急 Bug 修复，这样才能够为端侧的调用提供数据来源。</p></blockquote><h3 id="后端服务灰度发布策略"><a href="#后端服务灰度发布策略" class="headerlink" title="后端服务灰度发布策略"></a>后端服务灰度发布策略</h3><blockquote><p>后端服务的发布流程中有一个非常重要且通用的策略：灰度发布。所谓的灰度发布简单理解就是将新版本的服务只向一定比例的用户开放，而另一部分用户仍然使用旧版本的服务，然后观察新版本的状态，如果一切正常则慢慢扩大新版本的用户比例，直到全部用户都切入新版本，便完成了灰度发布的全流程。</p></blockquote><p><strong>灰度发布需要提前制定用户请求的转发策略，一般有两种：</strong></p><ul><li>按照新旧服务所占用的服务器比例随机转发；</li><li>按照用户的 ID 转发。</li></ul><blockquote><ul><li>第一种简单粗暴，比如你有 10 台服务器，其中 2 台部署了新版本的服务，负载均衡器会在接收到用户请求时按照 20% 的概率随机转发到新版本服务器上，剩余的转发到旧版本服务器。</li><li>第二种需要进行一定的编码工作，比如 Nginx 配置 Lua 脚本，当接收到用户请求时，从请求中获取到用户的 ID ，在小程序场景下就是用户的 OpenId ，然后匹配转发策略中是否这个 ID 在新版本服务的白名单中，如果是的话便转发到新版本服务，否则转发到旧版本服务。如下图所示：</li></ul></blockquote><p><img src="http://img-repo.poetries.top/images/20210418213424.png" alt></p><h2 id="八、云开发：云原生一体化应用开发平台"><a href="#八、云开发：云原生一体化应用开发平台" class="headerlink" title="八、云开发：云原生一体化应用开发平台"></a>八、云开发：云原生一体化应用开发平台</h2><blockquote><ul><li>云开发其实是一种后端服务，和服务器所扮演的角色类似，都是服务端角色。不过云开发把服务所需要的一些资源（比如计算、存储、消息推送等）封装打包，以方便开发者使用。整体上讲，云开发包括了云函数、云数据库、云存储、云托管等一些基础服务资源，以及云上的各种扩展能力（比如图像处理、客服服务等）。</li><li>在调用方式上， 云开发的使用方法和前端开发差不多，它将触手可及的各种资源以接口 SDK 的形式给到开发者。举个例子，如果开发微信小程序，需要存储用户的个人数据以方便应用业务，你可以用云开发的接口把数据存入数据库，这个接口并不是 URL 地址，而是一个函数方法（function），举例如下：</li></ul></blockquote><p><img src="http://img-repo.poetries.top/images/20210418213614.png" alt></p><p>如果你想对这些数据进行一些复杂的处理（比如对数据做分析，生成报表）涉及其他的数据，可以把处理的逻辑放到云开发云函数中进行，而云函数也可以在小程序中用函数方法（function）的形式调用，举例如下：</p><p><img src="http://img-repo.poetries.top/images/20210418213639.png" alt></p><p>再深一步，如果你的微信小程序想存储一些文件，也可以直接使用云开发接口，调用上传文件，文件可以同时被小程序端和云函数端获取到，方便应用功能的开发，举例如下：</p><p><img src="http://img-repo.poetries.top/images/20210418213655.png" alt></p><p><strong>以上在开发小程序时所用到的数据库、云函数、云存储都是云开发提供的资源：</strong></p><ul><li>云函数是独立的计算资源，通过触发执行逻辑运算或者资源处理，最终返回结果；</li><li>数据库是遵循 Mongo 协议的非关系型数据库，可以直接通过各种 API 进行调用处理；</li><li>云存储是云开发提供的专门的存储空间，有基础 API 进行文件管理。</li></ul><blockquote><p>而这些基础服务资源（数据库、云函数、云存储）都被整合到一套接口调用标准中，根据这套标准以及适用端场景，会产生各种 SDK，分别专注于客户端、云函数端、管理端等进行资源统筹和处理。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、双线程模型&quot;&gt;&lt;a href=&quot;#一、双线程模型&quot; class=&quot;headerlink&quot; title=&quot;一、双线程模型&quot;&gt;&lt;/a&gt;一、双线程模型&lt;/h2&gt;&lt;h3 id=&quot;渲染线程和逻辑线程&quot;&gt;&lt;a href=&quot;#渲染线程和逻辑线程&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="小程序" scheme="http://blog.poetries.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>serverless简介及应用</title>
    <link href="http://blog.poetries.top/2021/04/16/serverless-intro/"/>
    <id>http://blog.poetries.top/2021/04/16/serverless-intro/</id>
    <published>2021-04-16T07:24:08.000Z</published>
    <updated>2021-05-11T03:46:23.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Serverless"><a href="#一、什么是Serverless" class="headerlink" title="一、什么是Serverless"></a>一、什么是Serverless</h2><blockquote><p>Serverless 能解决什么问题？理清 Serverless 要解决的问题其实很简单，我们可以从字面上把它拆开来看。Server 这里指服务端，它是 Serverless 解决问题的边界；而 less 我们可以理解为较少关心，它是 Serverless 解决问题的目的。组合在一起就是“较少关心服务端”</p></blockquote><ul><li>第一种：<code>狭义 Serverless</code>（最常见）= <code>Serverless computing 架构</code> = <code>FaaS 架构</code> = <code>Trigger（事件驱动）+ FaaS（函数即服务）+ BaaS</code>（后端即服务，持久化或第三方服务）= <code>FaaS + BaaS</code></li><li>第二种：广义 <code>Serverless</code> = <code>服务端免运维</code> = <code>具备 Serverless 特性的云服务</code></li></ul><p><img src="http://img-repo.poetries.top/images/20210416155216.png" alt></p><h2 id="二、编写你的第一个-Serverless-应用"><a href="#二、编写你的第一个-Serverless-应用" class="headerlink" title="二、编写你的第一个 Serverless 应用"></a>二、编写你的第一个 Serverless 应用</h2><p><img src="http://img-repo.poetries.top/images/20210418151945.png" alt></p><ul><li>FaaS 平台都支持 Node.js、Python 、Java 等编程语言；</li><li>FaaS 平台都支持 HTTP 和定时触发器（这两个触发器最常用）。此外各厂商的 FaaS 支持与自己云产品相关的触发器，函数计算支持阿里云表格存储等触发器；</li><li>FaaS 的计费都差不多，且每个月都提供一定的免费额度。其中 GB-s 是指函数每秒消耗的内存大小，比如1G-s 的含义就是函数以 1G 内存执行 1 秒钟。超出免费额度后，费用基本都是 0.0133元/万次，0.00003167元/GB-s。所以，用 FaaS 整体费用非常便宜，对一个小应用来说，几乎是免费的。</li></ul><p><strong>以阿里云函数为例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logic.js</span></span><br><span class="line">exports.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> logic = <span class="built_in">require</span>(<span class="string">'./logic'</span>);</span><br><span class="line">exports.handler = <span class="function">(<span class="params">request, response, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 从 request 中获取</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = request.queries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理业务逻辑</span></span><br><span class="line">  <span class="keyword">const</span> message = logic.sayHello(name)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 HTTP 响应</span></span><br><span class="line">  response.setStatusCode(<span class="number">200</span>);</span><br><span class="line">  response.setHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(&#123; message &#125;)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>把业务逻辑拆分到入口函数之外</p></blockquote><h3 id="触发器及事件对象"><a href="#触发器及事件对象" class="headerlink" title="触发器及事件对象"></a>触发器及事件对象</h3><ol><li>HTTP 触发器</li></ol><blockquote><p>在众多 FaaS 平台中，函数计算直接提供了 HTTP 触发器，HTTP 触发器通过发送 HTTP 请求来触发函数执行，一般都会支持 POST、GET、PUT、HEAD 等方法。所以你可以用 HTTP 触发器来构建 Restful 接口或 Web 系统。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418152334.png" alt></p><p>HTTP 触发器会根据 HTTP 请求和请求参数生成事件，然后以参数形式传递给函数。那么 HTTP 触发器的入口函数参数中的 request 和 response 参数具体有哪些属性呢？</p><p>其实， request 和 response 参数本质上与 Express.js 框架的 request 和 response 类似</p><ol start="2"><li>API 网关触发器</li></ol><p>API 网关触发器与 HTTP 触发器类似，它主要用于构建 Web 系统。本质是利用 API 网关接收 HTTP 请求，然后再产生事件，将事件传递给 FaaS。FaaS 将函数执行完毕后将函数返回值传递给 API 网关，API 网关再将返回值包装为 HTTP 响应返回给用户。</p><p><img src="http://img-repo.poetries.top/images/20210418152415.png" alt></p><ol start="3"><li>定时触发器</li></ol><blockquote><p>定时触发器就是定时执行函数，它经常用来做一些周期任务，比如每天定时查询天气并给自己发送通知、每小时定时处理分析日志等等。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418152436.png" alt></p><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>无论你用什么编写语言开发 Serverless 应用，你都要在合适的时候输出合适的日志信息，方便调试应用、排查问题。在 Serverless 中，日志输出和传统应用的日志输出没有太大区别，只是日志的存储和查询方式变了。</p><p>以函数计算为例，如果你在控制台创建函数，则函数计算默认会使用日志服务来为你存储日志。在 “日志查询” 标签下可以查看函数调用日志。日志服务是一个日志采集、分析产品，所以如果你要实现业务监控，则可以将日志输出到日志服务，然后在日志服务中对日志进行分析，并设置报警项。</p><p><img src="http://img-repo.poetries.top/images/20210418152600.png" alt></p><h2 id="三、Serverless-应用是怎么运行的"><a href="#三、Serverless-应用是怎么运行的" class="headerlink" title="三、Serverless 应用是怎么运行的"></a>三、Serverless 应用是怎么运行的</h2><blockquote><p>Serverless 应用本质上是由一个个 FaaS 函数组成的，Serverless 应用的每一次运行，其实是单个或多个函数的运行，所以 <code>Serverelss 的运行原理，本质上就是函数的运行原理</code></p></blockquote><p><strong>FaaS 是怎么运行的</strong></p><p><img src="http://img-repo.poetries.top/images/20210416155334.png" alt></p><p><img src="http://img-repo.poetries.top/images/20210416155401.png" alt></p><h3 id="函数调用链路：事件驱动函数执行"><a href="#函数调用链路：事件驱动函数执行" class="headerlink" title="函数调用链路：事件驱动函数执行"></a>函数调用链路：事件驱动函数执行</h3><blockquote><p>对于 FaaS 函数来说，一方面可以通过事件来触发执行，另一方面也可以直接调用 API 来执行。FaaS 平台都提供了执行函数的 API</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418151354.png" alt></p><h3 id="函数生命周期：冷启动与热启动"><a href="#函数生命周期：冷启动与热启动" class="headerlink" title="函数生命周期：冷启动与热启动"></a>函数生命周期：冷启动与热启动</h3><blockquote><p>FaaS 中的冷启动是指从调用函数开始到函数实例准备完成的整个过程。冷启动我们关注的是启动时间，启动时间越短，我们对资源的利用率就越高。现在的云服务商，基于不同的语言特性，冷启动平均耗时基本在 <code>100～700 毫秒</code>之间。得益于 Google 的 JavaScript 引擎 Just In Time 特性，Node.js 在冷启动方面速度是最快的。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210416155824.png" alt></p><blockquote><p>注意，FaaS 服务从 0 开始，启动并执行完一个函数，只需要 100 毫秒。这也是为什么 FaaS 敢缩容到 0 的主要原因。通常我们打开一个网页有个关键指标，响应时间在 1 秒以内，都算优秀。这么一对比，100 毫秒的启动时间，对于网页的秒开率影响真的极小</p></blockquote><blockquote><p>在 FaaS 平台中，函数默认是不运行的，也不会分配任何资源。甚至 FaaS 中都不会保存函数代码。只有当 FaaS 接收到触发器的事件后，才会启动并运行函数。整个函数的运行过程可以分为四个阶段</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418151433.png" alt></p><ul><li>下载代码： FaaS 平台本身不会存储代码，而是将代码放在对象存储中，需要执行函数的时候，再从对象存储中将函数代码下载下来并解压，因此 FaaS 平台一般都会对代码包的大小进行限制，通常代码包不能超过 50MB。</li><li>启动容器： 代码下载完成后，FaaS 会根据函数的配置，启动对应容器，FaaS 使用容器进行资源隔离。</li><li>初始化运行环境： 分析代码依赖、执行用户初始化逻辑、初始化入口函数之外的代码等。</li><li>运行代码： 调用入口函数执行代码。</li></ul><blockquote><p>当函数第一次执行时，会经过完整的四个步骤，前三个过程统称为“冷启动”，最后一步称为 “热启动”。</p></blockquote><p>整个冷启动流程耗时可能达到百毫秒级别。函数运行完毕后，运行环境会保留一段时间，可能 2 ~ 5 分钟，这和具体云厂商有关。如果这段时间内函数需要再次执行，则 FaaS 平台就会使用上一次的运行环境，这就是“执行上下文重用”，函数的这个启动过程也叫“热启动”。“热启动” 的耗时就完全是启动函数的耗时了。当一段时间内没有请求时，函数运行环境就会被释放，直到下一次事件到来，再重新从冷启动开始初始化。</p><p>下面是一个函数的请求示意图，其中 “请求1” “请求3” 是冷启动，“请求2” 是热启动</p><p><img src="http://img-repo.poetries.top/images/20210418151527.png" alt></p><blockquote><p>函数执行完毕后销毁运行环境，虽然对首次函数执行的性能有损耗，但极大提高了资源利用效率，只有需要执行代码的时候才初始化环境、消耗硬件资源。并且如果你的应用请求量比较大，则大部分时候函数的执行可能都是热启动</p></blockquote><h3 id="FaaS-是怎么分层的"><a href="#FaaS-是怎么分层的" class="headerlink" title="FaaS 是怎么分层的"></a>FaaS 是怎么分层的</h3><p><img src="https://files.mdnice.com/user/6541/5d7d3769-4fc0-4036-bd1b-91e9a650c2c3.png" alt></p><blockquote><p>你的 FaaS 实例执行时，就如上图所示，至少是 3 层结构：容器、运行时 Runtime、具体函数代码。</p></blockquote><p>容器你可以理解为操作系统 OS。代码要运行，总需要和硬件打交道，容器就是模拟出内核和硬件信息，让你的代码和 Runtime 可以在里面运行。容器的信息包括内存大小、OS 版本、CPU 信息、环境变量等等。目前的 FaaS 实现方案中，容器方案可能是 Docker 容器、VM 虚拟机，甚至 Sandbox 沙盒环境。运行时 Runtime，就是你的函数执行时的上下文 context。Runtime 的信息包括代码运行的语言和版本，例如 Node.js v10，Python3.6；可调用对象，例如 aliyun SDK；系统信息，例如环境变量等等。</p><blockquote><ul><li>这样分层有什么好处呢？容器层适用性更广，云服务商可以预热大量的容器实例，将物理服务器的计算资源碎片化。Runtime 的实例适用性较低，可以少量预热；容器和 Runtime 固定后，下载你的代码就可以执行了。通过分层，我们可以做到资源统筹优化，这样就能让你的代码快速低成本地被执行。</li><li>理解了分层，我们再回想一下 FaaS 分层对应冷启动的过程，其实你就不难理解云服务商负责的就是容器和 Runtime 的准备阶段了。而开发者自己负责的则是函数执行阶段。一旦容器 &amp;Runtime 启动后，就会维持一段时间，这段时间内的这个函数实例就可以直接处理用户数据请求。当一段时间内没有用户请求事件发生（各个云服务商维持实例的时间和策略不同），则会销毁这个函数实例。</li></ul></blockquote><p><img src="http://img-repo.poetries.top/images/20210416160251.png" alt></p><ul><li>纯 FaaS 应用调用链路由函数触发器、函数服务和函数代码三部分组成，它们分别替代了传统服务端运维的负载均衡 &amp; 反向代理，服务器 &amp; 应用运行环境，应用代码部署</li><li>对比传统应用托管 PaaS 平台，FaaS 应用最大的不同就是，FaaS 应用可以缩容到 0，在事件到来时极速启动，Node.js 的函数甚至可以做到 100ms 启动并执行。</li><li>FaaS 在设计上牺牲了用户的可控性和应用场景，来简化代码模型，并且通过分层结构进一步提升资源的利用率，这也是为什么 FaaS 冷启动时间能这么短的主要原因。关于 FaaS 的 3 层结构，你可以这么想象：容器层就像是 Windows 操作系统；Runtime 就像是 Windows 里面的播放器暴风影音；你的代码就像是放在 U 盘里的电影</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>组成 Serverless 应用的函数是事件驱动的，但你也可以直接同 API 调用函数；</li><li>函数可以同步调用或异步调用，定时触发器函数是异步调用的，异步调用函数建议主动记录并处理异步调用结果；</li><li>函数的启动过程分为下载代码、启动容器、启动运行环境、执行代码四个步骤，前三个步骤称为冷启动，最后一个步骤称为热启动</li></ul><h2 id="四、如何提高应用开发调试和部署效率"><a href="#四、如何提高应用开发调试和部署效率" class="headerlink" title="四、如何提高应用开发调试和部署效率"></a>四、如何提高应用开发调试和部署效率</h2><h3 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h3><blockquote><p>Serverless 应用是由函数组成的，所以应用的管理主要就是函数的管理。各个 FaaS 平台其实也考虑到了这一点，比如函数计算的 “服务”功能或 Lambda 的 “应用” 功能。你可以把一个应用的函数都创建在同一个 “服务” 下，一个 “服务” 即代表一个应用。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418152848.png" alt></p><blockquote><p>那么如何去描述 “服务” 和 “函数” 的关系呢？因为二者是静态的，不会在代码运行时改变，所以你可以用 YAML 或 JSON 配置文件来表示（我推荐 YAML，因为它可以编写注释，可读性更好）。在创建函数时，你还要指定函数的入口、编程语言、触发器等信息。所以 YAML 文件的内容可能是这样的：</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serverless.yaml</span></span><br><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line">service: myservice</span><br><span class="line"><span class="comment"># 函数列表</span></span><br><span class="line"><span class="built_in">functions</span>:</span><br><span class="line">    <span class="comment"># 函数1</span></span><br><span class="line">  hello:</span><br><span class="line">    handler: hello.main <span class="comment"># 函数入口</span></span><br><span class="line">    runtime: nodejs12</span><br><span class="line">    events: <span class="comment"># 函数触发器，一个函数可能有多个触发器</span></span><br><span class="line">        - http</span><br><span class="line">        - timer</span><br><span class="line">  <span class="comment"># 函数2</span></span><br><span class="line">  goodbye:</span><br><span class="line">    handler: goodbye.main</span><br><span class="line">    runtime: nodejs12</span><br><span class="line">    events:</span><br><span class="line">        - http</span><br></pre></td></tr></table></figure><h3 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h3><p>有了应用配置文件之后，开发者就可以开始开发代码了。为了进一步简化用户操作，你甚至可以提供一些代码模板，然后提供 init 命令让开发者基于模板一键生成一个 Serverless 应用。例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ serverless init --template hello-world</span><br><span class="line">|-- hello.js</span><br><span class="line">|-- serverless.yaml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serverless.yaml</span></span><br><span class="line">service: myservice</span><br><span class="line"><span class="built_in">functions</span>:</span><br><span class="line">  hello:</span><br><span class="line">    handler: hello.main</span><br><span class="line">    events:</span><br><span class="line">        - http</span><br></pre></td></tr></table></figure><h2 id="五、serverless应用"><a href="#五、serverless应用" class="headerlink" title="五、serverless应用"></a>五、serverless应用</h2><h3 id="阿里云函数计算"><a href="#阿里云函数计算" class="headerlink" title="阿里云函数计算"></a>阿里云函数计算</h3><blockquote><p><a href="https://fc.console.aliyun.com/fc/overview" target="_blank" rel="noopener">https://fc.console.aliyun.com/fc/overview</a></p></blockquote><p>选择一个模板，体验一下</p><p><img src="https://files.mdnice.com/user/6541/d63653ac-0a1d-4dfa-9a2a-879f23aa803e.png" alt></p><blockquote><p>云函数使用指南 <a href="https://help.aliyun.com/product/50980.html" target="_blank" rel="noopener">https://help.aliyun.com/product/50980.html</a></p></blockquote><h3 id="腾讯云函数"><a href="#腾讯云函数" class="headerlink" title="腾讯云函数"></a>腾讯云函数</h3><p><img src="http://img-repo.poetries.top/images/20210416161014.png" alt></p><blockquote><p>云函数使用指南 <a href="https://cloud.tencent.com/document/product/876/41762" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/876/41762</a></p></blockquote><h3 id="使用vercel部署你的应用-推荐"><a href="#使用vercel部署你的应用-推荐" class="headerlink" title="使用vercel部署你的应用-推荐"></a>使用vercel部署你的应用-推荐</h3><p>vercel是用过的最好用的网站托管服务，我们可以在上面部署api、静态页面等。可以和GitHub深度绑定，推送代码，vercel会帮我们检测自动部署</p><p><strong>新建项目</strong></p><p><img src="http://img-repo.poetries.top/images/20210416161535.png" alt></p><p>导入GitHub的某一个项目部署</p><p><img src="http://img-repo.poetries.top/images/20210416161621.png" alt></p><p><img src="http://img-repo.poetries.top/images/20210416161653.png" alt></p><p><img src="http://img-repo.poetries.top/images/20210416161728.png" alt></p><p><img src="http://img-repo.poetries.top/images/20210416161748.png" alt></p><blockquote><p>部署完成后，可以在控制面板看到，vercel每次部署都动态帮我生成一个地址，可以直接访问你的应用</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210416161906.png" alt></p><p><strong>绑定GitHub应用</strong></p><p><img src="http://img-repo.poetries.top/images/20210416162735.png" alt></p><blockquote><p>每次提交代码到GitHub，vercel都会自动帮我们构建发布</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210416162612.png" alt></p><p><strong>绑定域名</strong></p><p>我们可以绑定自己的自定义域名</p><p><img src="http://img-repo.poetries.top/images/20210416162045.png" alt></p><blockquote><p>我们还可以使用vercel部署node小型应用，非常的方便。更多参考文档 <a href="https://vercel.com/docs" target="_blank" rel="noopener">https://vercel.com/docs</a></p></blockquote><h2 id="六、场景案例"><a href="#六、场景案例" class="headerlink" title="六、场景案例"></a>六、场景案例</h2><h3 id="1-使用-Serverless-实现登录注册功能"><a href="#1-使用-Serverless-实现登录注册功能" class="headerlink" title="1 使用 Serverless 实现登录注册功能"></a>1 使用 Serverless 实现登录注册功能</h3><h4 id="1-1-身份认证的技术方案"><a href="#1-1-身份认证的技术方案" class="headerlink" title="1.1 身份认证的技术方案"></a>1.1 身份认证的技术方案</h4><p><strong>Cookie-Session</strong></p><blockquote><p>Cookie-Session 方式是早期最常用的身份认证方式，直到现在很多 Web 网站依然使用这种方式。其认证流程是</p></blockquote><ul><li>用户在浏览器中输入账号密码登录；</li><li>服务端验证通过后，将用户信息保存在 Session 中并生成一个 Session ID；</li><li>然后服务端将 Session ID 放在 HTTP 响应头的 cookie 字段中；</li><li>浏览器收到 HTTP 响应后，将 cookie 保存在浏览器中，cookie 内容就是之前登录时生成的 Session ID；</li><li>用户再访问网站时，浏览器请求头就会自动带上 cookie 信息；</li><li>服务端接收到请求后，从 cookie 获取到 Session ID，然后根据 Session ID 解析出用户信息。</li></ul><p><img src="http://img-repo.poetries.top/images/20210418165707.png" alt></p><p><strong>这种方案存在两个主要问题：</strong></p><ul><li>服务端的 Session ID 是直接存储在内存中的，在分布式系统中无法共享登录状态；</li><li>cookie 是浏览器的功能，手机 App 等客户端并不支持 cookie，所以该方案不适用于非浏览器的应用。</li></ul><p>第一个问题也是 Cookie-Session 方案应用于 Serverless 架构的主要问题，因为 Serverless 应用是无状态的，内存中的数据用完即销毁，多个请求间无法共享 Session。解决该问题也比较容易， 就是用一个共享存储来保存 Session 信息，最常见的就是 Redis，因为 Redis 是一个内存数据库，读写速度很快。</p><blockquote><p>于是 Cookie-Session 的身份认证方案就发生了变化：</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210418165751.png" alt></p><blockquote><p>与早期方案不同，用户登录时，该方案会把用户信息保存在 Redis 中，而不是内存中，然后服务端依然会将 Session ID 返回给浏览器，浏览器将其保存在 cookie 中。而之后非登录的请求，浏览器依然会将包含 Session ID 的 cookie 放在请求头中发送给服务端，服务端拿到 Session ID 后，从 Redis 中查询出用户信息。这样就可以解决分布式、无状态的系统中用户登录状态共享问题。</p></blockquote><p>不过这个方案依旧无法解决非浏览器场景的身份认证问题，所以 JWT 方案诞生了。</p><p><strong>JWT</strong></p><blockquote><p>JWT 是（JSON Web Token）的简称，其原理是：</p></blockquote><ul><li>服务端认证通过后，根据用户信息生成一个 token 返回给客户端；</li><li>客户端将 token 存储在 cookie 或 localStorage 中；</li><li>之后客户端每次请求都需要带上 token，通常是将 token 放在 HTTP 请求头的 Authorization 字段中；</li><li>服务端接收到 token 后，验证 token 的合法性，并从 token 中解析出用户信息。</li></ul><p><img src="http://img-repo.poetries.top/images/20210418165833.png" alt></p><blockquote><p>token 是个比较长字符串，格式为 <code>Header.Payload.Signature</code>，由<code>.</code>分隔为三部分。下面是一个实际的 token 示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJqYWNrIiwiaWF0IjoxNjEwODg1MTcxfQ.KIduc-undaZ0z-Bt4wjGZIK5fMlx1auVHl_G1DvGDCw</span><br></pre></td></tr></table></figure><p>可能有同学会担忧： token 是根据用户信息生成的，这样会不会泄露用户信息呢？其实不用担心，因为生成 token 的加密算法是不可逆的，并且 token 也可以设置过期时间，所以 token 字符串本身不会泄露用户信息。</p><blockquote><p>基于 JWT ，客户端可以使用自己特有的存储来保存 token，不依赖 cookie，所以 JWT 可以适用于任意客户端。并且使用 JWT 进行身份认证，服务端就不用存储用户信息了，这样服务端就是无状态的。因此 JWT 这种身份认证方案，也非常适合 Serverless 应用。</p></blockquote><p>接下来，就基于 JWT ，带你从 0 到 1实现一个登录注册应用</p><h4 id="1-2-从-0-到-1-实现一个登录注册应用"><a href="#1-2-从-0-到-1-实现一个登录注册应用" class="headerlink" title="1.2 从 0 到 1 实现一个登录注册应用"></a>1.2 从 0 到 1 实现一个登录注册应用</h4><p><strong>应用初始化</strong></p><blockquote><p>首先安装 <code>express</code>、<code>body-parser</code> 和 <code>@webserverless/fc-express</code> 等依赖：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i express body-parser @webserverless/fc-express -S</span><br></pre></td></tr></table></figure><blockquote><p>@webserverless/fc-express 的作用是将函数计算的 HTTP 或 API 网关触发器参数转换为 Express.js 框架的参数，这样你就可以很方便在函数计算中使用 Express.js 了</p></blockquote><p>然后我们初始化一个 template.yaml 模板，该模板定义了 auth-app 这个函数，函数触发器为 HTTP 触发器，支持 GET 和 POST 请求：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROSTemplateFormatVersion: &apos;2015-09-01&apos;</span><br><span class="line">Transform: &apos;Aliyun::Serverless-2018-04-03&apos;</span><br><span class="line">Resources:</span><br><span class="line">  serverless:</span><br><span class="line">    Type: &apos;Aliyun::Serverless::Service&apos;</span><br><span class="line">    Properties:</span><br><span class="line">      Description: &apos;Serverless Authorization App&apos;</span><br><span class="line">    auth-app:</span><br><span class="line">      Type: &apos;Aliyun::Serverless::Function&apos;</span><br><span class="line">      Properties:</span><br><span class="line">        Handler: index.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: &apos;./&apos;</span><br><span class="line">        Timeout: 10</span><br><span class="line">      Events:</span><br><span class="line">        httpTrigger:</span><br><span class="line">          Type: HTTP</span><br><span class="line">          Properties:</span><br><span class="line">            AuthType: ANONYMOUS</span><br><span class="line">            Methods: [&apos;POST&apos;, &apos;GET&apos;]</span><br></pre></td></tr></table></figure><p>接下来在 index.js 中编写初始化代码，如下所示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'@webserverless/fc-express'</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;</span><br><span class="line">  extended: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 / 路由，返回 Hello Serverless!</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">        data: <span class="string">'Hello Serverless!'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> proxy.Server(app);</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 @webserverless/fc-express 来将函数计算的请求转发给 Express.js 应用</span></span><br><span class="line">    <span class="comment">// @webserverless/fc-express 可以将函数参数转换为 Express.js 的路由参数</span></span><br><span class="line">    server.httpProxy(req, res, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这段代码主要实现两个功能：</strong></p><ul><li>定义了 <code>/</code>  路由，该路由返回了 <code>Hello Serverless!</code> 字符串，我们之后可以用它来测试代码是否正常运行；</li><li>使用 <code>@webserverless/fc-express</code> 将函数计算的请求转发给 <code>Express.js</code> 应用<code>@webserverless/fc-express 可以将函数参数转换为</code>Express.js` 的路由参数。</li></ul><p>然后通过 <code>fun deploy</code> 部署应用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署应用</span></span><br><span class="line">$ fun deploy -y</span><br><span class="line">Waiting <span class="keyword">for</span> service serverless to be deployed...</span><br><span class="line">        Waiting <span class="keyword">for</span> <span class="keyword">function</span> auth-app to be deployed...</span><br><span class="line">                Waiting <span class="keyword">for</span> packaging <span class="keyword">function</span> auth-app code...</span><br><span class="line">                The <span class="keyword">function</span> auth-app has been packaged. A total of 419 files were compressed and the final size was 724.49 KB</span><br><span class="line">                Waiting <span class="keyword">for</span> HTTP trigger httpTrigger to be deployed...</span><br><span class="line">                triggerName: httpTrigger</span><br><span class="line">                methods: [ <span class="string">'POST'</span>, <span class="string">'GET'</span> ]</span><br><span class="line">                url: https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/</span><br><span class="line">                trigger httpTrigger deploy success</span><br><span class="line">        <span class="keyword">function</span> auth-app deploy success</span><br><span class="line">service serverless deploy success</span><br><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"data"</span>:<span class="string">"Hello Serverless!"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>部署成功后，我们就可以获取到函数计算提供的测试 HTTP Endpoint，然后就可以通过 curl 命令进行测试应用是否正常运行：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/</span><br><span class="line">&#123;&quot;success&quot;:true,&quot;data&quot;:&quot;Hello Serverless!&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-实现注册功能"><a href="#1-3-实现注册功能" class="headerlink" title="1.3 实现注册功能"></a>1.3 实现注册功能</h4><blockquote><p>注册的逻辑是：先获取用户输入的用户名和密码，然后判断用户是否存在，如果不存在就将其存入表格存储数据库</p></blockquote><p>这里我们使用的数据库是表格存储。 可能你使用的比较多的是 MySQL，之所以选用表格存储而不是 MySQL，是因为表格存储可以直接通过 Restful API 进行读写，并且弹性可扩展，更适合 Serverless 应用。使用表格存储时，你要先创建一个表格存储实例，然后创建一个 user 表。为了方便，我也给你提供了一个创建 user 表的脚本：<a href="https://github.com/nodejh/serverless-class/tree/master/15/create-table" target="_blank" rel="noopener">create-table</a>。</p><blockquote><p>接下来继续编写代码。由于要使用表格存储，所以首先需要安装 tablestore 依赖，然后在 index.js 中初始化表格存储 client：</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 tablestore 依赖</span></span><br><span class="line"><span class="comment"># tablestore 封装了表格存储的 API</span></span><br><span class="line">$ npm i tablestore -S</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> TableStore = <span class="built_in">require</span>(<span class="string">'tablestore'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 TableStore client</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> TableStore.Client(&#123;</span><br><span class="line">  accessKeyId: <span class="string">'&lt;your access key&gt;'</span>,</span><br><span class="line">  accessKeySecret: <span class="string">'your access secret'</span>,</span><br><span class="line">  endpoint: <span class="string">'https://serverless-app.cn-shanghai.ots.aliyuncs.com'</span>,</span><br><span class="line">  instancename: <span class="string">'serverless-app'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>现在我们就可以定义一个路由来处理用户的注册请求了。代码如下所示，首先我们根据 name 从表格存储中查询用户信息，如果用户已存在，则直接返回；如果用户不存在，则将用户信息写入表格存储。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 /register 路由，处理注册请求</span></span><br><span class="line">app.post(<span class="string">'/register'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从请求体中获取用户信息</span></span><br><span class="line">  <span class="keyword">const</span> name = req.body.name;</span><br><span class="line">  <span class="keyword">const</span> password = req.body.password;</span><br><span class="line">  <span class="keyword">const</span> age = req.body.age;</span><br><span class="line">  <span class="comment">// 判断用户是否已经存在</span></span><br><span class="line">  <span class="keyword">const</span> &#123; row &#125; = <span class="keyword">await</span> client.getRow(&#123;</span><br><span class="line">    tableName: <span class="string">"user"</span>,</span><br><span class="line">    primaryKey: [&#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (row.primaryKey) &#123;</span><br><span class="line">    <span class="comment">// 如果用户已存在，则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      message: <span class="string">'用户已存在'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建用户，将用户信息写入到表格存储中</span></span><br><span class="line">  <span class="keyword">await</span> client.putRow(&#123;</span><br><span class="line">    tableName: <span class="string">"user"</span>,</span><br><span class="line">    condition: <span class="keyword">new</span> TableStore.Condition(TableStore.RowExistenceExpectation.EXPECT_NOT_EXIST, <span class="literal">null</span>),</span><br><span class="line">    primaryKey: [&#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;],</span><br><span class="line">    attributeColumns: [&#123;</span><br><span class="line">      password</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      age</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 返回创建成功</span></span><br><span class="line">  <span class="keyword">return</span> res.send(&#123;</span><br><span class="line">    success: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>至此注册功能就完成了，你可以将代码部署到函数计算上，像下面这样通过 curl 命令来模拟用户请求，验证功能是否正常：</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login \</span><br><span class="line">-d <span class="string">"name=jack&amp;password=123456&amp;age=18"</span> \</span><br><span class="line">-X POST</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login \</span><br><span class="line">-d <span class="string">"name=jack&amp;password=123456&amp;age=18"</span> \</span><br><span class="line">-X POST</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">false</span>,<span class="string">"message"</span>:<span class="string">"用户已存在"</span>&#125;</span><br></pre></td></tr></table></figure><p>注册功能完成后，就可以继续实现登录功能了。</p><h4 id="1-4-实现登录功能"><a href="#1-4-实现登录功能" class="headerlink" title="1.4 实现登录功能"></a>1.4 实现登录功能</h4><p>登录就是验证用户输入的用户名密码是否正确。</p><blockquote><p>首先根据用户输入的 name 从表格存储中查询出用户信息，然后对比用户密码与数据库中的用户密码是否一致，如果一致，则登录成功；否则登录失败。登录成功后，还需要根据用户信息生成一个 token 返回给用户。具体怎么实现呢？</p></blockquote><p>前面我们提到，Serverless 中最通用的身份认证方案是 JWT，所以我们首先需要安装 Node.js 中的 JWT 依赖包 jsonwebtoken：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install jsonwebtoken -S</span><br></pre></td></tr></table></figure><blockquote><p>然后在代码中引入 jsonwebtoken ，并定义 SECRET。SECRET 是用来加密和解密 token 的密钥，非常重要，且不能泄露。</p></blockquote><blockquote><p>接下来在代码中定义 <code>/login</code> 路由来处理用户请求。这段代码中，我们首先验证了用户密码是否正确，密码正确后，再使用 <code>jwt.sign()</code> 方法，根据用户信息生成了 token，最后将 token 返回给客户端，客户端需要将 token 保存下来。之后客户端每次请求，都需要带上 token 进行身份认证。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</span><br><span class="line"><span class="comment">// 设置密钥，非常重要，不能泄露</span></span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">'token_secret_xd2dasf19df='</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 定义 /login 路由，用来实现登录功能</span></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从请求体中获取用户名和密码</span></span><br><span class="line">  <span class="keyword">const</span> name = req.body.name;</span><br><span class="line">  <span class="keyword">const</span> password = req.body.password;</span><br><span class="line">  <span class="comment">// 根据用户名查询用户信息</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    row</span><br><span class="line">  &#125; = <span class="keyword">await</span> client.getRow(&#123;</span><br><span class="line">    tableName: <span class="string">'user'</span>,</span><br><span class="line">    primaryKey: [&#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 如果查询结果为空，则直接返回用户不存在</span></span><br><span class="line">  <span class="keyword">if</span> (!row.primaryKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      message: <span class="string">'用户不存在'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从查询结果中构造用户信息</span></span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;;</span><br><span class="line">  row.attributes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> user[item.columnName] = item.columnValue);</span><br><span class="line">  <span class="comment">// 判断密码是否正确</span></span><br><span class="line">  <span class="keyword">if</span> (password !== user.password) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      message: <span class="string">'密码错误'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  user.password = <span class="string">'******'</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成 token</span></span><br><span class="line"><span class="comment">   * jwt.sign() 接受两个参数，一个是传入的对象，一个是自定义的密钥</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> token = jwt.sign(user, SECRET)</span><br><span class="line">  <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">    success: <span class="literal">true</span>,</span><br><span class="line">    data: &#123; token &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码编写完成后，部署到函数计算并进行测试，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login \</span><br><span class="line">-d <span class="string">"name=jack&amp;password=123456"</span> \ </span><br><span class="line">-X POST</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"data"</span>:&#123;<span class="string">"token"</span>:<span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7MkU"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用错误的密码登录</span></span><br><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login \</span><br><span class="line">-d <span class="string">"name=jack&amp;password=1234561"</span> \</span><br><span class="line">-X POST</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">false</span>,<span class="string">"message"</span>:<span class="string">"密码错误"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么问题来了：对于需要登录后才能访问的接口，应该怎么根据 token 验证用户身份呢？别急，我们继续下面的学习。</p></blockquote><h4 id="1-5-验证用户身份"><a href="#1-5-验证用户身份" class="headerlink" title="1.5 验证用户身份"></a>1.5 验证用户身份</h4><blockquote><p>前面提到，登录成功后，客户端需要将 token 保存下来，然后在接下来的请求中，都需要带上 token。通常会将 token 放在 HTTP 请求头中，格式通常为：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer token</span><br></pre></td></tr></table></figure><p>这时假设我们要实现一个新的接口，获取当前登录用户信息，该接口也只能登录后才能使用。那么代码实现就是下面这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 /user 路由，获取当前登录的用户信息</span></span><br><span class="line">app.get(<span class="string">'/user'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从 HTTP 请求头中获取 token 信息</span></span><br><span class="line">  <span class="keyword">const</span> token = req</span><br><span class="line">    .headers</span><br><span class="line">    .authorization</span><br><span class="line">    .split(<span class="string">' '</span>)</span><br><span class="line">    .pop();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 验证 token 并解析出用户信息</span></span><br><span class="line">    <span class="keyword">const</span> user = jwt.verify(token, SECRET);</span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">true</span>,</span><br><span class="line">      data: user</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      data: <span class="string">'身份认证失败'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>首先我们定义了 /user 路由，然后通过请求头拿到 token 信息，最后使用 <code>jwt.verify()</code> 对 token 进行解密，并从中得到用户信息，如果用户传入的 token 无法解析，则说明用户身份异常。</p></blockquote><p>同样，我们可以将代码部署到函数计算并进行测试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl https:<span class="comment">//1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user \</span></span><br><span class="line">-H <span class="string">"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7MkU"</span></span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"data"</span>:&#123;<span class="string">"name"</span>:<span class="string">"jack"</span>,<span class="string">"age"</span>:<span class="string">"18"</span>,<span class="string">"password"</span>:<span class="string">"******"</span>,<span class="string">"iat"</span>:<span class="number">1610905944</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 使用错误的 token 进行身份认证</span><br><span class="line">$ curl https:<span class="comment">//1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7Mk"</span></span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">false</span>,<span class="string">"data"</span>:<span class="string">"身份认证失败"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到此为止，一个 Serverless 架构的登录注册功能就完成了，我们也基于 JWT 实现了 Serverless 中的身份认证。</p></blockquote><p><strong>强调这样几点：</strong></p><ul><li>Cookie-Session 的身份认证方式，是在服务端存储 Session 信息，客户端（浏览器）通过 cookie 存储 Session ID；</li><li>JWT 的身份认证方式，是在服务端根据用户信息生成 token，客户端保存 token；</li><li>Cookie-Session 的认证方案通常是有状态的，对于分布式、无状态的应用，需要将 Session 保存在共享存储中；</li><li>JWT 的认证方式通常是无状态的，所以比较适合 Serverless 应用。</li></ul><h3 id="2-基于-Serveless-构建弹性可扩展的-Restful-API"><a href="#2-基于-Serveless-构建弹性可扩展的-Restful-API" class="headerlink" title="2 基于 Serveless 构建弹性可扩展的 Restful API"></a>2 基于 Serveless 构建弹性可扩展的 Restful API</h3><blockquote><p>API 是使用 Serverless 最常见，也是最适合的场景之一。和 Serverful 架构的  API 相比，用 Serverless 开发 API 好处很多：</p></blockquote><ul><li>不用购买、管理服务器等基础设施，不用关心服务器的运维，节省人力成本；</li><li>基于 Serverless 的 API，具备自动弹性伸缩的能力，能根据请求流量弹性扩缩容，让你不再担心流量波峰、波谷；</li><li>基于 Serverless 的 API 按实际资源使用量来付费，节省财务成本。</li></ul><blockquote><p>因为好处很多，很多开发者跃跃欲试，但在实践过程中却遇到了很多问题，比如怎么设计最优的架构？怎么组织代码？怎么管理多个函数？所以今天我就以开发一个内容管理系统为例，带你学习怎么基于 Serverless 去开发一个 Restful API，解决上述共性问题。</p></blockquote><p>首先，我们需要对内容管理系统进行架构设计。</p><h4 id="2-1-内容管理系统的架构设计"><a href="#2-1-内容管理系统的架构设计" class="headerlink" title="2.1 内容管理系统的架构设计"></a>2.1 内容管理系统的架构设计</h4><p>在进行架构设计前，你要明确系统的需求。对于一个内容管理系统，最核心的功能（也是这一讲要实现的功能），主要有这样几个：</p><ul><li>用户注册；</li><li>用户登录；</li><li>发布文章；</li><li>修改文章；</li><li>删除文章；</li><li>查询文章。</li></ul><blockquote><p>这 6 个功能分别对应了我们要实现的 Restful API。为了方便统一管理 API，在 Serverless 架构中我们通常会用到 API 网关，通过 API 网关触发函数执行，并且基于  API 网关我们还可以实现参数控制、超时时间、IP 黑名单、流量控制等高级功能。</p></blockquote><p>对于文章管理相关的 Restful API，用户发布文章前需要先登录，你已经知道在 Serverless 中可以用 JWT 进行身份认证，咱们的管理系统中的登录注册功能也将沿用上一讲的内容。</p><blockquote><p>在传统的 Serverful 架构中，通常会用 MySQL 等关系型数据库存储数据，但因为关系型数据库要在代码中维护连接状态及连接池，且一般不能自动扩容，并不适合 Serverless 应用，所以在 Serverless 架构中，通常选用表格存储等 Serverless NoSQL 数据来存储数据。</p></blockquote><p>基于 JWT 的身份认证方案、数据存储方案，我们可以画出 Serverless 的内容管理系统架构图：</p><p><img src="http://img-repo.poetries.top/images/20210418171452.png" alt></p><ul><li>图中主要表达的意思是： 通过 API 网关承接用户请求，并驱动函数执行。每个函数分别实现一个具体功能，并通过 JWT 实现身份认证，最后表格存储作为数据库。</li><li>其中，数据库中存储的数据主要是用户数据和文章数据。假设用户有 username（用户名） 和 password（密码） 两个属性；文章有 <code>article_id</code>（文章 ID）、<code>username</code>（创建者）、<code>title</code>（文章标题）、<code>content</code>（文章内容）、<code>create_date</code>（创建时间）、<code>update_date</code>（更新时间）这几个属性</li></ul><p><img src="http://img-repo.poetries.top/images/20210418171543.png" alt></p><p>接下来，你可以在表格存储中创建对应的数据表（你可以在表格存储控制台创建，也可以直接用我提供的这段代码进行创建）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> TableStore = <span class="built_in">require</span>(<span class="string">"tablestore"</span>);</span><br><span class="line"><span class="comment">// 初始化 TableStore client</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> TableStore.Client(&#123;</span><br><span class="line">  accessKeyId: <span class="string">'&lt;your access key&gt;'</span>,</span><br><span class="line">  accessKeySecret: <span class="string">'&lt;your access secret&gt;'</span>,</span><br><span class="line">  endpoint: <span class="string">"https://serverless-app.cn-shanghai.ots.aliyuncs.com"</span>,</span><br><span class="line">  instancename: <span class="string">"serverless-cms"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 user 表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考文档： https://help.aliyun.com/document_detail/100594.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createUserTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> table = &#123;</span><br><span class="line">    tableMeta: &#123;</span><br><span class="line">      tableName: <span class="string">"user"</span>,</span><br><span class="line">      primaryKey: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"username"</span>, <span class="comment">// 用户名</span></span><br><span class="line">          type: TableStore.PrimaryKeyType.STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      definedColumn: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"password"</span>, <span class="comment">// 密码</span></span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 为数据表配置预留读吞吐量或预留写吞吐量。0 表示不预留吞吐量，完全按量付费</span></span><br><span class="line">    reservedThroughput: &#123;</span><br><span class="line">      capacityUnit: &#123;</span><br><span class="line">        read: <span class="number">0</span>,</span><br><span class="line">        write: <span class="number">0</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    tableOptions: &#123;</span><br><span class="line">      <span class="comment">// 数据的过期时间，单位为秒，-1表示永不过期</span></span><br><span class="line">      timeToLive: <span class="number">-1</span>,</span><br><span class="line">      <span class="comment">// 保存的最大版本数，1 表示每列上最多保存一个版本即保存最新的版本</span></span><br><span class="line">      maxVersions: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> client.createTable(table);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建文章表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createArticleTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> table = &#123;</span><br><span class="line">    tableMeta: &#123;</span><br><span class="line">      tableName: <span class="string">"article"</span>,</span><br><span class="line">      primaryKey: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"article_id"</span>, <span class="comment">// 文章 ID，唯一字符串</span></span><br><span class="line">          type: TableStore.PrimaryKeyType.STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      definedColumn: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"title"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"username"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"content"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"create_date"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"update_date"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 为数据表配置预留读吞吐量或预留写吞吐量。0 表示不预留吞吐量，完全按量付费</span></span><br><span class="line">    reservedThroughput: &#123;</span><br><span class="line">      capacityUnit: &#123;</span><br><span class="line">        read: <span class="number">0</span>,</span><br><span class="line">        write: <span class="number">0</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    tableOptions: &#123;</span><br><span class="line">      <span class="comment">// 数据的过期时间，单位为秒，-1表示永不过期</span></span><br><span class="line">      timeToLive: <span class="number">-1</span>,</span><br><span class="line">      <span class="comment">// 保存的最大版本数，1 表示每列上最多保存一个版本即保存最新的版本</span></span><br><span class="line">      maxVersions: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> client.createTable(table);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> createUserTable();</span><br><span class="line">  <span class="keyword">await</span> createArticleTable();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><blockquote><p>这段代码主要创建了 user 和 article 两张表，其中 user 表的主键是 username，article 表的主键是 article_id，主键的作用是方便查询。除了主键，我还定义了几个列。其实对于表格存储，默认也可以不创建列，表格存储是宽表，除主键外，数据列可以随意扩展</p></blockquote><p>在完成了数据库表的创建后，我们就可以开始进行系统实现了。</p><h4 id="2-2-内容管理系统的实现"><a href="#2-2-内容管理系统的实现" class="headerlink" title="2.2 内容管理系统的实现"></a>2.2 内容管理系统的实现</h4><p>为了方便你学习，为你提供了完整代码（代码地址），你可以参考着学习。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/poetries/serverless-class</span><br><span class="line">$ cd 15/cms</span><br></pre></td></tr></table></figure><p>整个代码目录结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── config</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   ├── db</span><br><span class="line">│   │   └── client.js</span><br><span class="line">│   ├── function</span><br><span class="line">│   │   ├── article</span><br><span class="line">│   │   │   ├── create.js</span><br><span class="line">│   │   │   ├── delete.js</span><br><span class="line">│   │   │   ├── detail.js</span><br><span class="line">│   │   │   └── update.js</span><br><span class="line">│   │   └── user</span><br><span class="line">│   │       ├── login.js</span><br><span class="line">│   │       └── register.js</span><br><span class="line">│   └── middleware</span><br><span class="line">│       └── auth.js</span><br><span class="line">└── template.yml</span><br></pre></td></tr></table></figure><p>其中，所有业务代码都放在 src 目录中：</p><ul><li><code>config/index.js</code> 是配置文件，里面包含身份凭证等配置信息；</li><li><code>db/client.js</code> 对表格存储的增删改查操作进行了封装，方便在函数中使用（将数据库的操作封装还有一个好处是，如果你之后想要迁移到其他数据库，只要修改 db/client.js 中的逻辑，不用修改业务代码）；</li><li><code>middleware</code> 目录中是一些中间件，比如 <code>auth.js</code>，用于身份认证；</li><li><code>functions</code> 目录中就是所有函数，登录、注册、创建文章等，每个功能分别对应一个函数；</li><li><code>template.yaml</code> 是应用配置文件，包括函数和 API 网关的配置。</li></ul><p>根据前面梳理的系统功能，我们需要实现以下几个 API：</p><table><thead><tr><th>用户注册</th><th>POST /user/register</th></tr></thead><tbody><tr><td>用户登录</td><td>POST /user/login</td></tr><tr><td>发布文章</td><td>POST /article/create</td></tr><tr><td>查询文章</td><td>GET /article/detail/[article_id]</td></tr><tr><td>更新文章</td><td>POST /article/update</td></tr><tr><td>删除文章</td><td>PUT /article/delete/[article_id]</td></tr></tbody></table><blockquote><p>每个 API 对应一个具体的函数，每个函数也都有一个与之对应的 API 网关触发器。由于这些函数属于同一个应用，所以我们可以通过一个 template.yaml 来定义所有函数。同时也可以在 template.yaml 中定义函数的 API 网关触发器，这样部署函数时，就会自动创建 API 网关。</p></blockquote><p>内容管理系统的 <code>template.yaml</code> 格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROSTemplateFormatVersion: <span class="string">'2015-09-01'</span></span><br><span class="line">Transform: <span class="string">'Aliyun::Serverless-2018-04-03'</span></span><br><span class="line">Resources:</span><br><span class="line">  <span class="comment"># 函数服务，该服务中的函数都是内容管理系统的函数</span></span><br><span class="line">  serverless-cms:</span><br><span class="line">    Type: <span class="string">'Aliyun::Serverless::Service'</span></span><br><span class="line">    Properties:</span><br><span class="line">      Description: <span class="string">'Serverless 内容管理系统'</span></span><br><span class="line">    <span class="comment"># 函数名称</span></span><br><span class="line">    [functionName]:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        <span class="comment"># 函数路径</span></span><br><span class="line">        Handler: &lt;functionPath&gt;.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">  <span class="comment"># API 网关分组，分钟中的所有 API 都是内容管理系统的 API</span></span><br><span class="line">  ServerlessCMSGroup: </span><br><span class="line">    Type: <span class="string">'Aliyun::Serverless::Api'</span></span><br><span class="line">    Properties:</span><br><span class="line">      StageName: RELEASE</span><br><span class="line">      DefinitionBody:</span><br><span class="line">        &lt;Path&gt;: <span class="comment"># 请求的 path</span></span><br><span class="line">          post: <span class="comment"># 请求的 method</span></span><br><span class="line">            x-aliyun-apigateway-api-name: user_register <span class="comment"># API 名称</span></span><br><span class="line">            x-aliyun-apigateway-fc: <span class="comment"># 当请求该 API 时，要触发的函数，</span></span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;&lt;functionName&gt;.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br></pre></td></tr></table></figure><p><strong>template.yaml  主要分为两部分</strong>： 函数定义和 API 网关定义，每个函数都有一个与之对应的 API 网关。我们用 serverless-cms 服务来表示内容管理系统这个应用，服务内的所有函数都是内容管理系统的函数。同理，ServerlessCMSGroup 这个 API 网关分组中的所有 API 都是内容管理系统的 API。</p><p>完整的 <code>template.yaml</code>配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROSTemplateFormatVersion: <span class="string">'2015-09-01'</span></span><br><span class="line">Transform: <span class="string">'Aliyun::Serverless-2018-04-03'</span></span><br><span class="line">Resources:</span><br><span class="line">  <span class="comment"># 函数服务</span></span><br><span class="line">  serverless-cms:</span><br><span class="line">    Type: <span class="string">'Aliyun::Serverless::Service'</span></span><br><span class="line">    Properties:</span><br><span class="line">      Description: <span class="string">'Serverless 内容管理系统'</span></span><br><span class="line">    user-register:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/user/register.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    user-login:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/user/login.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    article-create:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/article/create.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    article-detail:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/article/detail.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    article-update:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/article/update.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    article-delete:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/article/delete.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">  <span class="comment"># API 网关分组</span></span><br><span class="line">  ServerlessCMSGroup: </span><br><span class="line">    Type: <span class="string">'Aliyun::Serverless::Api'</span></span><br><span class="line">    Properties:</span><br><span class="line">      StageName: RELEASE</span><br><span class="line">      DefinitionBody:</span><br><span class="line">        <span class="string">'/user/register'</span>: <span class="comment"># 请求的 path</span></span><br><span class="line">          post: <span class="comment"># 请求的 method</span></span><br><span class="line">            x-aliyun-apigateway-api-name: user_register <span class="comment"># API 名称</span></span><br><span class="line">            x-aliyun-apigateway-fc: <span class="comment"># 当请求该 API 时，要触发的函数，</span></span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;user-register.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/user/login'</span>:</span><br><span class="line">          post:</span><br><span class="line">            x-aliyun-apigateway-api-name: user_login</span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;user-login.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/article/create'</span>:</span><br><span class="line">          post:</span><br><span class="line">            x-aliyun-apigateway-api-name: article_create</span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;article-create.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/article/detail/[article_id]'</span>:</span><br><span class="line">          GET:</span><br><span class="line">            x-aliyun-apigateway-api-name: article_detail</span><br><span class="line">            x-aliyun-apigateway-request-parameters:</span><br><span class="line">              - apiParameterName: <span class="string">'article_id'</span></span><br><span class="line">                location: <span class="string">'Path'</span></span><br><span class="line">                parameterType: <span class="string">'String'</span></span><br><span class="line">                required: <span class="string">'REQUIRED'</span></span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;article-detail.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/article/update/[article_id]'</span>:</span><br><span class="line">          PUT:</span><br><span class="line">            x-aliyun-apigateway-api-name: article_update</span><br><span class="line">            x-aliyun-apigateway-request-parameters:</span><br><span class="line">              - apiParameterName: <span class="string">'article_id'</span></span><br><span class="line">                location: <span class="string">'Path'</span></span><br><span class="line">                parameterType: <span class="string">'String'</span></span><br><span class="line">                required: <span class="string">'REQUIRED'</span></span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;article-update.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/article/delete/[article_id]'</span>:</span><br><span class="line">          DELETE:</span><br><span class="line">            x-aliyun-apigateway-api-name: article_update</span><br><span class="line">            x-aliyun-apigateway-request-parameters:</span><br><span class="line">              - apiParameterName: <span class="string">'article_id'</span></span><br><span class="line">                location: <span class="string">'Path'</span></span><br><span class="line">                parameterType: <span class="string">'String'</span></span><br><span class="line">                required: <span class="string">'REQUIRED'</span></span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;article-delete.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br></pre></td></tr></table></figure><p>在这份配置中，需要注意两个地方：</p><p>函数的 Handler 配置，Handler 可以写函数路径，比如<code>src/function/user/register.handler</code>表示<code>src/function/user/目录中的 register.js 文件中的 handler 方法</code>；</p><p>API 网关配置中的<code>/article/detail/[article_id]Path</code>，这种带参数的 PATH，必须使用<code>x-aliyun-apigateway-request-parameters</code>指定 Path 参数。</p><p>接下来，我们就来实现内容管理系统的各个 API，也就是 template.yaml 中定义的各个函数。</p><h4 id="2-3-用户注册"><a href="#2-3-用户注册" class="headerlink" title="2.3 用户注册"></a>2.3 用户注册</h4><p>用户注册接口定义如下。</p><p>请求方法：POST。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path：/user/register</span><br></pre></td></tr></table></figure><blockquote><p>Body参数：username 用户名、password 密码。</p></blockquote><p>整体代码很简单，在入口函数 handler 中，通过 event 得到 API 网关传递过来的 HTTP 请求 body 数据，然后从中得到 username、password，再将用户信息写入数据库。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/function/user/register</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户注册</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>username 用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>password 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> client.createRow(<span class="string">"user"</span>, &#123; username &#125;, &#123; password &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从 event 中获取 API 网关传递 HTTP 请求 body 数据</span></span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.parse(event.toString()).body);</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = body;</span><br><span class="line">  register(username, password)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="literal">null</span>, &#123; <span class="attr">success</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123; <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">message</span>: <span class="string">"用户注册失败"</span> &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码完成后，就可以将应用部署到函数计算：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署应用</span></span><br><span class="line">$ fun deploy</span><br><span class="line">Waiting <span class="keyword">for</span> service serverless-cms to be deployed...</span><br><span class="line">...</span><br><span class="line">service serverless-cms deploy success</span><br><span class="line">Waiting <span class="keyword">for</span> api gateway ServerlessCMSGroup to be deployed...</span><br><span class="line">...</span><br><span class="line">api gateway ServerlessCMSGroup deploy success</span><br></pre></td></tr></table></figure><p>部署过程中，如果看到函数服务 serverless-cms  和 API 网关 ServerlessCMSGroup 都成功部署了，就说明应用部署完成。部署完成后，API 网关会提供一个用来测试的 API Endpoint，当然你也可以绑定自定义域名。</p><p>我们可以通过 curl 测试一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/user/register \</span><br><span class="line">-X POST \</span><br><span class="line">-d &quot;username=Jack&amp;password=123456&quot;</span><br><span class="line">&#123;&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>返回 <code>{&quot;success&quot;: true}</code> ，说明用户注册成功。这时在表格存储控制台也可以看到刚注册的用户。</p><p><img src="http://img-repo.poetries.top/images/20210418172230.png" alt></p><h4 id="2-4-用户登录"><a href="#2-4-用户登录" class="headerlink" title="2.4 用户登录"></a>2.4 用户登录</h4><p>完成用户注册函数开发后，就可以接着开发登录。用户登录的接口定义如下。</p><ul><li>请求方法：POST。</li><li>Path：/user/login</li><li>Body 参数：username 用户名、password 密码。</li></ul><blockquote><p>登录的逻辑就是根据用户输入的密码是否正确，如果正确就生成一个 token 返回给调用方。代码实现如下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/function/user/login</span></span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">"assert"</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; jwt_secret &#125; = <span class="built_in">require</span>(<span class="string">"../../config"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>username 用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>password 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> client.getRow(<span class="string">"user"</span>, &#123; username &#125;);</span><br><span class="line">  assert(user &amp;&amp; user.password === password);</span><br><span class="line">  <span class="keyword">const</span> token = jwt.sign(&#123; <span class="attr">username</span>: user.username &#125;, jwt_secret);</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.parse(event.toString()).body);</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = body;</span><br><span class="line">  login(username, password)</span><br><span class="line">    .then(<span class="function">(<span class="params">token</span>) =&gt;</span> callback(<span class="literal">null</span>, &#123; <span class="attr">success</span>: <span class="literal">true</span>, <span class="attr">data</span>: &#123; token &#125; &#125;))</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123; <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">message</span>: <span class="string">"用户登录失败"</span> &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将其部署到函数计算后，我们也可以使用 curl 命令进行测试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/user/login \</span><br><span class="line">-X POST \</span><br><span class="line">-d &quot;username=Jack&amp;password=123456&quot;</span><br><span class="line">&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-身份认证"><a href="#2-5-身份认证" class="headerlink" title="2.5 身份认证"></a>2.5 身份认证</h4><p>在完成了注册登录接口后，我们再来看一下内容管理系统中，身份认证应该怎么实现。</p><p>在之前，我们实现了一个 Express.js 框架的身份认证中间件，用来拦截所有请求，身份认证通过后才能进执行后面的代码逻辑。在内容管理系统中，你也可以参考 Express.js 的思想，实现一个 auth.js 专门用于身份认证，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/middleware/auth.js</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">"jsonwebtoken"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; jwt_secret &#125; = <span class="built_in">require</span>(<span class="string">"../config/index"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 身份认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>event API 网关的 event 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;object&#125;</span> </span>认证通过后返回 user 信息；认证失败则返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> auth = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(event.toString());</span><br><span class="line">    <span class="keyword">if</span> (data.headers &amp;&amp; data.headers.Authorization) &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="built_in">JSON</span>.parse(event.toString())</span><br><span class="line">        .headers.Authorization.split(<span class="string">" "</span>)</span><br><span class="line">        .pop();</span><br><span class="line">      <span class="keyword">const</span> user = jwt.verify(token, jwt_secret);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = auth;</span><br></pre></td></tr></table></figure><ul><li>其原理很简单，就是从 API 网关的 event 对象中获取 token，然后验证 token 是否正常。如果认证通过，就返回 user 信息，失败就返回 false。</li><li>这样在需要身份认证的函数中，你只引入 auth.js 并传入 event 对象就可以了。下面是一个简单的示例：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">'./middleware/auth'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 auth 进行身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">'身份认证失败!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过身份认证后的业务逻辑</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callback(<span class="literal">null</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>除了登录注册，其他接口都需要身份认证，所以接下来我们就通过实现“发布文章”函数来实际使用 auth.js。</p></blockquote><h4 id="2-6-发布文章"><a href="#2-6-发布文章" class="headerlink" title="2.6 发布文章"></a>2.6 发布文章</h4><p>发布文章的接口定义如下。</p><ul><li>请求方法：POST。</li><li>Path：/article/create</li><li>Headers 参数: Authorization token。</li><li>Body 参数：title、content。</li></ul><blockquote><p>由于登录后才能发布文章，所以要先通过登录接口获取 token，然后调用 /article/create 接口时，再将 token 放在 HTTP Headers 参数中。发布文章的代码实现如下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/function/article/auth</span></span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">"uuid"</span>);</span><br><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">"../../middleware/auth"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>username 用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>title 文章标题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>content 文章内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createArticle</span>(<span class="params">username, title, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> article_id = uuid.v4();</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString();</span><br><span class="line">  <span class="keyword">await</span> client.createRow(</span><br><span class="line">    <span class="string">"article"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      article_id,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      username,</span><br><span class="line">      title,</span><br><span class="line">      content,</span><br><span class="line">      create_date: now,</span><br><span class="line">      update_date: now,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> article_id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"身份认证失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 user 中获取 username</span></span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = user;</span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.parse(event.toString()).body);</span><br><span class="line">  <span class="keyword">const</span> &#123; title, content &#125; = body;</span><br><span class="line">  createArticle(username, title, content)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        message: <span class="string">"创建文章失败"</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先是使用 auth.js 进行身份认证，认证通过后就可以从 user 中获取 username。然后再从请求体中获取文章标题和文章内容数据，将其存入数据库。</p><p>接下来我们依旧可以将函数部署和使用 curl 进行测试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/create \</span><br><span class="line">-X POST \</span><br><span class="line">-d &quot;title=这是文章标题&amp;content=内容内容内容......&quot; \</span><br><span class="line">-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;</span><br><span class="line">&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;article_id&quot;:&quot;d4b9bad8-a0ed-499d-b3c6-c57f16eaa193&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>在测试时，我们需要将 token 放在 HTTP 请求头的 Authorization 属性中。文章发布成功后，你就可以在表格存储中看到对应的数据了。</p><p><img src="http://img-repo.poetries.top/images/20210418172448.png" alt></p><h4 id="2-7-查询文章"><a href="#2-7-查询文章" class="headerlink" title="2.7 查询文章"></a>2.7 查询文章</h4><blockquote><p>发布文章的接口开发完成后，我们继续开发一个查询文章的接口，这样就可以查询出刚才创建的文章。查询文章接口定义如下。</p></blockquote><ul><li>请求方法：GET。</li><li><code>Path：/article/detail/[article_id]</code></li><li>Headers 参数: Authorization token。</li></ul><blockquote><p>在查询文章接口中，我们需要在 Path 中定义文章 ID 参数，即 article_id。这样在函数代码中，你就可以通过 event 对象的 pathParameters 中获取 article_id 参数，然后根据 article_id 来查询文章详情了。完整代码如下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">"uuid"</span>);</span><br><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">"../../middleware/auth"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文章详情</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>title 文章 ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getArticle</span>(<span class="params">article_id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> client.getRow(</span><br><span class="line">    <span class="string">"article"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      article_id,</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"身份认证失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从 event 对象中获取文章 ID</span></span><br><span class="line">  <span class="keyword">const</span> article_id = <span class="built_in">JSON</span>.parse(event.toString()).pathParameters[<span class="string">'article_id'</span>];</span><br><span class="line">  getArticle(article_id)</span><br><span class="line">    .then(<span class="function">(<span class="params">detail</span>) =&gt;</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">        data: detail</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        message: <span class="string">"创建文章失败"</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>开发完成后，我们可以将其部署到函数计算，再用 curl 命令进行测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/detail/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \</span><br><span class="line">-H <span class="string">"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA"</span></span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"data"</span>:&#123;<span class="string">"article_id"</span>:<span class="string">"d4b9bad8-a0ed-499d-b3c6-c57f16eaa193"</span>,<span class="string">"content"</span>:<span class="string">"内容内容内容......"</span>,<span class="string">"create_date"</span>:<span class="string">"1/24/2021, 2:05:46 PM"</span>,<span class="string">"title"</span>:<span class="string">"这是文章标题"</span>,<span class="string">"update_date"</span>:<span class="string">"1/24/2021, 2:05:46 PM"</span>,<span class="string">"username"</span>:<span class="string">"Jack"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>如上所示，查询文章的接口按照预期返回了文章详情。</p><h4 id="2-8-更新文章"><a href="#2-8-更新文章" class="headerlink" title="2.8 更新文章"></a>2.8 更新文章</h4><blockquote><p>更新文章的 API Path 参数和查询文章一样，都需要 Path 中定义 article_id。而其 body 参数则与创建文章相同。此外，更新文章的请求 method 是 PUT，因为在 Restful API 规范中，我们通常使用 POST 来表示创建， 使用 PUT 来表示更新。</p></blockquote><p>更新文章的接口定义如下。</p><p>请求方法：PUT。</p><ul><li>Path：/article/update/[article_id]</li><li>Headers 参数: Authorization token。</li><li>Body 参数：title、content。</li></ul><p>更新文章的逻辑就是根据  article_id 去更新一行数据。代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">"../../middleware/auth"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>article_id 待更新的文章 ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>title 文章标题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>content 文章内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">updateArticle</span>(<span class="params">article_id, title, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString();</span><br><span class="line">  <span class="keyword">await</span> client.updateRow(</span><br><span class="line">    <span class="string">"article"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      article_id,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      title,</span><br><span class="line">      content,</span><br><span class="line">      update_date: now,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"身份认证失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> eventObject = <span class="built_in">JSON</span>.parse(event.toString())</span><br><span class="line">  <span class="comment">// 从 event 对象的 pathParameters 中获取 Path 参数</span></span><br><span class="line">  <span class="keyword">const</span> article_id = eventObject.pathParameters[<span class="string">'article_id'</span>];</span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(eventObject.body);</span><br><span class="line">  <span class="comment">// 从 event 对象的 body 中获取请求体参数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; title, content &#125; = body;</span><br><span class="line">  updateArticle(article_id, title, content)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        message: <span class="string">"更新文章失败"</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>开发并部署完成后，使用 curl 命令进行测试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/update/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \</span><br><span class="line">-X PUT \</span><br><span class="line">-d &quot;title=这是文章标题&amp;content=更新的内容......&quot; \</span><br><span class="line">-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;</span><br><span class="line">&#123;&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>返回 <code>{&quot;success&quot;:true}</code> 则说明更新成功。</p><h4 id="2-9-删除文章"><a href="#2-9-删除文章" class="headerlink" title="2.9 删除文章"></a>2.9 删除文章</h4><blockquote><p>最后就还是一个删除文章的 API 了。删除文章的 API 也需要在 Path 中定义 article_id 参数，并且其 HTTP method 是 DELETE。具体接口定义如下。</p></blockquote><ul><li>请求方法：DELETE。</li><li>Path：/article/delete/[article_id]</li><li>Headers 参数: Authorization token，</li><li>删除文章很简单，就是根据 article_id 删除一行数据，代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">"uuid"</span>);</span><br><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">"../../middleware/auth"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>title 文章 ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteArticle</span>(<span class="params">article_id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> client.deleteRow(</span><br><span class="line">    <span class="string">"article"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      article_id,</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"身份认证失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从 event 对象中获取文章 ID</span></span><br><span class="line">  <span class="keyword">const</span> article_id = <span class="built_in">JSON</span>.parse(event.toString()).pathParameters[<span class="string">'article_id'</span>];</span><br><span class="line">  deleteArticle(article_id)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        message: <span class="string">"删除文章失败"</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样我们可以通过 curl 命令进行测试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/delete/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \</span><br><span class="line">-X DELETE \</span><br><span class="line">-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;</span><br><span class="line">&#123;&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>删除成功后，再去表格存储中就找不到这行记录了。至此，内容管理系统的 Restful API 就开发完毕了。</p><h4 id="2-10-总结"><a href="#2-10-总结" class="headerlink" title="2.10 总结"></a>2.10 总结</h4><blockquote><p>可以看到，基于 Serverless 开发 Restful API 的整个代码非常简单，每个函数只负责一个独立的业务，职责单一、逻辑清晰。关于这一讲，我想强调这样几个重点：</p></blockquote><ul><li>基于 Serverless 开发 API 时，建议你使用 API 网关进行 API 的管理；</li><li>对于数据库等第三方服务，建议对其基本操作进行封装，这样更方便进行扩展；</li><li>Serverless 函数需要保持简单、独立、单一职责。</li></ul><h3 id="3-基于-Serverless-开发高可用音视频处理系统"><a href="#3-基于-Serverless-开发高可用音视频处理系统" class="headerlink" title="3 基于 Serverless 开发高可用音视频处理系统"></a>3 基于 Serverless 开发高可用音视频处理系统</h3><p>Serverless 的应用场景非常广泛，它还可以用于大数据计算、物联网应用、音视频处理等。为了让你了解到更多的 Serverless 的应用场景，我准备了今天的内容。</p><p>音视频处理是一个 CPU 密集型的操作，非常消耗计算资源，以往我们处理视频就要采购大量的高性能服务器，财务成本和维护成本都很高。有了 Serverless 后，就不用再关心计算资源不足的问题，也不用担心服务器的维护，并且还能降低成本。</p><p>接下来，我先带你了解传统的音视频处理方案，然后在此基础上再带你学习并实践基于 Serverless 的音视频处理系统，这样你理解得会更加深入。</p><h4 id="3-1-传统音视频处理方案"><a href="#3-1-传统音视频处理方案" class="headerlink" title="3.1 传统音视频处理方案"></a>3.1 传统音视频处理方案</h4><p>近几年，计算机技术和通信技术日新月异，信息传播的媒介也在不断演变，从文字到图片再到视频，各种短视频、直播甚至 AR、VR 等产品百花齐放。在这些产品的背后，离不开音视频处理技术。</p><p>得益于云计算的发展，有些云厂商推出了对应的视频解决方案，因此你现在要搭建一个视频处理程序是很容易的（下图就是一个典型的视频处理方案）：</p><p><img src="http://img-repo.poetries.top/images/20210418173047.png" alt></p><p>在该方案中，我们用 OSS 来存储海量的视频内容，视频上传后用视频转码服务将不同来源的视频进行转码，以适配各种终端，然后利用 CDN 提升客户端访问视频的速度。</p><p>不过，虽然用了视频转码服务，但我们还是要购买大量的服务器，搭建自己的视频处理系统，对视频进行更高级的自定义处理，比如视频转码后将元数据存入数据库、生成视频前几秒的 GIF 图片用来做视频的封面，以及各种格式的音视频转换等。</p><p>除此之外，当我们已经在服务器上部署了一套视频处理系统后，可能还会遇到一些问题。比如，如何应对大量并发任务？能否让这个系统有更高的弹性和可用性？这些问题其实超出了视频处理本身的范围，我们的需求只是进行视频处理，但不得不面临繁重的运维工作。并且我们可能为了应对周期大量处理任务或瞬时流量，不得不购买大量的服务器，成本大幅增加，在服务器的闲置期间还造成了不必要的资源浪费。而且我们也无法 100% 利用机器的性能，这也是一种资源浪费。</p><p>而 Serverless 就能解决这些问题，基于 Serverless 你可以很轻松实现一个弹性、可扩展、低成本、免运维、高可用的音视频处理系统。</p><h4 id="3-2-基于-Serverless-的音视频处理系统"><a href="#3-2-基于-Serverless-的音视频处理系统" class="headerlink" title="3.2 基于 Serverless 的音视频处理系统"></a>3.2 基于 Serverless 的音视频处理系统</h4><ul><li>从基础设施的角度来看，基于 Serverless 的音视频解决方案，主要是替换了传统方案中的计算资源，也就是替换了服务器。</li><li>此外，我们基于 Serverless 平台提供的丰富的触发器，也能简化编程模型。比如以往我们需要用户将视频上传到 OSS 后，再通过接口主动通知服务器进行视频处理，但在 Serverless 架构中，我们可以为函数设置 OSS 触发器，这样只要有文件被上传到 OSS 中，就可以触发函数执行，进而简化了业务逻辑。</li></ul><p>下图就是基于 Serverless 的视频处理系统解决方案：</p><p><img src="http://img-repo.poetries.top/images/20210418173248.png" alt></p><p>用户将视频上传后 OSS 后，触发函数计算中的视频转码函数执行，该函数对视频进行转码后，将元数据存入数据库，然后将转码后的视频再保存到 OSS 中。</p><p>接下来我们就实现一个基于 Serverless 的音视频处理系统，系统主要有以下几个功能：</p><ul><li>获取视频时长；</li><li>获取视频元数据；</li><li>截取视频 GIF 图；</li><li>为视频添加水印；</li><li>对视频进行转码。</li></ul><p>为了方便你实践，我为你提供了一份示例代码，你可以通过 git 下载查看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/poetries/serverless-class</span><br><span class="line">$ cd 18/serverless-video</span><br></pre></td></tr></table></figure><p>代码结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── functions</span><br><span class="line">│   ├── common</span><br><span class="line">│   │   └── utils.js</span><br><span class="line">│   ├── get_duration</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   └── get_meta</span><br><span class="line">│       └── index.js</span><br><span class="line">├── build.js</span><br><span class="line">├── ffmpeg</span><br><span class="line">├── ffprobe</span><br><span class="line">├── package.json</span><br><span class="line">└── template.yml</span><br></pre></td></tr></table></figure><blockquote><p>其中 functions 中是函数源代码，common/utils.js是一些公共方法，get_duration、get_meta等目录则分别对应的每个具体的功能。build.js是用来构建函数的脚本。在代码中，我们会使用 FFmpeg 进行视频处理，FFmpeg 是一款功能强大、用途广泛的开源软件，很多视频网站都在用它，比如 Youtube、Bilibili。ffmpeg 和 ffprobe 是 FFmpeg 的两个命令行工具，我们会将其作为依赖部署到 FaaS 平台（函数计算）上，这样在函数中就可以使用这两个命令来处理视频了。</p></blockquote><p>接下来就让我们学习具体如何实现。</p><p>由于这几个函数的逻辑基本类似，所以我主要针对“获取视频时长”函数进行讲解，学会了这个函数的实现就很容易理解其他函数了。另外，由于该视频处理系统用到了公共方法及依赖，所以我还会为你介绍如何部署这些函数。</p><h4 id="3-3-获取视频时长函数的实现"><a href="#3-3-获取视频时长函数的实现" class="headerlink" title="3.3 获取视频时长函数的实现"></a>3.3 获取视频时长函数的实现</h4><p>首先是获取视频时长的实现，也就是 get_duration 函数。我们可以通过 ffprobe 来获取视频时长，命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ffprobe -v quiet -show_entries format=duration -print_format json -i video.mp4</span><br><span class="line">&#123;</span><br><span class="line">    &quot;format&quot;: &#123;</span><br><span class="line">        &quot;duration&quot;: &quot;170.859000&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中-print_format json是指以 JSON 格式输出结果，-i是指定文件位置，可以是本地文件，也可以是网络上的远程文件。</p></blockquote><p>所以获取视频时长的函数逻辑就是： 下载 OSS 中的文件到本地，然后运行 ffprobe 命令得到视频时长，最后返回视频时长。</p><p>为了让代码尽可能复用，所以我在<code>common/utils.js</code>中实现了一些公共方法，代码大致如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common/utils.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行 Linux 命令</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>command 待运行的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">command</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(command)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    child_process.exec(command, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stderr) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(stderr)</span><br><span class="line">        <span class="keyword">return</span> reject(stderr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(stdout)</span><br><span class="line">      <span class="keyword">return</span> resolve(stdout);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 OSS Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>context 函数上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOssClient</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取函数计算的临时访问凭证</span></span><br><span class="line">  <span class="keyword">const</span> accessKeyId = context.credentials.accessKeyId;</span><br><span class="line">  <span class="keyword">const</span> accessKeySecret = context.credentials.accessKeySecret;</span><br><span class="line">  <span class="keyword">const</span> securityToken = context.credentials.securityToken;</span><br><span class="line">  <span class="comment">// 初始化 OSS 客户端</span></span><br><span class="line">  <span class="keyword">const</span> client = oss(&#123;</span><br><span class="line">    accessKeyId,</span><br><span class="line">    accessKeySecret,</span><br><span class="line">    stsToken: securityToken,</span><br><span class="line">    bucket: OSS_BUCKET_NAME,</span><br><span class="line">    region: OSS_REGION,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  exec,</span><br><span class="line">  getOssClient,</span><br><span class="line">  OSS_VIDEO_NAME,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>common/utils.js的代码主要就包含两个方法：exec和getOssClient，分别用来执行 Linux 系统命令和获取 OSS 客户端。</p></blockquote><p>这样我们在functions/get_duration/index.js中就可以直接引入并使用了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functions/get_duration/index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; exec, getOssClient, OSS_VIDEO_NAME &#125; = <span class="built_in">require</span>(<span class="string">"../common/utils"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取视频元信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>client OSS client</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getDuration</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filePath = <span class="string">"/tmp/video.mp4"</span>;</span><br><span class="line">  <span class="keyword">await</span> client.get(OSS_VIDEO_NAME, filePath);</span><br><span class="line">  <span class="keyword">const</span> command = <span class="string">`./ffprobe -v quiet -show_entries format=duration -print_format json -i <span class="subst">$&#123;filePath&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> exec(command);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 OSS 客户端</span></span><br><span class="line">  <span class="keyword">const</span> client = getOssClient(context);</span><br><span class="line">  getDuration(client)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"视频时长: \n"</span>, res);</span><br><span class="line">      callback(<span class="literal">null</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> callback(err));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先注意第 20 行，我们通过 getOssClient 获取到 OSS 客户端，然后调用 getDuration 函数执行业务逻辑，也就是获取视频时长。</p><p>在 getDuration 中，我们先下载视频到临时目录/tmp/video.mp4中，临时目录是可以读写的，当前代码目录只能写不能读。然后在第 13 行，通过 exec 执行了获取视频时长的命令，最后将得到的结果返回。</p><p>这样获取视频时长的功能就开发完成了。</p><p>获取视频元数据等其他函数与获取视频时长的实现是非常类似的，不同之处主要在于执行的命令，也就是第 12 行的command变量。具体实现可以参考我的示例代码，这里就不赘述。</p><p>由于该系统包含多个函数，且函数不仅依赖了 ffmpeg ，还依赖了公共的<code>common/utils.js</code>，所以很多同学就犯难了，这些函数应该怎么部署呢？</p><h4 id="3-4-音视频处理系统的部署"><a href="#3-4-音视频处理系统的部署" class="headerlink" title="3.4 音视频处理系统的部署"></a>3.4 音视频处理系统的部署</h4><p>我们需要将 ffmpeg 或 ffprobe 上传。看起来比较简单，我们直接将其放在函数代码目录并上传就可以了。</p><p>不过这里需要注意的是， 由于 ffmpeg 和 ffprobe 是可执行文件，最终我们需要用到这两个命令，所以在上传到 FaaS 平台之前，需要为其赋予可执行权限。</p><p>你可以通过ls -l来查看文件的权限：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-rwxr-xr-x    1 root  staff  39000328  2  9 20:59 ffmpeg</span><br><span class="line">-rwxr-xr-x    1 root  staff  38906056  2  9 21:00 ffprobe</span><br></pre></td></tr></table></figure><p>-rwxr-xr-x分为四部分：</p><ul><li>第 0 位-表示文件类型；</li><li>第 1-3 位rwx表示文件所有者的权限；</li><li>第 4-6 位r-x是同组用户的权限；</li><li>第 7-9r-x位表示其他用户的权限。</li></ul><blockquote><p>r 表示读权限，w 表示写权限，x 表示执行权限。从文件权限可以看出，针对所有用户这两个文件都有可执行权限。</p></blockquote><p>如果你的这两个文件没有执行权限，则需要通过下面的命令添加权限：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x ffmpeg</span><br><span class="line">$ chmod +x ffprobe</span><br></pre></td></tr></table></figure><ul><li>这样在 FaaS 平台上，Node.js 才可以执行这两个命令。</li><li>解决了可执行文件的权限问题后，还有一个问题是函数的权限。</li></ul><p>由于函数需要读写 OSS，所以我们需要为函数设置角色，并为该角色添加管理 OSS 的权限。如果你不清楚如何授权，可以复习一下 “10｜访问控制：如何授权访问其他云服务？”的内容。</p><blockquote><p>在我提供的示例代码中，我在 template.yaml 的第 7 行设置了函数的角色acs:ram::1457216987974698:role/aliyunfclogexecutionrole，文件内容如下所示：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROSTemplateFormatVersion: &apos;2015-09-01&apos;</span><br><span class="line">Transform: &apos;Aliyun::Serverless-2018-04-03&apos;</span><br><span class="line">Resources:</span><br><span class="line">  serverless-video:</span><br><span class="line">    Type: &apos;Aliyun::Serverless::Service&apos;</span><br><span class="line">    Properties:</span><br><span class="line">      Role: acs:ram::1457216987974698:role/aliyunfclogexecutionrole</span><br><span class="line">      Description: &apos;基于 Serverless 开发高可用音视频处理系统&apos;</span><br><span class="line">    get_duration:</span><br><span class="line">      Type: &apos;Aliyun::Serverless::Function&apos;</span><br><span class="line">      Properties:</span><br><span class="line">        Handler: index.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        Timeout: 600</span><br><span class="line">        MemorySize: 256</span><br><span class="line">        CodeUri: ./.serverless/get_duration</span><br><span class="line">    get_meta:</span><br><span class="line">      Type: &apos;Aliyun::Serverless::Function&apos;</span><br><span class="line">      Properties:</span><br><span class="line">        Handler: index.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        Timeout: 600</span><br><span class="line">        MemorySize: 256</span><br><span class="line">        CodeUri: ./.serverless/get_meta</span><br><span class="line"></span><br><span class="line">      ......</span><br></pre></td></tr></table></figure><p>细心的你可能发现了，在该 YAML 配置中，函数的 CodeUri 不是./functions/get_durtion，而是./.serverless/get_meta，这是为什么呢？</p><p>这主要是因为我们需要对函数代码进行构建，./.serverless/get_duration对应的是构建后的代码。之所以需要构建，是为了解决common/utils.js代码共用的问题。</p><p>如果不对代码进行构建，直接部署functions/get_duration中的代码，函数执行时就会报错：Cannot find module ‘../common/utils，因为common/utils.js不在入口函数目录中，没有部署到 FaaS 上。</p><p>要解决这个问题，就需要对代码进行构建，将函数及依赖的所有代码构建为单个文件，这样部署时就只需要部署一个文件，不涉及目录和依赖的问题了。</p><p>我们可以使用 ncc 这个工具对函数进行构建，使用方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-oss</span><br></pre></td></tr></table></figure><p>该命令就会将<code>functions/get_duration/index.js</code>进行构建，最终会将<code>index.js</code>以及缩依赖的 exec、getOSSClient 等方法进行编译，最终合并为一个文件并输出到<code>./.serverless/get_duration/</code>目录中。</p><p><strong>这里还需要注意的是</strong><code>-e ali-oss</code>这个参数，含义是构建时，排除 ali-oss 这个依赖，也就是不将其编译到最终的<code>index.js</code>文件中。这是因为函数计算的 Node.js 运行时内置了 ali-oss 模块，所以我们的构建产物就不需要包含 ali-oss 的代码了。</p><p>处理对代码进行构建，我们还需要将 ffmpeg 和 ffprobe 复制到对应的函数目录中。最终我将这些步骤编写到了<code>build.js</code>中，内容如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">"./functions/common/utils"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 清空编译目录</span></span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"rm -rf .serverless/*"</span>);</span><br><span class="line">  <span class="comment">// 编译 get_duration 函数</span></span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"mkdir -p ./.serverless/get_duration"</span>);</span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">`ncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-oss`</span>);</span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"cp ./ffprobe ./.serverless/get_duration/ffprobe"</span>);</span><br><span class="line">  <span class="comment">// 编译 get_meta 函数</span></span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"mkdir -p ./.serverless/get_meta"</span>);</span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">`ncc build ./functions/get_meta/index.js -o ./.serverless/get_meta/ -e ali-oss`</span>);</span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"cp ./ffprobe ./.serverless/get_meta/ffprobe"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">build();</span><br></pre></td></tr></table></figure><p>然后我在 package.json 中添加了两个命令：</p><ul><li>build构建函数</li><li>deploy构建并部署</li></ul><p>例如你开发完成后需要部署，就可以直接运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm run deploy</span><br><span class="line">&gt; serverless-video@1.0.0 deploy</span><br><span class="line">&gt; npm run build &amp;&amp; fun deploy</span><br><span class="line">&gt; serverless-video@1.0.0 build</span><br><span class="line">&gt; node build.js</span><br><span class="line">rm -rf .serverless/*</span><br><span class="line">mkdir -p ./.serverless/get_duration</span><br><span class="line">ncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-oss</span><br><span class="line"></span><br><span class="line">using template: template.yml</span><br><span class="line">Waiting for service serverless-video to be deployed...</span><br><span class="line">    Waiting for function get_duration to be deployed...</span><br><span class="line">        Waiting for packaging function get_duration code...</span><br><span class="line">        The function get_duration has been packaged. A total of 2 files were compressed and the final size was 15.2 MB</span><br><span class="line">    function get_duration deploy success</span><br><span class="line">......</span><br><span class="line">service serverless-video deploy success</span><br></pre></td></tr></table></figure><p>部署成功后，我们就可以对函数进行测试了，可以直接在控制台上运行函数，也可以通过fun invoke执行函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ fun invoke get_duration</span><br><span class="line">&#123;</span><br><span class="line">    &quot;format&quot;: &#123;</span><br><span class="line">        &quot;duration&quot;: &quot;170.859000&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强调下面几点：</strong></p><ul><li>Serverless 除了适合 Web 接口、服务端渲染等场景，还适合 CPU 密集型的任务；</li><li>基于 Serverless 开发的音视频处理系统，本身就具备弹性、可扩展、低成本、免运维、高可用的能力；</li><li>对于需要通过代码执行的命令行工具等依赖，部署到 FaaS 平台之前需要为其设置可执行权限；若函数依需要调用其他云产品的接口，需要为函数授予相应权限；</li><li>对于添加水印、视频转码等消耗资源的操作，需要为函数设置较大的内存和超时时间。</li></ul><h3 id="4-使用-React-js-开发-Serverless-服务端渲染应用"><a href="#4-使用-React-js-开发-Serverless-服务端渲染应用" class="headerlink" title="4 使用 React.js 开发 Serverless 服务端渲染应用"></a>4 使用 React.js 开发 Serverless 服务端渲染应用</h3><p>对前端工程师来说，Serverless 最大的应用场景之一就是开发服务端渲染（SSR）应用。因为传统的服务端渲染应用要由前端工程师负责服务器的运维，但往往前端工程师并不擅长这一点，基于 Serverless 开发服务端渲染应用的话，就可以减轻这个负担。希望你学完今天的内容之后，能够学会如何去使用 Serverless 开发一个服务端渲染应用。</p><h3 id="5-基于-Serverless-的服务端渲染架构"><a href="#5-基于-Serverless-的服务端渲染架构" class="headerlink" title="5 基于 Serverless 的服务端渲染架构"></a>5 基于 Serverless 的服务端渲染架构</h3><blockquote><p>现在的主流前端框架是 React.js、Vue.js 等，基于这些框架开发的都是单页应用，其渲染方式都是客户端渲染：代码开发完成后，构建出一个或多个 JS 资源，页面渲染时加载这些 JS 资源，然后再执行 JS 渲染页面。虽然这些框架可以极大提升前端开发效率，但也带来了一些新的问题。</p></blockquote><ul><li><strong>不利于 SEO：</strong> 页面源码不再是HTML，而是渲染 HTML 的 JavaScript，这就导致搜索引擎爬虫难以解析其中的内容；</li><li><strong>初始化性能差：</strong> 通常单元应用的 JS 文件体积都比较大、加载耗时比较长，导致页面白屏。</li></ul><p>为了解决这些问题，很多框架和开发者就开始尝试服务端渲染的方式：页面加载时，由服务端先生成 HTML 返回给浏览器，浏览器直接渲染 HTML。在传统的服务端渲染架构中，通常需要前端同学使用 Node.js 去实现一个服务端的渲染应用。在应用内，每个请求的 path 对应着服务端的每个路由，由该路由实现对应 path 的 HTML 文档渲染：</p><p><img src="http://img-repo.poetries.top/images/20210418174418.png" alt></p><p>传统服务端渲染架构</p><p>对前端工程师来说，要实现一个服务端渲染应用，通常面临着一些问题：</p><ul><li>部署服务端渲染应用需要购买服务器，并配置服务器环境，要对服务器进行运维；</li><li>需要关注业务量，考虑有没有高并发场景、服务器有没有扩容机制；</li><li>需要实现负载均衡、流量控制等复杂后端能力等。</li></ul><p>开篇我也提到，而且是服务端的工作，很多前端同学都不擅长，好在有了 Serverless。</p><p>用 Serverless 做服务端渲染，就是将以往的每个路由，都拆分为一个个函数，再在 FaaS 上部署对应的函数，这样用户请求的 path，对应的就是每个单独的函数。通过这种方式，就将运维操作转移到了 FaaS 平台，前端同学开发服务端渲染应用，就再也不用关心服务端程序的运维部署了。并且在 FaaS 平台中运行的函数，天然具有弹性伸缩的能力，你也不用担心流量波峰波谷了。</p><p><img src="http://img-repo.poetries.top/images/20210418174139.png" alt></p><p>基于 Serverless 的服务选渲染架构</p><p>如图所示，FaaS 函数接收请求后直接执行代码渲染出 HTML 并返回给浏览器，这是最基本的架构，虽然它可以满足大部分场景，但要追求极致的性能，你通常要加入缓存。</p><p><img src="http://img-repo.poetries.top/images/20210418174151.png" alt></p><p>进阶版基于 Serverless 的服务端渲染架构</p><p>首先我们会使用 CDN 做缓存，基于 CDN 的缓存可以减少函数执行次数，进而避免函数冷启动带来的性能损耗。如果 CDN 中没有 SSR HTML 页面的缓存，则继续由网关处理请求，网关再去触发函数执行。</p><p>函数首先会判读缓存数据库中是否有 SSR HTML 的缓存，如果有直接返回；如果没有再渲染出 HTML 并返回。基于数据库的缓存，可以减少函数渲染 HTML 的时间，从而页面加载提升性能。</p><p>讲了这么多，具体怎么基于 Serverless 实现一个服务端渲染应用呢？</p><h4 id="5-1-实现一个-Serverless-的服务端渲染应用"><a href="#5-1-实现一个-Serverless-的服务端渲染应用" class="headerlink" title="5.1 实现一个 Serverless 的服务端渲染应用"></a>5.1 实现一个 Serverless 的服务端渲染应用</h4><p>我们实现了一个内容管理系统的 Restful API，但没有前端界面，所以今天我们的目标就基于 Serverless 实现一个内容管理系统的前端界面（如图所示）。</p><p><img src="https://s0.lgstatic.com/i/image/M00/94/3B/Ciqc1GAXxoiANTROADtU9yybMQY209.gif" alt="ssr.gif"></p><p>该应用主要包含两个页面：</p><ul><li>首页，展示文章列表；</li><li>详情页，展示文章详情。</li></ul><p>为了方便你进行实践，我为你提供了一份示例代码，你可以直接下载并使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载代码</span><br><span class="line"></span><br><span class="line">$ git clone https://github.com/poetries/serverless-class</span><br><span class="line"></span><br><span class="line"># 进入服务端渲染应用目录</span><br><span class="line"></span><br><span class="line">$ cd 16/serverless-ssr-cms</span><br></pre></td></tr></table></figure><p>代码结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"></span><br><span class="line">├── config.js</span><br><span class="line"></span><br><span class="line">├── f.yml</span><br><span class="line"></span><br><span class="line">├── package-lock.json</span><br><span class="line"></span><br><span class="line">├── package.json</span><br><span class="line"></span><br><span class="line">├── src</span><br><span class="line"></span><br><span class="line">│   ├── api.ts</span><br><span class="line"></span><br><span class="line">│   ├── config</span><br><span class="line"></span><br><span class="line">│   │   └── config.default.ts</span><br><span class="line"></span><br><span class="line">│   ├── configuration.ts</span><br><span class="line"></span><br><span class="line">│   ├── index.ts</span><br><span class="line"></span><br><span class="line">│   ├── interface</span><br><span class="line"></span><br><span class="line">│   │   ├── detail.ts</span><br><span class="line"></span><br><span class="line">│   │   └── index.ts</span><br><span class="line"></span><br><span class="line">│   ├── mock</span><br><span class="line"></span><br><span class="line">│   │   ├── detail.ts</span><br><span class="line"></span><br><span class="line">│   │   └── index.ts</span><br><span class="line"></span><br><span class="line">│   ├── render.ts</span><br><span class="line"></span><br><span class="line">│   └── service</span><br><span class="line"></span><br><span class="line">│       ├── detail.ts</span><br><span class="line"></span><br><span class="line">│       └── index.ts</span><br><span class="line"></span><br><span class="line">├── tsconfig.json</span><br><span class="line"></span><br><span class="line">├── tsconfig.lint.json</span><br><span class="line"></span><br><span class="line">└── web</span><br><span class="line"></span><br><span class="line">    ├── @types</span><br><span class="line"></span><br><span class="line">    │   └── global.d.ts</span><br><span class="line"></span><br><span class="line">    ├── common.less</span><br><span class="line"></span><br><span class="line">    ├── components</span><br><span class="line"></span><br><span class="line">    │   ├── layout</span><br><span class="line"></span><br><span class="line">    │   │   ├── index.less</span><br><span class="line"></span><br><span class="line">    │   │   └── index.tsx</span><br><span class="line"></span><br><span class="line">    │   └── title</span><br><span class="line"></span><br><span class="line">    │       ├── index.less</span><br><span class="line"></span><br><span class="line">    │       └── index.tsx</span><br><span class="line"></span><br><span class="line">    ├── interface</span><br><span class="line"></span><br><span class="line">    │   ├── detail-index.ts</span><br><span class="line"></span><br><span class="line">    │   ├── index.ts</span><br><span class="line"></span><br><span class="line">    │   └── page-index.ts</span><br><span class="line"></span><br><span class="line">    ├── pages</span><br><span class="line"></span><br><span class="line">    │   ├── detail</span><br><span class="line"></span><br><span class="line">    │   │   ├── fetch.ts</span><br><span class="line"></span><br><span class="line">    │   │   ├── index.less</span><br><span class="line"></span><br><span class="line">    │   │   └── render$id.tsx</span><br><span class="line"></span><br><span class="line">    │   └── index</span><br><span class="line"></span><br><span class="line">    │       ├── fetch.ts</span><br><span class="line"></span><br><span class="line">    │       ├── index.less</span><br><span class="line"></span><br><span class="line">    │       └── render.tsx</span><br><span class="line"></span><br><span class="line">    └── tsconfig.json</span><br></pre></td></tr></table></figure><p>文件很多，不过不用担心，你只需重点关注 web/pages/ 和 src/service 两个目录：</p><ul><li>web/ 目录中主要是前端页面的代码， web/pages/ 中的文件分别对应着我们要实现的 index（首页）和 detail（详情页）两个页面，这两个页面会使用到 components 目录中的公共组件；</li><li>src/ 目录中主要是后端代码，src/service 目录中的 index.ts  和 detail.ts 则定义了两个页面分别需要用到的接口，为了简单起见，接口数据我使用了 src/mock/ 目录中的 mock 数据。</li></ul><p>当我一个人又负责前端页面也负责后端接口的开发时，通常习惯先实现接口，再开发前端页面，这样方便调试。接下来就让我们看一下具体是怎么实现的。</p><h4 id="5-2-首页接口的实现"><a href="#5-2-首页接口的实现" class="headerlink" title="5.2 首页接口的实现"></a>5.2 首页接口的实现</h4><p>其源码在 src/service/index.ts 文件中，代码如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/service/index.ts</span><br><span class="line"></span><br><span class="line">import &#123; provide &#125; from &apos;@midwayjs/faas&apos;</span><br><span class="line"></span><br><span class="line">import &#123; IApiService &#125; from &apos;../interface&apos;</span><br><span class="line"></span><br><span class="line">import mock from &apos;../mock&apos;</span><br><span class="line"></span><br><span class="line">@provide(&apos;ApiService&apos;)</span><br><span class="line"></span><br><span class="line">export class ApiService implements IApiService &#123;</span><br><span class="line"></span><br><span class="line">  async index (): Promise&lt;any&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return await Promise.resolve(mock)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了一个 ApiService 类以及 index 方法，该方法会返回首页的文章列表。数据结构如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;data&quot;:[</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            &quot;id&quot;:&quot;3f8a198c-60a2-11eb-8932-9b95cd7afc2d&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;title&quot;:&quot;开篇词：Serverless 大热，程序员面临的新机遇与挑战&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;content&quot;:&quot;可能你会认为 Serverless 是最近两年兴起的技术......&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;date&quot;:&quot;2020-12-23&quot;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            &quot;id&quot;:&quot;5158b100-5fee-11eb-9afa-9b5f85523067&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;title&quot;:&quot;基础入门：编写你的第一个 Serverless 应用&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;content&quot;:&quot;学习一门新技术，除了了解其基础概念，更重要的是把理论转化为实践...&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;date&quot;:&quot;2020-12-29&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行服务端渲染时，你可以通过 ctx 获取到 ApiService 实例，进而调用其中的方法，获取文章列表数据。此外，ApiService 也会被 src/api.ts 调用，src/api.ts 则直接对外提供了 HTTP 接口。</p><h4 id="5-3-首页页面的实现"><a href="#5-3-首页页面的实现" class="headerlink" title="5.3 首页页面的实现"></a>5.3 首页页面的实现</h4><p>有了接口后，我们就可以继续实现首页的前端页面了。首页页面的代码在 web/pages/ 目录中，该目录下有三个文件：</p><ul><li>fetch.ts，获取首页数据；</li><li>render.tsx 首页页面 UI 组件代码；</li><li>index.less 样式代码。</li></ul><p>首先来看一下 fetch.ts：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// web/pages/index/fetch.ts</span><br><span class="line"></span><br><span class="line">import &#123; IFaaSContext &#125; from &apos;ssr-types&apos;</span><br><span class="line"></span><br><span class="line">import &#123; IndexData &#125; from &apos;@/interface&apos;</span><br><span class="line"></span><br><span class="line">interface IApiService &#123;</span><br><span class="line"></span><br><span class="line">  index: () =&gt; Promise&lt;IndexData&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default async (ctx: IFaaSContext&lt;&#123;</span><br><span class="line"></span><br><span class="line">  apiService?: IApiService</span><br><span class="line"></span><br><span class="line">&#125;&gt;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const data = __isBrowser__ ? await (await window.fetch(&apos;/api/index&apos;)).json() : await ctx.apiService?.index()</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line"></span><br><span class="line">    indexData: data</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码的逻辑比较简单，核心点在第 10 行</strong>，如果是浏览器，就用浏览器自带的 fetch 方法请求<code>/api/index</code>接口获取数据；如果不是浏览器，即服务端渲染，可以直接调用 apiService 中的 index 方法。获取到数据后，将其存入 state.indexData 中，这样在 UI 组件中就可以使用了。<br>首页的 UI 组件 render.tsx 代码如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// web/pages/index/render.tsx</span><br><span class="line"></span><br><span class="line">import React, &#123; useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; SProps, IContext &#125; from &quot;ssr-types&quot;;</span><br><span class="line"></span><br><span class="line">import Navbar from &quot;@/components/navbar&quot;;</span><br><span class="line"></span><br><span class="line">import Header from &quot;@/components/header&quot;;</span><br><span class="line"></span><br><span class="line">import Item from &quot;@/components/item&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; IData &#125; from &quot;@/interface&quot;;</span><br><span class="line"></span><br><span class="line">import styles from &quot;./index.less&quot;;</span><br><span class="line"></span><br><span class="line">export default (props: SProps) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const &#123; state &#125; = useContext&lt;IContext&lt;IData&gt;&gt;(window.STORE_CONTEXT);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Navbar &#123;...props&#125; isHomePage=&#123;true&#125;&gt;&lt;/Navbar&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;state?.indexData?.data.map((item) =&gt; (</span><br><span class="line"></span><br><span class="line">          &lt;Item</span><br><span class="line"></span><br><span class="line">            &#123;...props&#125;</span><br><span class="line"></span><br><span class="line">            id=&#123;item.id&#125;</span><br><span class="line"></span><br><span class="line">            key=&#123;item.id&#125;</span><br><span class="line"></span><br><span class="line">            title=&#123;item.title&#125;</span><br><span class="line"></span><br><span class="line">            content=&#123;item.content&#125;</span><br><span class="line"></span><br><span class="line">            date=&#123;item.date&#125;</span><br><span class="line"></span><br><span class="line">          &gt;&lt;/Item&gt;</span><br><span class="line"></span><br><span class="line">        ))&#125;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 UI 组件中，我们可以通过 useContext 获取刚才由 fetch.ts 存入 state 的数据，然后利用数据渲染 UI。UI 组件主要由三部分组成。</p><ul><li>Navbar：导航条。</li><li>Header：页面标题。</li><li>Item：每篇文章的简介。</li></ul><p><img src="http://img-repo.poetries.top/images/20210418174309.png" alt></p><h4 id="5-4-详情页接口的实现"><a href="#5-4-详情页接口的实现" class="headerlink" title="5.4 详情页接口的实现"></a>5.4 详情页接口的实现</h4><p>完成了首页后，就可以实现详情页了。详情页与首页整体类似，区别就在于详情页需要传入参数查询某条数据。</p><p>详情页接口在 src/service/detail.ts 中 ，代码如下所示：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/service/detail.ts</span><br><span class="line"></span><br><span class="line">import &#123; provide &#125; from &apos;@midwayjs/faas&apos;</span><br><span class="line"></span><br><span class="line">import &#123; IApiDetailService &#125; from &apos;../interface/detail&apos;</span><br><span class="line"></span><br><span class="line">import mock from &apos;../mock/detail&apos;</span><br><span class="line"></span><br><span class="line">@provide(&apos;ApiDetailService&apos;)</span><br><span class="line"></span><br><span class="line">export class ApiDetailService implements IApiDetailService &#123;</span><br><span class="line"></span><br><span class="line">  async index (id): Promise&lt;any&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return await Promise.resolve(mock.data[id])</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们实现了一个 ApiDetailService 类以及 index 方法，index 方法的如参 id 即文章 ID，然后根据文章 ID 从 mock 数据中查询文章详情。</p><p>文章详情数据如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;title&quot;:&quot;Serverless 大热，程序员面临的新机遇与挑战&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;wordCount&quot;:2540,</span><br><span class="line"></span><br><span class="line">    &quot;readingTime&quot;:10,</span><br><span class="line"></span><br><span class="line">    &quot;date&quot;:&quot;2020-12-23 12:00:00&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;content&quot;:&quot;可能你会认为 Serverless 是最近两年兴起的技术，实际上，Serverless 概念从 2012 年就提出来了，随后 AWS 在 2014 年推出了第一款 Serverless 产品 Lambda，开启了 Serverless 元年... &quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-详情页页面的实现"><a href="#5-5-详情页页面的实现" class="headerlink" title="5.5 详情页页面的实现"></a>5.5 详情页页面的实现</h4><p>和首页一样，详情页也包含数据请求、UI 组件和样式代码三个文件。</p><p>数据请求代码文件的命名和首页一样，都是 fetch.ts。与首页不同的是，详情页我们需要从上下文（服务端渲染场景）或 URL 中（浏览器场景）获取到文章 ID，然后根据文章 ID 获取文章详情数据。代码如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; RouteComponentProps &#125; from &quot;react-router&quot;;</span><br><span class="line"></span><br><span class="line">export default async (ctx) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  let data;</span><br><span class="line"></span><br><span class="line">  if (__isBrowser__) &#123;</span><br><span class="line"></span><br><span class="line">    const id = (ctx as RouteComponentProps&lt;&#123; id: string &#125;&gt;).match.params.id;</span><br><span class="line"></span><br><span class="line">    data = await (await window.fetch(`/api/detail/$&#123;id&#125;`)).json()</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    const id = /detail\/(.*)(\?|\/)?/.exec(ctx.req.path)[1];</span><br><span class="line"></span><br><span class="line">    data = await ctx.apiDeatilservice.index(id);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line"></span><br><span class="line">    detailData: data,</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详情页的 UI 组件名称为<code>render$id.tsx</code>的文件，<code>$id</code>表示该组件的参数是 id，这样访问 /detail/ 这个路由（id 是变量）时，就会匹配到 web/pages/detail/render$id.tsx 这个页面了。</p><p><code>render$id.tsx</code>详细代码如下：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; IContext, SProps &#125; from &quot;ssr-types&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; Data &#125; from &quot;@/interface&quot;;</span><br><span class="line"></span><br><span class="line">import Navbar from &quot;@/components/navbar&quot;;</span><br><span class="line"></span><br><span class="line">import Content from &quot;@/components/content&quot;;</span><br><span class="line"></span><br><span class="line">import Title from &quot;@/components/title&quot;;</span><br><span class="line"></span><br><span class="line">import Tip from &quot;@/components/tip&quot;;</span><br><span class="line"></span><br><span class="line">import styles from &quot;./index.less&quot;;</span><br><span class="line"></span><br><span class="line">export default (props: SProps) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const &#123; state &#125; = useContext&lt;IContext&lt;Data&gt;&gt;(window.STORE_CONTEXT);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Navbar &#123;...props&#125;&gt;&lt;/Navbar&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Title&gt;&#123;state?.detailData?.title&#125;&lt;/Title&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Tip</span><br><span class="line"></span><br><span class="line">          date=&#123;state?.detailData?.date&#125;</span><br><span class="line"></span><br><span class="line">          wordCount=&#123;state?.detailData?.wordCount&#125;</span><br><span class="line"></span><br><span class="line">          readingTime=&#123;state?.detailData?.readingTime&#125;</span><br><span class="line"></span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Content&gt;&#123;state?.detailData?.content&#125;&lt;/Content&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详情页的 UI 组件由四部分组成。</p><ul><li>Navbar：导航条。</li><li>Title：文章标题。</li><li>Tip：文章发布时间、字数等提示。</li><li>Content：文章内容。</li></ul><p><img src="http://img-repo.poetries.top/images/20210418174323.png" alt></p><h4 id="5-6-应用部署"><a href="#5-6-应用部署" class="headerlink" title="5.6 应用部署"></a>5.6 应用部署</h4><p>代码开发完成后，你可以通过下面的命令在本地启动应用：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm start</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[HPM] Proxy created: /asset-manifest  -&gt; http://127.0.0.1:8000</span><br><span class="line"></span><br><span class="line"> Server is listening on http://localhost:3000</span><br></pre></td></tr></table></figure><p>应用启动后就可以打开浏览器输入 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000</a> 查看效果了。<br>在本地开发测试完成后，接下来就需要将其部署到函数计算。你可以运行 npm run deploy 命令进部署：</p><p>复制代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm run deploy</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">service  serverless-ssr-cms deploy success</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">The assigned temporary domain is http://41506101-1457216987974698.test.functioncompute.com，expired at 2021-02-04 00:35:01, limited by 1000 per day.</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Deploy success</span><br></pre></td></tr></table></figure><p><code>npm run deploy</code>其实是执行了构建代码和部署应用两个步骤，这两个步骤都是在本机执行的。但这就存在一个隐藏风险，如果团队同学本地开发环境不同，就可能导致构建产物不同，进而导致部署到线上的代码存在风险。<strong>所以更好的实践是：实现一个业务的持续集成流程，统一构建部署。</strong></p><p>应用部署成功后，会自动创建一个测试的域名，例如<a href="http://41506101-1457216987974698.test.functioncompute.com/" target="_blank" rel="noopener">http://41506101-1457216987974698.test.functioncompute.com</a>，我们可以打开该域名查看最终效果。</p><p>讲到这儿，基于 Serverless 的服务端渲染应用就开发完成了。</p><h4 id="5-7-总结"><a href="#5-7-总结" class="headerlink" title="5.7 总结"></a>5.7 总结</h4><p>总的来说，基于 Serverless 的服务端渲染应用实现也比较简单。如果你想要追求更好的用户体验，我也建议你对核心业务做服务端渲染的优化。基于 Serverless 的服务端渲染，可以让我们不用再像以前一样担心服务器的运维和扩容，大大提高了生产力。同时有了服务端渲染后，我也建议你完善业务的持续集成流程，将整个研发链路打通，降低代码构建发布的风险，提升从开发到测试再到部署的效率。</p><p>当然，要达到页面的极致体验，我们还需要做很多工作，比如：</p><ul><li>将静态资源部署到 CDN，提升资源加载速度；</li><li>针对页面进行缓存，减少函数冷启动对性能的影响；</li><li>对服务端异常进行降级处理等等。</li></ul><p>但不管我们用不用 Serverless，都需要做这些工作。关于这一讲，我想要强调以下几点：</p><ul><li>基于 Serverless 的服务端渲染应用，可以让我们不用关心服务器的运维，应用也天然具有弹性；</li><li>基于 Serverless 开发服务端渲染应用，建议你完善业务的持续集成流程；</li><li>要达到页面的极致性能，还需要考虑将静态资源部署到 CDN、对页面进行缓存等技术；</li><li>对于服务端渲染应用，建议你完善业务的服务降级能力，进一步提高稳定性。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是Serverless&quot;&gt;&lt;a href=&quot;#一、什么是Serverless&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Serverless&quot;&gt;&lt;/a&gt;一、什么是Serverless&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Serve
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="serverless" scheme="http://blog.poetries.top/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>虚拟DOM原理分析</title>
    <link href="http://blog.poetries.top/2021/03/29/virtual-dom-analysis/"/>
    <id>http://blog.poetries.top/2021/03/29/virtual-dom-analysis/</id>
    <published>2021-03-29T00:35:32.000Z</published>
    <updated>2021-05-11T03:46:23.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Virtual-DOM"><a href="#什么是-Virtual-DOM" class="headerlink" title="什么是 Virtual DOM"></a>什么是 Virtual DOM</h2><ol><li><code>Virtual DOM</code>(虚拟 DOM)，是由普通的 <code>JS</code> 对象来描述 <code>DOM</code> 对象，因为不是真实的 <code>DOM</code> 对象，所以叫 <code>Virtual DOM</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>) </span><br><span class="line"><span class="keyword">let</span> s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> element) &#123;</span><br><span class="line">  s += key + <span class="string">','</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果 align,title,lang,translate,dir,hidden,accessKey,draggable,spellcheck,aut ocapitalize,contentEditable,isContentEditable,inputMode,offsetParent,off setTop,offsetLeft,offsetWidth,offsetHeight,style,innerText,outerText,onc opy,oncut,onpaste,onabort,onblur,oncancel,oncanplay,oncanplaythrough,onc hange,onclick,onclose,oncontextmenu,oncuechange,ondblclick,ondrag,ondrag end,ondragenter,ondragleave,ondragover,ondragstart,ondrop,ondurationchan ge,onemptied,onended,onerror,onfocus,oninput,oninvalid,onkeydown,onkeypr ess,onkeyup,onload,onloadeddata,onloadedmetadata,onloadstart,onmousedown ,onmouseenter,onmouseleave,onmousemove,onmouseout,onmouseover,onmouseup, onmousewheel,onpause,onplay,onplaying,onprogress,onratechange,onreset,on resize,onscroll,onseeked,onseeking,onselect,onstalled,onsubmit,onsuspend ,ontimeupdate,ontoggle,onvolumechange,onwaiting,onwheel,onauxclick,ongot pointercapture,onlostpointercapture,onpointerdown,onpointermove,onpointe rup,onpointercancel,onpointerover,onpointerout,onpointerenter,onpointerl eave,onselectstart,onselectionchange,onanimationend,onanimationiteration ,onanimationstart,ontransitionend,dataset,nonce,autofocus,tabIndex,click ,focus,blur,enterKeyHint,onformdata,onpointerrawupdate,attachInternals,n amespaceURI,prefix,localName,tagName,id,className,classList,slot,part,at tributes,shadowRoot,assignedSlot,innerHTML,outerHTML,scrollTop,scrollLef t,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight ,attributeStyleMap,onbeforecopy,onbeforecut,onbeforepaste,onsearch,eleme ntTiming,previousElementSibling,nextElementSibling,children,firstElement Child,lastElementChild,childElementCount,onfullscreenchange,onfullscreen error,onwebkitfullscreenchange,onwebkitfullscreenerror,setPointerCapture ,releasePointerCapture,hasPointerCapture,hasAttributes,getAttributeNames ,getAttribute,getAttributeNS,setAttribute,setAttributeNS,removeAttribute ,removeAttributeNS,hasAttribute,hasAttributeNS,toggleAttribute,getAttrib uteNode,getAttributeNodeNS,setAttributeNode,setAttributeNodeNS,removeAtt ributeNode,closest,matches,webkitMatchesSelector,attachShadow,getElement sByTagName,getElementsByTagNameNS,getElementsByClassName,insertAdjacentE lement,insertAdjacentText,insertAdjacentHTML,requestPointerLock,getClien tRects,getBoundingClientRect,scrollIntoView,scroll,scrollTo,scrollBy,scr ollIntoViewIfNeeded,animate,computedStyleMap,before,after,replaceWith,re move,prepend,append,querySelector,querySelectorAll,requestFullscreen,web kitRequestFullScreen,webkitRequestFullscreen,createShadowRoot,getDestina tionInsertionPoints,ELEMENT_NODE,ATTRIBUTE_NODE,TEXT_NODE,CDATA_SECTION_ NODE,ENTITY_REFERENCE_NODE,ENTITY_NODE,PROCESSING_INSTRUCTION_NODE,COMME NT_NODE,DOCUMENT_NODE,DOCUMENT_TYPE_NODE,DOCUMENT_FRAGMENT_NODE,NOTATION _NODE,DOCUMENT_POSITION_DISCONNECTED,DOCUMENT_POSITION_PRECEDING,DOCUMEN T_POSITION_FOLLOWING,DOCUMENT_POSITION_CONTAINS,DOCUMENT_POSITION_CONTAI NED_BY,DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC,nodeType,nodeName,baseU RI,isConnected,ownerDocument,parentNode,parentElement,childNodes,firstCh ild,lastChild,previousSibling,nextSibling,nodeValue,textContent,hasChild Nodes,getRootNode,normalize,cloneNode,isEqualNode,isSameNode,compareDocu mentPosition,contains,lookupPrefix,lookupNamespaceURI,isDefaultNamespace ,insertBefore,appendChild,replaceChild,removeChild,addEventListener,remo veEventListener,dispatchEvent</span></span><br></pre></td></tr></table></figure><ol start="2"><li>可以使用 <code>Virtual DOM</code> 来描述真实 <code>DOM</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  sel: <span class="string">"div"</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  children: <span class="literal">undefined</span>,</span><br><span class="line">  text: <span class="string">"Hello Virtual DOM"</span>,</span><br><span class="line">  elm: <span class="literal">undefined</span>,</span><br><span class="line">  key: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么使用-Virtual-DOM"><a href="#为什么使用-Virtual-DOM" class="headerlink" title="为什么使用 Virtual DOM"></a>为什么使用 Virtual DOM</h2><ul><li>手动操作 <code>DOM</code> 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 <code>jQuery</code> 等库简化 <code>DOM</code> 操作，但是随着项目的复杂 DOM 操作复杂提升</li><li>为了简化 <code>DOM</code> 的复杂操作于是出现了各种 <code>MVVM</code> 框架，<code>MVVM</code> 框架解决了视图和状态的同步问题</li><li>为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是<code>Virtual DOM</code> 出现了</li><li><code>Virtual DOM</code> 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述<code>DOM</code>，<code>Virtual DOM</code> 内部将弄清楚如何有效(<code>diff</code>)的更新 <code>DOM</code></li><li>虚拟 <code>DOM</code> 可以维护程序的状态，跟踪上一次的状态</li><li>通过比较前后两次状态的差异更新真实 <code>DOM</code></li></ul><h2 id="虚拟-DOM-的作用"><a href="#虚拟-DOM-的作用" class="headerlink" title="虚拟 DOM 的作用"></a>虚拟 DOM 的作用</h2><ul><li>维护视图和状态的关系</li><li>复杂视图情况下提升渲染性能</li><li>除了渲染 <code>DOM</code> 以外，还可以实现 <code>SSR(Nuxt.js/Next.js)</code>、原生应用(<code>Weex/React Native</code>)、小程序(<code>mpvue/uni-app</code>)等</li></ul><p><img src="http://img-repo.poetries.top/images/20210328112610.png" alt></p><h2 id="Virtual-DOM-库"><a href="#Virtual-DOM-库" class="headerlink" title="Virtual DOM 库"></a>Virtual DOM 库</h2><ul><li><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">Snabbdom</a><ul><li><code>Vue 2.x</code> 内部使用的 <code>Virtual DOM</code> 就是改造的 <code>Snabbdom</code></li><li>通过模块可扩展</li><li>源码使用 <code>TypeScript</code> 开发</li><li>最快的 <code>Virtual DOM</code> 之一</li></ul></li><li><a href="https://github.com/Matt-Esch/virtual-dom" target="_blank" rel="noopener">virtual-dom</a></li></ul><h2 id="Snabbdom-基本使用"><a href="#Snabbdom-基本使用" class="headerlink" title="Snabbdom 基本使用"></a>Snabbdom 基本使用</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目目录</span></span><br><span class="line">md snabbdom-demo</span><br><span class="line"><span class="comment"># 进入项目目录</span></span><br><span class="line"><span class="built_in">cd</span> snabbdom-demo</span><br><span class="line"><span class="comment"># 创建 package.json yarn init -y</span></span><br><span class="line"><span class="comment"># 本地安装 parcel</span></span><br><span class="line">yarn add parcel-bundler</span><br></pre></td></tr></table></figure><p>配置 <code>package.json</code> 的 <code>scripts</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;dev&quot;: &quot;parcel index.html --open&quot;, &quot;build&quot;: &quot;parcel build index.html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建目录结构</p><p><img src="http://img-repo.poetries.top/images/20210328123653.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add snabbdom</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import&#123;init,h,thunk&#125;from&apos;snabbdom&apos;</span><br></pre></td></tr></table></figure><blockquote><p><code>snabbdom</code> 的核心仅提供最基本的功能，只导出了三个函数 <code>init()</code>、<code>h()</code>、<code>thunk()</code></p></blockquote><ul><li><code>init()</code> 是一个高阶函数，返回 <code>patch()</code></li><li><code>h()</code> 返回虚拟节点 <code>VNode</code>，这个函数我们在使用 <code>Vue.js</code> 的时候见过</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) </span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>thunk()</code> 是一种优化策略，可以在处理不可变数据时使用</li></ul><blockquote><p>注意:导入时候不能使用 <code>import snabbdom from &#39;snabbdom&#39;</code>。原因:<code>node_modules/src/snabbdom.ts</code> 末尾导出使用的语法是 <code>export</code> 导出 <code>API</code>，没有使用 <code>export default</code> 导出默认输出</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210328124133.png" alt></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>例子1</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, init &#125; <span class="keyword">from</span> <span class="string">'snabbdom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. hello world</span></span><br><span class="line"><span class="comment">// 参数：数组，模块</span></span><br><span class="line"><span class="comment">// 返回值：patch函数，作用对比两个vnode的差异更新到真实DOM</span></span><br><span class="line"><span class="keyword">let</span> patch = init([])</span><br><span class="line"><span class="comment">// 第一个参数：标签+选择器</span></span><br><span class="line"><span class="comment">// 第二个参数：如果是字符串的话就是标签中的内容</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">'div#container.cls'</span>, &#123; </span><br><span class="line">  hook: &#123;</span><br><span class="line">    init (vnode) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(vnode.elm)</span><br><span class="line">    &#125;,</span><br><span class="line">    create (emptyVnode, vnode) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(vnode.elm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="string">'Hello World'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line"><span class="comment">// 第一个参数：可以是DOM元素，内部会把DOM元素转换成VNode</span></span><br><span class="line"><span class="comment">// 第二个参数：VNode</span></span><br><span class="line"><span class="comment">// 返回值：VNde</span></span><br><span class="line"><span class="keyword">let</span> oldVnode = patch(app, vnode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设的时刻</span></span><br><span class="line">vnode = h(<span class="string">'div'</span>, <span class="string">'Hello Snabbdom'</span>)</span><br><span class="line"></span><br><span class="line">patch(oldVnode, vnode)</span><br></pre></td></tr></table></figure><p><strong>例子2</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. div中放置子元素 h1,p</span></span><br><span class="line"><span class="keyword">import</span> &#123; h, init &#125; <span class="keyword">from</span> <span class="string">'snabbdom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> patch = init([])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">'div#container'</span>, [</span><br><span class="line">  h(<span class="string">'h1'</span>, <span class="string">'Hello Snabbdom'</span>),</span><br><span class="line">  h(<span class="string">'p'</span>, <span class="string">'这是一个p标签'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oldVnode = patch(app, vnode)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vnode = h(<span class="string">'div#container'</span>, [</span><br><span class="line">    h(<span class="string">'h1'</span>, <span class="string">'Hello World'</span>),</span><br><span class="line">    h(<span class="string">'p'</span>, <span class="string">'Hello P'</span>)</span><br><span class="line">  ])</span><br><span class="line">  patch(oldVnode, vnode)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空页面元素 -- 错误</span></span><br><span class="line">  <span class="comment">// patch(oldVnode, null)</span></span><br><span class="line">  patch(oldVnode, h(<span class="string">'!'</span>))</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p><strong>例子3 debug-patchVnode</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, init &#125; <span class="keyword">from</span> <span class="string">'snabbdom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> patch = init([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">'div'</span>, <span class="string">'Hello World'</span>)</span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line"><span class="keyword">let</span> oldVnode = patch(app, vnode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// patchVnode 的执行过程</span></span><br><span class="line">vnode = h(<span class="string">'div'</span>, <span class="string">'Hello Snabbdom'</span>)</span><br><span class="line">patch(oldVnode, vnode)</span><br></pre></td></tr></table></figure><p><strong>例子4 debug-updateChildren</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, init &#125; <span class="keyword">from</span> <span class="string">'snabbdom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> patch = init([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">'ul'</span>, [</span><br><span class="line">  h(<span class="string">'li'</span>, <span class="string">'首页'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, <span class="string">'视频'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, <span class="string">'微博'</span>)</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line"><span class="keyword">let</span> oldVnode = patch(app, vnode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// updateChildren 的执行过程</span></span><br><span class="line">vnode = h(<span class="string">'ul'</span>, [</span><br><span class="line">  h(<span class="string">'li'</span>, <span class="string">'首页'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, <span class="string">'微博'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, <span class="string">'视频'</span>)</span><br><span class="line">])</span><br><span class="line">patch(oldVnode, vnode)</span><br></pre></td></tr></table></figure><p><strong>例子5 debug-updateChildren-key</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, init &#125; <span class="keyword">from</span> <span class="string">'snabbdom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> patch = init([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">'ul'</span>, [</span><br><span class="line">  h(<span class="string">'li'</span>, &#123; <span class="attr">key</span>: <span class="string">'a'</span> &#125;, <span class="string">'首页'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123; <span class="attr">key</span>: <span class="string">'b'</span> &#125;, <span class="string">'视频'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123; <span class="attr">key</span>: <span class="string">'c'</span> &#125;, <span class="string">'微博'</span>)</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line"><span class="keyword">let</span> oldVnode = patch(app, vnode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// updateChildren 的执行过程</span></span><br><span class="line">vnode = h(<span class="string">'ul'</span>, [</span><br><span class="line">  h(<span class="string">'li'</span>, &#123; <span class="attr">key</span>: <span class="string">'a'</span> &#125;, <span class="string">'首页'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123; <span class="attr">key</span>: <span class="string">'c'</span> &#125;, <span class="string">'微博'</span>),</span><br><span class="line">  h(<span class="string">'li'</span>, &#123; <span class="attr">key</span>: <span class="string">'b'</span> &#125;, <span class="string">'视频'</span>)</span><br><span class="line">])</span><br><span class="line">patch(oldVnode, vnode)</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><blockquote><p><code>Snabbdom</code> 的核心库并不能处理元素的<code>属性/样式/事件</code>等，如果需要处理的话，可以使用模块</p></blockquote><p><strong>常用模块</strong></p><p>官方提供了 6 个模块</p><ul><li><code>attributes</code><ul><li>设置 <code>DOM</code> 元素的属性，使用 <code>setAttribute ()</code></li><li>处理布尔类型的属性</li></ul></li><li><code>props</code><ul><li>和 <code>attributes</code> 模块相似，设置 <code>DOM</code> 元素的属性 <code>element[attr] = value</code></li><li>不处理布尔类型的属性</li></ul></li><li><code>class</code><ul><li>切换类样式</li><li>注意:给元素设置类样式是通过 <code>sel</code> 选择器 </li></ul></li><li><code>dataset</code><ul><li>设置 <code>data-*</code> 的自定义属性 <code>eventlisteners</code></li><li>注册和移除事件</li></ul></li><li><code>style</code><ul><li>设置行内样式，支持动画</li><li><code>delayed/remove/destroy</code></li></ul></li></ul><p><strong>模块使用</strong></p><blockquote><p>模块使用步骤:</p></blockquote><ul><li>导入需要的模块</li><li><code>init()</code> 中注册模块</li><li>使用 <code>h()</code> 函数创建 <code>VNode</code> 的时候，可以把第二个参数设置为对象，其他参数往后移</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; init, h &#125; <span class="keyword">from</span> <span class="string">'snabbdom'</span></span><br><span class="line"><span class="comment">// 1. 导入模块</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'snabbdom/modules/style'</span></span><br><span class="line"><span class="keyword">import</span> eventlisteners <span class="keyword">from</span> <span class="string">'snabbdom/modules/eventlisteners'</span></span><br><span class="line"><span class="comment">// 2. 注册模块</span></span><br><span class="line"><span class="keyword">let</span> patch = init([</span><br><span class="line">  style,</span><br><span class="line">  eventlisteners</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 3. 使用 h() 函数的第二个参数传入模块需要的数据（对象）</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">'div'</span>, &#123;</span><br><span class="line">  style: &#123;</span><br><span class="line">    backgroundColor: <span class="string">'red'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  on: &#123;</span><br><span class="line">    click: eventHandler</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [</span><br><span class="line">  h(<span class="string">'h1'</span>, <span class="string">'Hello Snabbdom'</span>),</span><br><span class="line">  h(<span class="string">'p'</span>, <span class="string">'这是p标签'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'点击我了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oldVnode = patch(app, vnode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vnode = h(<span class="string">'div'</span>, <span class="string">'hello'</span>)</span><br><span class="line">patch(oldVnode, vnode)</span><br></pre></td></tr></table></figure><h2 id="Snabbdom-源码解析"><a href="#Snabbdom-源码解析" class="headerlink" title="Snabbdom 源码解析"></a>Snabbdom 源码解析</h2><h3 id="Snabbdom-的核心"><a href="#Snabbdom-的核心" class="headerlink" title="Snabbdom 的核心"></a>Snabbdom 的核心</h3><ul><li>使用 <code>h()</code> 函数创建 JavaScript 对象(<code>VNode</code>)描述真实 DOM </li><li><code>init()</code> 设置模块，创建 <code>patch()</code></li><li><code>patch()</code> 比较新旧两个 <code>VNode</code></li><li>把变化的内容更新到真实 <code>DOM</code> 树上</li></ul><p><strong>Snabbdom 源码</strong></p><blockquote><p>源码地址: <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">https://github.com/snabbdom/snabbdom</a></p></blockquote><p>src 目录结构</p><p><img src="http://img-repo.poetries.top/images/20210328125857.png" alt></p><h3 id="h-函数"><a href="#h-函数" class="headerlink" title="h 函数"></a>h 函数</h3><ul><li><code>h()</code> 函数介绍: 在使用 <code>Vue</code> 的时候见过 <code>h()</code> 函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) </span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>h()</code> 函数最早见于 <code>hyperscript</code>，使用 JavaScript 创建超文本</li><li>Snabbdom 中的 <code>h()</code> 函数不是用来创建超文本，而是创建 <code>VNode</code></li></ul><p><strong>函数重载</strong></p><ul><li>概念<ul><li>参数个数或类型不同的函数</li><li><code>JavaScript</code> 中没有重载的概念</li><li><code>TypeScript</code> 中有重载，不过重载的实现还是通过代码调整参数</li></ul></li><li>重载的示意</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b + c) </span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><blockquote><p>源码位置:<code>src/h.ts</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h函数的重载</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params">sel: string</span>): <span class="title">VNode</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">h</span> (<span class="params">sel: string, data: VNodeData | null</span>): <span class="title">VNode</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">h</span> (<span class="params">sel: string, children: VNodeChildren</span>): <span class="title">VNode</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">h</span> (<span class="params">sel: string, data: VNodeData | null, children: VNodeChildren</span>): <span class="title">VNode</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">h</span> (<span class="params">sel: any, b?: any, c?: any</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data: VNodeData = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> children: any</span><br><span class="line">  <span class="keyword">let</span> text: any</span><br><span class="line">  <span class="keyword">let</span> i: number</span><br><span class="line">  <span class="comment">// 处理参数，实现重载的机制</span></span><br><span class="line">  <span class="keyword">if</span> (c !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理三个参数的情况</span></span><br><span class="line">    <span class="comment">// sel、data、children/text</span></span><br><span class="line">    <span class="keyword">if</span> (b !== <span class="literal">null</span>) &#123;</span><br><span class="line">      data = b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is.array(c)) &#123;</span><br><span class="line">      children = c</span><br><span class="line">      <span class="comment">// 如果 c 是字符串或者数字</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(c)) &#123;</span><br><span class="line">      text = c</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &amp;&amp; c.sel) &#123;</span><br><span class="line">      children = [c]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b !== <span class="literal">undefined</span> &amp;&amp; b !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理两个参数的情况</span></span><br><span class="line">    <span class="keyword">if</span> (is.array(b)) &#123;</span><br><span class="line">      children = b</span><br><span class="line">      <span class="comment">// 如果 b 是字符串或者数字</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(b)) &#123;</span><br><span class="line">      text = b</span><br><span class="line">      <span class="comment">// 如果 b 是 VNode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &amp;&amp; b.sel) &#123;</span><br><span class="line">      children = [b]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; data = b &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (children !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 children 中的原始值(string/number)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">      <span class="comment">// 如果 child 是 string/number，创建文本节点</span></span><br><span class="line">      <span class="keyword">if</span> (is.primitive(children[i])) children[i] = vnode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, children[i], <span class="literal">undefined</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    sel[<span class="number">0</span>] === <span class="string">'s'</span> &amp;&amp; sel[<span class="number">1</span>] === <span class="string">'v'</span> &amp;&amp; sel[<span class="number">2</span>] === <span class="string">'g'</span> &amp;&amp;</span><br><span class="line">    (sel.length === <span class="number">3</span> || sel[<span class="number">3</span>] === <span class="string">'.'</span> || sel[<span class="number">3</span>] === <span class="string">'#'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果是 svg，添加命名空间</span></span><br><span class="line">    addNS(data, children, sel)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回 VNode</span></span><br><span class="line">  <span class="keyword">return</span> vnode(sel, data, children, text, <span class="literal">undefined</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> h;</span><br></pre></td></tr></table></figure><h3 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h3><blockquote><p>一个 <code>VNode</code> 就是一个虚拟节点用来描述一个 <code>DOM</code> 元素，如果这个 <code>VNode</code> 有 <code>children</code> 就是 <code>Virtual DOM</code></p></blockquote><p>源码位置: <code>src/vnode.ts</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface VNodeData &#123;</span><br><span class="line">  props?: Props</span><br><span class="line">  attrs?: Attrs</span><br><span class="line">  class?: Classes</span><br><span class="line">  style?: VNodeStyle</span><br><span class="line">  dataset?: Dataset</span><br><span class="line">  on?: On</span><br><span class="line">  hero?: Hero</span><br><span class="line">  attachData?: AttachData</span><br><span class="line">  hook?: Hooks</span><br><span class="line">  key?: Key</span><br><span class="line">  ns?: string <span class="comment">// for SVGs</span></span><br><span class="line">  fn?: <span class="function"><span class="params">()</span> =&gt;</span> VNode <span class="comment">// for thunks</span></span><br><span class="line">  args?: any[] <span class="comment">// for thunks</span></span><br><span class="line">  is?: string <span class="comment">// for custom elements v1</span></span><br><span class="line">  [key: string]: any <span class="comment">// for any other 3rd party module</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface VNode &#123;</span><br><span class="line">  <span class="comment">// 选择器</span></span><br><span class="line">  sel: string | <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 节点数据:属性/样式/事件等</span></span><br><span class="line">  data: VNodeData | <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 子节点，和 text 只能互斥</span></span><br><span class="line">  children: <span class="built_in">Array</span>&lt;VNode | string&gt; | <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 记录 vnode 对应的真实 DOM</span></span><br><span class="line">  elm: Node | <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 节点中的内容，和 children 只能互斥</span></span><br><span class="line">  text: string | <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 优化用</span></span><br><span class="line">  key: Key | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span> (<span class="params">sel: string | undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any | undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: Array&lt;VNode | string&gt; | undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">  text: string | undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">  elm: Element | Text | undefined</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = data === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : data.key</span><br><span class="line">  <span class="keyword">return</span> &#123; sel, data, children, text, elm, key &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="snabbdom"><a href="#snabbdom" class="headerlink" title="snabbdom"></a>snabbdom</h3><ul><li><code>patch(oldVnode, newVnode)</code></li><li>打补丁，把新节点中变化的内容渲染到真实 <code>DOM</code>，最后返回新节点作为下一次处理的旧节点</li><li>对比新旧 <code>VNode</code> 是否相同节点(节点的 <code>key</code> 和 <code>sel</code> 相同)</li><li>如果不是相同节点，删除之前的内容，重新渲染</li><li>如果是相同节点，再判断新的 <code>VNode</code> 是否有 <code>text</code>，如果有并且和 <code>oldVnode</code> 的 <code>text</code> 不同，直接更 新文本内容</li><li>如果新的 <code>VNode</code> 有 <code>children</code>，判断子节点是否有变化，判断子节点的过程使用的就是 <code>diff</code> 算法</li><li><code>diff</code> 过程只进行同层级比较</li></ul><p><img src="http://img-repo.poetries.top/images/20210329091820.png" alt></p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><ul><li>功能: <code>init(modules, domApi)</code>，返回 <code>patch()</code>函数(高阶函数)</li><li>为什么要使用高阶函数?<ul><li>因为 <code>patch()</code> 函数再外部会调用多次，每次调用依赖一些参数，比如: <code>modules/domApi/cbs</code></li><li>通过高阶函数让 <code>init()</code> 内部形成闭包，返回的 <code>patch()</code> 可以访问到 <code>modules/domApi/cbs</code>，而 不需要重新创建</li></ul></li><li><code>init()</code> 在返回 <code>patch()</code> 之前，首先收集了所有模块中的钩子函数存储到 <code>cbs</code> 对象中</li></ul><blockquote><p>源码位置:<code>src/init.ts</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params">modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number</span><br><span class="line">  <span class="keyword">let</span> j: number</span><br><span class="line">  <span class="keyword">const</span> cbs: ModuleHooks = &#123;</span><br><span class="line">    create: [],</span><br><span class="line">    update: [],</span><br><span class="line">    remove: [],</span><br><span class="line">    destroy: [],</span><br><span class="line">    pre: [],</span><br><span class="line">    post: []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> api: DOMAPI = domApi !== <span class="literal">undefined</span> ? domApi : htmlDomApi</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">    cbs[hooks[i]] = []</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</span><br><span class="line">      <span class="keyword">const</span> hook = modules[j][hooks[i]]</span><br><span class="line">      <span class="keyword">if</span> (hook !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        (cbs[hooks[i]] <span class="keyword">as</span> any[]).push(hook)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i: number, <span class="attr">elm</span>: Node, <span class="attr">parent</span>: Node</span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue: VNodeQueue = []</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.pre.length; ++i) cbs.pre[i]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isVnode(oldVnode)) &#123;</span><br><span class="line">      oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">      patchVnode(oldVnode, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elm = oldVnode.elm!</span><br><span class="line">      parent = api.parentNode(elm) <span class="keyword">as</span> Node</span><br><span class="line"></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))</span><br><span class="line">        removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insertedVnodeQueue.length; ++i) &#123;</span><br><span class="line">      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.post.length; ++i) cbs.post[i]()</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><ul><li>功能:<ul><li>传入新旧 <code>VNode</code>，对比差异，把差异渲染到 <code>DOM</code></li><li>返回新的 <code>VNode</code>，作为下一次 <code>patch()</code> 的 <code>oldVnode</code></li></ul></li><li>执行过程:<ul><li>首先执行模块中的钩子函数 <code>pre</code></li><li>如果 <code>oldVnode</code> 和 <code>vnode</code> 相同(<code>key</code> 和 <code>sel</code> 相同)<ul><li>调用 <code>patchVnode()</code>，找节点的差异并更新 <code>DOM</code></li></ul></li><li>如果 <code>oldVnode</code> 是 <code>DOM</code> 元素<ul><li>把 <code>DOM</code> 元素转换成 <code>oldVnode</code></li><li>调用 <code>createElm()</code> 把 <code>vnode</code> 转换为真实 <code>DOM</code>，记录到 <code>vnode.elm</code></li><li>把刚创建的 <code>DOM</code> 元素插入到 <code>parent</code> 中</li><li>移除老节点</li><li>触发用户设置的 <code>create</code> 钩子函数</li></ul></li></ul></li></ul><p>源码位置:<code>src/snabbdom.ts</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number, <span class="attr">elm</span>: Node, <span class="attr">parent</span>: Node</span><br><span class="line">  <span class="comment">// 保存新插入节点的队列，为了触发钩子函数</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue: VNodeQueue = []</span><br><span class="line">  <span class="comment">// 执行模块的 pre 钩子函数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.pre.length; ++i) cbs.pre[i]()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 oldVnode 不是 VNode，创建 VNode 并设置 elm</span></span><br><span class="line">  <span class="keyword">if</span> (!isVnode(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// 把 DOM 元素转换成空的 VNode</span></span><br><span class="line">    oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果新旧节点是相同节点(key 和 sel 相同)</span></span><br><span class="line">  <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">    <span class="comment">// 找节点的差异并更新 DOM</span></span><br><span class="line">    patchVnode(oldVnode, vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果新旧节点不同，vnode 创建对应的 DOM</span></span><br><span class="line">    <span class="comment">// 获取当前的 DOM 元素</span></span><br><span class="line">    elm = oldVnode.elm!</span><br><span class="line">    parent = api.parentNode(elm) <span class="keyword">as</span> Node</span><br><span class="line">    <span class="comment">// 触发 init/create 钩子函数,创建 DOM</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果父节点不为空，把 vnode 对应的 DOM 插入到文档中</span></span><br><span class="line">      api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))</span><br><span class="line">      <span class="comment">// 移除老节点</span></span><br><span class="line">      removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行用户设置的 insert 钩子函数 </span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insertedVnodeQueue.length; ++i) &#123;</span><br><span class="line">    insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行模块的 post 钩子函数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.post.length; ++i) cbs.post[i]()</span><br><span class="line">  <span class="comment">// 返回 vnode</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a>createElm</h3><ul><li><p>功能:</p><ul><li><code>createElm(vnode, insertedVnodeQueue)</code>，返回创建的 <code>DOM</code> 元素</li><li>创建 <code>vnode</code> 对应的 <code>DOM</code> 元素</li></ul></li><li><p>执行过程:</p><ul><li>首先触发用户设置的 <code>init</code> 钩子函数</li><li>如果选择器是<code>!</code>，创建评论节点</li><li>如果选择器为空，创建文本节点</li><li>如果选择器不为空<ul><li>解析选择器，设置标签的 <code>id</code> 和 <code>class</code> 属性</li><li>执行模块的 <code>create</code> 钩子函数</li><li>如果 <code>vnode</code> 有 <code>children</code>，创建子 <code>vnode</code> 对应的 <code>DOM</code>，追加到 <code>DOM</code> 树</li><li>如果 <code>vnode</code> 的 <code>text</code> 值是 <code>string/number</code>，创建文本节点并追击到 <code>DOM</code> 树</li><li>执行用户设置的 <code>create</code> 钩子函数</li><li>如果有用户设置的 <code>insert</code> 钩子函数，把 <code>vnode</code> 添加到队列中</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params">vnode: VNode, insertedVnodeQueue: VNodeQueue</span>): <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: any</span><br><span class="line">  <span class="keyword">let</span> data = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (data !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行用户设置的 init 钩子函数</span></span><br><span class="line">    <span class="keyword">const</span> init = data.hook?.init</span><br><span class="line">    <span class="keyword">if</span> (isDef(init)) &#123;</span><br><span class="line">      init(vnode)</span><br><span class="line">      data = vnode.data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> sel = vnode.sel</span><br><span class="line">  <span class="keyword">if</span> (sel === <span class="string">'!'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果选择器是!，创建评论节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      vnode.text = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    vnode.elm = api.createComment(vnode.text!)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// Parse selector</span></span><br><span class="line">    <span class="comment">// 如果选择器不为空</span></span><br><span class="line">    <span class="comment">// 解析选择器</span></span><br><span class="line">    <span class="comment">// Parse selector</span></span><br><span class="line">    <span class="keyword">const</span> hashIdx = sel.indexOf(<span class="string">'#'</span>)</span><br><span class="line">    <span class="keyword">const</span> dotIdx = sel.indexOf(<span class="string">'.'</span>, hashIdx)</span><br><span class="line">    <span class="keyword">const</span> hash = hashIdx &gt; <span class="number">0</span> ? hashIdx : sel.length</span><br><span class="line">    <span class="keyword">const</span> dot = dotIdx &gt; <span class="number">0</span> ? dotIdx : sel.length</span><br><span class="line">    <span class="keyword">const</span> tag = hashIdx !== <span class="number">-1</span> || dotIdx !== <span class="number">-1</span> ? sel.slice(<span class="number">0</span>, <span class="built_in">Math</span>.min(hash, dot)) : sel</span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = isDef(data) &amp;&amp; isDef(i = data.ns)</span><br><span class="line">      ? api.createElementNS(i, tag, data)</span><br><span class="line">      : api.createElement(tag, data)</span><br><span class="line">    <span class="keyword">if</span> (hash &lt; dot) elm.setAttribute(<span class="string">'id'</span>, sel.slice(hash + <span class="number">1</span>, dot))</span><br><span class="line">    <span class="keyword">if</span> (dotIdx &gt; <span class="number">0</span>) elm.setAttribute(<span class="string">'class'</span>, sel.slice(dot + <span class="number">1</span>).replace(<span class="regexp">/\./g</span>, <span class="string">' '</span>))</span><br><span class="line">    <span class="comment">// 执行模块的 create 钩子函数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode)</span><br><span class="line">    <span class="comment">// 如果 vnode 中有子节点，创建子 vnode 对应的 DOM 元素并追加到 DOM 树上</span></span><br><span class="line">    <span class="keyword">if</span> (is.array(children)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> ch = children[i]</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="literal">null</span>) &#123;</span><br><span class="line">          api.appendChild(elm, createElm(ch <span class="keyword">as</span> VNode, insertedVnodeQueue))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(vnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 如果 vnode 的 text 值是 string/number，创建文本节点并追加到 DOM 树</span></span><br><span class="line">      api.appendChild(elm, api.createTextNode(vnode.text))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hook = vnode.data!.hook</span><br><span class="line">    <span class="keyword">if</span> (isDef(hook)) &#123;</span><br><span class="line">      <span class="comment">// 执行用户传入的钩子 create</span></span><br><span class="line">      hook.create?.(emptyNode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (hook.insert) &#123;</span><br><span class="line">        <span class="comment">// 把 vnode 添加到队列中，为后续执行 insert 钩子做准备</span></span><br><span class="line">        insertedVnodeQueue.push(vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果选择器为空，创建文本节点</span></span><br><span class="line">    vnode.elm = api.createTextNode(vnode.text!)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新创建的 DOM</span></span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><ul><li>功能:<ul><li><code>patchVnode(oldVnode, vnode, insertedVnodeQueue)</code></li><li>对比 <code>oldVnode</code> 和 <code>vnode</code> 的差异，把差异渲染到 <code>DOM</code></li></ul></li><li>执行过程:<ul><li>首先执行用户设置的 <code>prepatch</code> 钩子函数</li><li>执行 <code>create</code> 钩子函数<ul><li>首先执行模块的 <code>create</code>钩子函数</li><li>然后执行用户设置的 <code>create</code> 钩子函数</li></ul></li><li>如果 <code>vnode.text</code> 未定义<ul><li>如果 <code>oldVnode.children</code> 和 <code>vnode.children</code> 都有值<ul><li>调用 <code>updateChildren()</code></li><li>使用 <code>diff</code> 算法对比子节点，更新子节点</li></ul></li><li>如果 <code>vnode.children</code> 有值， <code>oldVnode.children</code> 无值<ul><li>清空 <code>DOM</code> 元素</li><li>调用 <code>addVnodes()</code> ，批量添加子节点</li></ul></li><li>如果 <code>oldVnode.children</code> 有值， <code>vnode.children</code> 无值<ul><li>调用 <code>removeVnodes()</code> ，批量移除子节点</li></ul></li><li>如果 <code>oldVnode.text</code> 有值<ul><li>清空 <code>DOM</code> 元素的内容</li></ul></li></ul></li><li>如果设置了 <code>vnode.text</code> 并且和和 <code>oldVnode.text</code> 不等<ul><li>如果老节点有子节点，全部移除</li><li>设置 <code>DOM</code> 元素的 <code>textContent</code> 为 <code>vnode.text</code></li></ul></li><li>最后执行用户设置的 <code>postpatch</code> 钩子函数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = vnode.data?.hook</span><br><span class="line">  <span class="comment">// 首先执行用户设置的 prepatch 钩子函数</span></span><br><span class="line">  hook?.prepatch?.(oldVnode, vnode)</span><br><span class="line">  <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm!</span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children <span class="keyword">as</span> VNode[]</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children <span class="keyword">as</span> VNode[]</span><br><span class="line">  <span class="comment">// 如果新老 vnode 相同返回</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.data !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行模块的 update 钩子函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">    <span class="comment">// 执行用户设置的 update 钩子函数</span></span><br><span class="line">    vnode.data.hook?.update?.(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 vnode.text 未定义</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 如果新老节点都有 children</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 使用 diff 算法对比子节点，更新子节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 如果新节点有 children，老节点没有 children</span></span><br><span class="line">      <span class="comment">// 如果老节点有text，清空dom 元素的内容</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) api.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      <span class="comment">// 批量添加子节点</span></span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 如果老节点有children，新节点没有children</span></span><br><span class="line">      <span class="comment">// 批量移除子节点</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 如果老节点有 text，清空 DOM 元素</span></span><br><span class="line">      api.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 如果没有设置 vnode.text</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 如果老节点有 children，移除</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 DOM 元素的 textContent 为 vnode.text</span></span><br><span class="line">    api.setTextContent(elm, vnode.text!)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后执行用户设置的 postpatch 钩子函数</span></span><br><span class="line">  hook?.postpatch?.(oldVnode, vnode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><ul><li>功能:<ul><li><code>diff</code> 算法的核心，对比新旧节点的 <code>children</code>，更新 <code>DOM</code></li></ul></li><li>执行过程: <ul><li>要对比两棵树的差异，我们可以取第一棵树的每一个节点依次和第二课树的每一个节点比 较，但是这样的时间复杂度为 <code>O(n^3)</code></li><li>在 <code>DOM</code> 操作的时候我们很少很少会把一个父节点移动/更新到某一个子节点</li><li>因此只需要找同级别的子节点依次比较，然后再找下一级别的节点比较，这样算法的时间复 杂度为 <code>O(n)</code></li></ul></li></ul><p><img src="http://img-repo.poetries.top/images/20210329092027.png" alt></p><ul><li>在进行同级别节点比较的时候，首先会对新老节点数组的开始和结尾节点设置标记索引，遍 历的过程中移动索引</li><li>在对开始和结束节点比较的时候，总共有四种情况<ul><li><code>oldStartVnode / newStartVnode</code> (旧开始节点 / 新开始节点)</li><li><code>oldEndVnode / newEndVnode</code> (旧结束节点 / 新结束节点)</li><li><code>oldStartVnode / oldEndVnode</code> (旧开始节点 / 新结束节点)</li><li><code>oldEndVnode / newStartVnode</code> (旧结束节点 / 新开始节点)</li></ul></li></ul><p><img src="http://img-repo.poetries.top/images/20210329092301.png" alt></p><ul><li>开始节点和结束节点比较，这两种情况类似<ul><li><code>oldStartVnode / newStartVnode</code> (旧开始节点 / 新开始节点)</li><li><code>oldEndVnode / newEndVnode</code> (旧结束节点 / 新结束节点)</li></ul></li><li>如果 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 是 <code>sameVnode</code> (<code>key</code> 和 <code>sel</code> 相同)<ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li><li>把旧开始和新开始索引往后移动 <code>oldStartIdx++ / oldEndIdx++</code></li></ul></li></ul><p><img src="http://img-repo.poetries.top/images/20210329092430.png" alt></p><ul><li><code>oldStartVnode / newEndVnode</code> (旧开始节点 / 新结束节点) 相同<ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li><li>把 <code>oldStartVnode</code> 对应的 <code>DOM</code> 元素，移动到右边 <ul><li>更新索引</li></ul></li></ul></li></ul><p><img src="http://img-repo.poetries.top/images/20210329092820.png" alt></p><ul><li><code>oldEndVnode / newStartVnode</code> (旧结束节点 / 新开始节点) 相同<ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li><li>把 <code>oldEndVnode</code> 对应的 <code>DOM</code> 元素，移动到左边</li><li>更新索引</li></ul></li></ul><p><img src="http://img-repo.poetries.top/images/20210329093025.png" alt></p><ul><li>如果不是以上四种情况<ul><li>遍历新节点，使用 <code>newStartNode</code> 的 <code>key</code> 在老节点数组中找相同节点</li><li>如果没有找到，说明 <code>newStartNode</code> 是新节点<ul><li>创建新节点对应的 DOM 元素，插入到 DOM 树中</li></ul></li><li>如果找到了<ul><li>判断新节点和找到的老节点的 <code>sel</code> 选择器是否相同</li><li>如果不相同，说明节点被修改了<ul><li>重新创建对应的 <code>DOM</code> 元素，插入到 DOM 树中</li></ul></li><li>如果相同，把 <code>elmToMove</code> 对应的 DOM 元素，移动到左边</li></ul></li></ul></li></ul><p><img src="http://img-repo.poetries.top/images/20210329093137.png" alt></p><ul><li>循环结束<ul><li>当老节点的所有子节点先遍历完 (<code>oldStartIdx &gt; oldEndIdx</code>)，循环结束</li><li>新节点的所有子节点先遍历完 (<code>newStartIdx &gt; newEndIdx</code>)，循环结束</li></ul></li><li>如果老节点的数组先遍历完(<code>oldStartIdx &gt; oldEndIdx</code>)，说明新节点有剩余，把剩余节点批量插入到右边</li></ul><p><img src="http://img-repo.poetries.top/images/20210329093302.png" alt></p><ul><li>如果新节点的数组先遍历完(<code>newStartIdx &gt; newEndIdx</code>)，说明老节点有剩余，把剩余节点批 量删除</li></ul><p><img src="http://img-repo.poetries.top/images/20210329093414.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-Virtual-DOM&quot;&gt;&lt;a href=&quot;#什么是-Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;什么是 Virtual DOM&quot;&gt;&lt;/a&gt;什么是 Virtual DOM&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Virtua
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Vue" scheme="http://blog.poetries.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue响应式原理模拟</title>
    <link href="http://blog.poetries.top/2021/03/28/vue-reative-summary/"/>
    <id>http://blog.poetries.top/2021/03/28/vue-reative-summary/</id>
    <published>2021-03-28T10:40:12.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><ul><li>数据响应式、双向绑定、数据驱动</li><li>数据响应式<ul><li>数据模型仅仅是普通的 <code>JavaScript</code> 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 <code>DOM</code> 操作提高开发效率</li></ul></li><li>双向绑定<ul><li>数据改变，视图改变;视图改变，数据也随之改变</li><li>我们可以使用 <code>v-model</code> 在表单元素上创建双向数据绑定</li></ul></li><li>数据驱动是 <code>Vue</code> 最独特的特性之一<ul><li>开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图</li></ul></li></ul><h2 id="数据响应式的核心原理"><a href="#数据响应式的核心原理" class="headerlink" title="数据响应式的核心原理"></a>数据响应式的核心原理</h2><h3 id="Vue-2-x"><a href="#Vue-2-x" class="headerlink" title="Vue 2.x"></a>Vue 2.x</h3><ul><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue 2.x深入响应式原理</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">MDN - Object.defineProperty</a></li><li>浏览器兼容 IE8 以上(不兼容 IE8)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 的实例 </span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line"><span class="comment">// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(vm, <span class="string">'msg'</span>, &#123;</span><br><span class="line">  <span class="comment">// 可枚举(可遍历)</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) </span></span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 当获取值的时候执行 </span></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get: '</span>, data.msg)</span><br><span class="line">    <span class="keyword">return</span> data.msg </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置值的时候执行 </span></span><br><span class="line">  <span class="keyword">set</span> (newValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set: '</span>, newValue) </span><br><span class="line">    <span class="keyword">if</span> (newValue === data.msg) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    data.msg = newValue</span><br><span class="line">    <span class="comment">// 数据更改，更新 DOM 的值 </span></span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>).textContent = data.msg</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">vm.msg = <span class="string">'Hello World'</span> </span><br><span class="line"><span class="built_in">console</span>.log(vm.msg)</span><br></pre></td></tr></table></figure><blockquote><p>如果有一个对象中多个属性需要转换 <code>getter/setter</code> 如何处理?</p></blockquote><h3 id="Vue-3-x"><a href="#Vue-3-x" class="headerlink" title="Vue 3.x"></a>Vue 3.x</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">MDN - Proxy</a></li><li>直接监听对象，而非属性</li><li><code>ES 6</code>中新增，<code>IE</code> 不支持，性能由浏览器优化</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  msg: <span class="string">'hello'</span>,</span><br><span class="line">  count: <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 实例</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 当访问 vm 的成员会执行</span></span><br><span class="line">  <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get, key: '</span>, key, target[key])</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置 vm 的成员会执行</span></span><br><span class="line">  <span class="keyword">set</span> (target, key, newValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set, key: '</span>, key, newValue)</span><br><span class="line">    <span class="keyword">if</span> (target[key] === newValue) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = newValue</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>).textContent = target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">vm.msg = <span class="string">'Hello World'</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.msg)</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h2><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><ul><li><strong>发布/订阅模式</strong><ul><li>订阅者</li><li>发布者</li><li>信号中心</li></ul></li></ul><blockquote><p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”(publish)一个信 号，其他任务可以向信号中心”订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执 行。这就叫做”发布/订阅模式”(publish-subscribe pattern)</p></blockquote><p>Vue 的自定义事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue()</span><br><span class="line">vm.$on(<span class="string">'dataChange'</span>, () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'dataChange'</span>)&#125;)</span><br><span class="line">vm.$on(<span class="string">'dataChange'</span>, () =&gt; &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dataChange1'</span>)</span><br><span class="line">&#125;) </span><br><span class="line">vm.$emit(<span class="string">'dataChange'</span>)</span><br></pre></td></tr></table></figure><p>兄弟组件通信过程</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="comment">// 事件中心</span></span><br><span class="line"><span class="keyword">let</span> eventHub = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentA.vue</span></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line">addTodo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发布消息(事件)</span></span><br><span class="line">  eventHub.$emit(<span class="string">'add-todo'</span>, &#123; <span class="attr">text</span>: <span class="keyword">this</span>.newTodoText &#125;) </span><br><span class="line">  <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ComponentB.vue</span></span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line">created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 订阅消息(事件)</span></span><br><span class="line">  eventHub.$on(<span class="string">'add-todo'</span>, <span class="keyword">this</span>.addTodo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>模拟 Vue 自定义事件的实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// &#123; eventType: [ handler1, handler2 ] &#125;</span></span><br><span class="line">    <span class="keyword">this</span>.subs = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅通知</span></span><br><span class="line">  $on(eventType, fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs[eventType] = <span class="keyword">this</span>.subs[eventType] || []</span><br><span class="line">    <span class="keyword">this</span>.subs[eventType].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布通知</span></span><br><span class="line">  $emit(eventType) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.subs[eventType]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subs[eventType].forEach(<span class="function"><span class="params">v</span>=&gt;</span>v())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">bus.$on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">bus.$on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件 </span></span><br><span class="line">bus.$emit(<span class="string">'click'</span>)</span><br></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><ul><li>观察者(订阅者) – <code>Watcher</code><ul><li><code>update()</code>:当事件发生时，具体要做的事情</li></ul></li><li>目标(发布者) – <code>Dep</code><ul><li><code>subs</code> 数组:存储所有的观察者</li><li><code>addSub()</code>:添加观察者</li><li><code>notify()</code>:当事件发生，调用所有观察者的 <code>update()</code> 方法</li></ul></li><li>没有事件中心</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标(发布者) </span></span><br><span class="line"><span class="comment">// Dependency</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 存储所有的观察者</span></span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub &amp;&amp; sub.update) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有观察者</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.update())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者(订阅者)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="keyword">let</span> watcher = <span class="keyword">new</span> Watcher()</span><br><span class="line">dep.addSub(watcher) </span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>观察者模式</strong>是由具体目标调度，比如当事件触发，<code>Dep</code> 就会去调用观察者的方法，所以观察者模<br>式的订阅者与发布者之间是存在依赖的</li><li><strong>发布/订阅模式</strong>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在</li></ul><p><img src="http://img-repo.poetries.top/images/20210328214834.png" alt></p><h2 id="Vue-响应式原理模拟"><a href="#Vue-响应式原理模拟" class="headerlink" title="Vue 响应式原理模拟"></a>Vue 响应式原理模拟</h2><h3 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h3><ul><li>Vue 基本结构</li><li>打印 Vue 实例观察</li><li>整体结构</li></ul><p><img src="http://img-repo.poetries.top/images/20210328214931.png" alt></p><ul><li><code>Vue</code>: 把 <code>data</code> 中的成员注入到 <code>Vue</code> 实例，并且把 <code>data</code> 中的成员转成 <code>getter/setter</code></li><li><code>Observer</code>：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知 <code>Dep</code></li><li><code>Compiler</code>：解析每个元素中的指令/插值表达式，并替换成相应的数据</li><li><code>Dep</code>：添加观察者(<code>watcher</code>)，当数据变化通知所有观察者</li><li><code>Watcher</code>：数据变化更新视图</li></ul><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul><li>功能<ul><li>负责接收初始化的参数(选项)</li><li>负责把 <code>data</code> 中的属性注入到 <code>Vue</code> 实例，转换成 <code>getter/setter</code></li><li>负责调用 <code>observer</code> 监听 <code>data</code> 中所有属性的变化</li><li>负责调用 <code>compiler</code> 解析指令/插值表达式</li></ul></li><li>结构</li></ul><p><img src="http://img-repo.poetries.top/images/20210328215207.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="comment">// 1. 保存选项的数据</span></span><br><span class="line">    <span class="keyword">this</span>.$options = options || &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.$data = options.data || &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> el = options.el</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="keyword">typeof</span> options.el === <span class="string">'string'</span> ? <span class="built_in">document</span>.querySelector(el) : el</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 负责把 data 注入到 Vue 实例</span></span><br><span class="line">    <span class="keyword">this</span>._proxyData(<span class="keyword">this</span>.$data)</span><br><span class="line">    <span class="comment">// 3. 负责调用 Observer 实现数据劫持</span></span><br><span class="line">    <span class="comment">// 4. 负责调用 Compiler 解析指令/插值表达式等</span></span><br><span class="line">  &#125;</span><br><span class="line">  _proxyData (data) &#123;</span><br><span class="line">    <span class="comment">// 遍历 data 的所有属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">        <span class="keyword">get</span> () &#123;</span><br><span class="line">          <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> (newValue) &#123;</span><br><span class="line">          <span class="keyword">if</span> (data[key] === newValue) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          data[key] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><ul><li>功能<ul><li>负责把 <code>data</code> 选项中的属性转换成响应式数据</li><li><code>data</code> 中的某个属性也是对象，把该属性转换成响应式数据</li><li>数据变化发送通知</li></ul></li><li>结构</li></ul><p><img src="http://img-repo.poetries.top/images/20210328215538.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负责数据劫持</span></span><br><span class="line"><span class="comment">// 把 $data 中的成员转换成 getter/setter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.walk(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1. 判断数据是否是对象，如果不是对象返回</span></span><br><span class="line">  <span class="comment">// 2. 如果是对象，遍历对象的所有属性，设置为 getter/setter</span></span><br><span class="line">  walk (data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 data 的所有成员</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.defineReactive(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义响应式成员</span></span><br><span class="line">  defineReactive (data, key, val) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果 val 是对象，继续设置它下面的成员为响应式数据</span></span><br><span class="line">    <span class="keyword">this</span>.walk(val)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span> (newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue === val) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 newValue 是对象，设置 newValue 的成员为响应式</span></span><br><span class="line">        that.walk(newValue)</span><br><span class="line">        val = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><ul><li>功能<ul><li>负责编译模板，解析指令/插值表达式</li><li>负责页面的首次渲染</li><li>当数据变化后重新渲染视图</li></ul></li><li>结构</li></ul><p><img src="http://img-repo.poetries.top/images/20210328215943.png" alt></p><p><strong>1. compile()</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负责解析指令/插值表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">this</span>.el = vm.$el</span><br><span class="line">    <span class="comment">// 编译模板</span></span><br><span class="line">    <span class="keyword">this</span>.compile(<span class="keyword">this</span>.el)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译模板</span></span><br><span class="line">  <span class="comment">// 处理文本节点和元素节点</span></span><br><span class="line">  compile (el) &#123;</span><br><span class="line">    <span class="keyword">const</span> nodes = el.childNodes</span><br><span class="line">    <span class="built_in">Array</span>.from(nodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是文本节点还是元素节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isTextNode(node)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.compileText(node)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.isElementNode(node)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.compileElement(node)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点中还有子节点，递归编译</span></span><br><span class="line">        <span class="keyword">this</span>.compile(node)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是文本节点</span></span><br><span class="line">  isTextNode (node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是属性节点</span></span><br><span class="line">  isElementNode (node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是以 v- 开头的指令</span></span><br><span class="line">  isDirective (attrName) &#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">'v-'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译文本节点</span></span><br><span class="line">  compileText (node) &#123; &#125;</span><br><span class="line">  <span class="comment">// 编译属性节点 </span></span><br><span class="line">  compileElement (node) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. compileText()</strong></p><ul><li>负责编译插值表达式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译文本节点</span></span><br><span class="line">compileText (node) &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.+)\&#125;\&#125;/</span></span><br><span class="line">  <span class="comment">// 获取文本节点的内容</span></span><br><span class="line">  <span class="keyword">const</span> value = node.textContent</span><br><span class="line">  <span class="keyword">if</span> (reg.test(value)) &#123;</span><br><span class="line">    <span class="comment">// 插值表达式中的值就是我们要的属性名称</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">RegExp</span>.$<span class="number">1.</span>trim()</span><br><span class="line">    <span class="comment">// 把插值表达式替换成具体的值</span></span><br><span class="line">    node.textContent = value.replace(reg, <span class="keyword">this</span>.vm[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. compileElement()</strong></p><ul><li>负责编译元素的指令</li><li>处理 <code>v-text</code> 的首次渲染</li><li>处理 <code>v-model</code> 的首次渲染</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译属性节点</span></span><br><span class="line">compileElement (node) &#123;</span><br><span class="line">  <span class="comment">// 遍历元素节点中的所有属性，找到指令</span></span><br><span class="line">  <span class="built_in">Array</span>.from(node.attributes).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取元素属性的名称</span></span><br><span class="line">    <span class="keyword">let</span> attrName = attr.name</span><br><span class="line">    <span class="comment">// 判断当前的属性名称是否是指令</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDirective(attrName)) &#123;</span><br><span class="line">      <span class="comment">// attrName 的形式 v-text v-model</span></span><br><span class="line">      <span class="comment">// 截取属性的名称，获取 text model</span></span><br><span class="line">      attrName = attrName.substr(<span class="number">2</span>)</span><br><span class="line">      <span class="comment">// 获取属性的名称，属性的名称就是我们数据对象的属性 v-text="name"，获取的是name</span></span><br><span class="line">      <span class="keyword">const</span> key = attr.value</span><br><span class="line">      <span class="comment">// 处理不同的指令</span></span><br><span class="line">      <span class="keyword">this</span>.update(node, key, attrName)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责更新 DOM</span></span><br><span class="line"><span class="comment">// 创建 Watcher</span></span><br><span class="line">update (node, key, dir) &#123;</span><br><span class="line">  <span class="comment">// node 节点，key 数据的属性名称，dir 指令的后半部分</span></span><br><span class="line">  <span class="keyword">const</span> updaterFn = <span class="keyword">this</span>[dir + <span class="string">'Updater'</span>]</span><br><span class="line">  updaterFn &amp;&amp; updaterFn(node, <span class="keyword">this</span>.vm[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v-text 指令的更新方法</span></span><br><span class="line">textUpdater (node, value) &#123;</span><br><span class="line">  node.textContent = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v-model 指令的更新方法</span></span><br><span class="line">modelUpdater (node, value) &#123;</span><br><span class="line">  node.value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dep-Dependency"><a href="#Dep-Dependency" class="headerlink" title="Dep(Dependency)"></a>Dep(Dependency)</h3><p><img src="http://img-repo.poetries.top/images/20210328220733.png" alt></p><ul><li>功能<ul><li>收集依赖，添加观察者(<code>watcher</code>)</li><li>通知所有观察者</li></ul></li><li>结构</li></ul><p><img src="http://img-repo.poetries.top/images/20210328220757.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 存储所有的观察者</span></span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者 </span></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub &amp;&amp; sub.update) &#123; <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有观察者 </span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.update()) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>compiler.js</code> 中收集依赖，发送通知</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defineReactive 中</span></span><br><span class="line"><span class="comment">// 创建 dep 对象收集依赖</span></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 中</span></span><br><span class="line"><span class="comment">// get 的过程中收集依赖</span></span><br><span class="line">Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line"></span><br><span class="line"><span class="comment">// setter 中</span></span><br><span class="line"><span class="comment">// 当数据变化之后，发送通知</span></span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><img src="http://img-repo.poetries.top/images/20210328221004.png" alt></p><ul><li>功能<ul><li>当数据变化触发依赖， <code>dep</code> 通知所有的 <code>Watcher</code> 实例更新视图</li><li>自身实例化的时候往 <code>dep</code> 对象中添加自己<br>-结构</li></ul></li></ul><p><img src="http://img-repo.poetries.top/images/20210328221037.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (vm, key, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// data 中的属性名称</span></span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="comment">// 当数据变化的时候，调用 cb 更新视图</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="comment">// 在 Dep 的静态属性上记录当前 watcher 对象，当访问数据的时候把 watcher 添加到dep 的 subs 中</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 触发一次 getter，让 dep 为当前 key 记录 watcher</span></span><br><span class="line">    <span class="keyword">this</span>.oldValue = vm[key]</span><br><span class="line">    <span class="comment">// 清空 target</span></span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="keyword">this</span>.vm[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.oldValue === newValue) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>compiler.js</code> 中为每一个指令/插值表达式创建 <code>watcher</code> 对象，监视数据的变化</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为在 textUpdater等中要使用 this</span></span><br><span class="line">updaterFn &amp;&amp; updaterFn.call(<span class="keyword">this</span>, node, <span class="keyword">this</span>.vm[key], key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// v-text 指令的更新方法</span></span><br><span class="line">textUpdater (node, value, key) &#123;</span><br><span class="line">  node.textContent = value</span><br><span class="line">  <span class="comment">// 每一个指令中创建一个 watcher，观察数据的变化</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm, key, value =&gt; &#123;</span><br><span class="line">    node.textContent = value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视图变化更新数据"><a href="#视图变化更新数据" class="headerlink" title="视图变化更新数据"></a>视图变化更新数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-model 指令的更新方法</span></span><br><span class="line">modelUpdater (node, value, key) &#123;</span><br><span class="line">  node.value = value</span><br><span class="line">  <span class="comment">// 每一个指令中创建一个 watcher，观察数据的变化</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm, key, value =&gt; &#123;</span><br><span class="line">    node.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听视图的变化</span></span><br><span class="line">  node.addEventListener(<span class="string">'input'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm[key] = node.value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过下图回顾整体流程</p><p><img src="http://img-repo.poetries.top/images/20210328221437.png" alt></p><ul><li>Vue<ul><li>记录传入的选项，设置 <code>$data/$el</code></li><li>把 <code>data</code> 的成员注入到 <code>Vue</code> 实例</li><li>负责调用 <code>Observer</code> 实现数据响应式处理(数据劫持)</li><li>负责调用 <code>Compiler</code> 编译指令/插值表达式等</li></ul></li><li><code>Observer</code><ul><li>数据劫持<ul><li>负责把 <code>data</code> 中的成员转换成 <code>getter/setter</code></li><li>负责把多层属性转换成 <code>getter/setter</code></li><li>如果给属性赋值为新对象，把新对象的成员设置为 <code>getter/setter</code></li></ul></li><li>添加 <code>Dep</code> 和 <code>Watcher</code> 的依赖关系</li><li>数据变化发送通知</li></ul></li><li><code>Compiler</code><ul><li>负责编译模板，解析指令/插值表达式</li><li>负责页面的首次渲染过程</li><li>当数据变化后重新渲染</li></ul></li><li><code>Dep</code><ul><li>收集依赖，添加订阅者(<code>watcher</code>)</li><li>通知所有订阅者</li></ul></li><li><code>Watcher</code><ul><li>自身实例化的时候往<code>dep</code>对象中添加自己</li><li>当数据变化<code>dep</code>通知所有的 <code>Watcher</code> 实例更新视图</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据驱动&quot;&gt;&lt;a href=&quot;#数据驱动&quot; class=&quot;headerlink&quot; title=&quot;数据驱动&quot;&gt;&lt;/a&gt;数据驱动&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据响应式、双向绑定、数据驱动&lt;/li&gt;
&lt;li&gt;数据响应式&lt;ul&gt;
&lt;li&gt;数据模型仅仅是普通的 &lt;code&gt;
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Vue" scheme="http://blog.poetries.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue Router、Vuex原理实践</title>
    <link href="http://blog.poetries.top/2021/03/13/vue-router-vuex/"/>
    <id>http://blog.poetries.top/2021/03/13/vue-router-vuex/</id>
    <published>2021-03-13T07:12:12.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><blockquote><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单⻚面应用变得易如反 掌。</p></blockquote><p>安装: vue add router 核心步骤:</p><ol><li>步骤一:使用vue-router插件，router.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span> </span><br><span class="line">Vue.use(Router)</span><br></pre></td></tr></table></figure><ol start="2"><li>步骤二:创建Router实例，router.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;...&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>步骤三:在根组件上添加该实例，main.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>步骤四:添加路由视图，<code>App.vue</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p>导航</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">"/"</span>&gt;Home&lt;<span class="regexp">/router-link&gt; </span></span><br><span class="line"><span class="regexp">&lt;router-link to="/</span>about<span class="string">"&gt;About&lt;/router-link&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-router源码实现"><a href="#vue-router源码实现" class="headerlink" title="vue-router源码实现"></a>vue-router源码实现</h3><ul><li>作为一个插件存在:实现<code>VueRouter</code>类和<code>install</code>方法 </li><li>实现两个全局组件:<code>router-view</code>用于显示匹配组件内容，<code>router-link</code>用于跳转 </li><li>监控<code>url</code>变化:监听<code>hashchange</code>或<code>popstate</code>事件 </li><li>响应最新<code>url</code>:创建一个响应式的属性<code>current</code>，当它改变时获取对应组件并显示</li></ul><p>创建kvue-router.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的插件：</span></span><br><span class="line"><span class="comment">// 1.实现一个Router类并挂载期实例</span></span><br><span class="line"><span class="comment">// 2.实现两个全局组件router-link和router-view</span></span><br><span class="line"><span class="keyword">let</span> Vue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 核心任务：</span></span><br><span class="line">  <span class="comment">// 1.监听url变化</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$options = options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存path和route映射关系</span></span><br><span class="line">    <span class="comment">// 这样找组件更快</span></span><br><span class="line">    <span class="keyword">this</span>.routeMap = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.$options.routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.routeMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据响应式</span></span><br><span class="line">    <span class="comment">// 定义一个响应式的current，则如果他变了，那么使用它的组件会rerender</span></span><br><span class="line">    Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'current'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请确保onHashChange中this指向当前实例</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.onHashChange.bind(<span class="keyword">this</span>))</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.onHashChange.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onHashChange() &#123;</span><br><span class="line">    <span class="comment">// console.log(window.location.hash);</span></span><br><span class="line">    <span class="keyword">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件需要实现install方法</span></span><br><span class="line"><span class="comment">// 接收一个参数，Vue构造函数，主要用于数据响应式</span></span><br><span class="line">VueRouter.install = <span class="function"><span class="keyword">function</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存Vue构造函数在VueRouter中使用</span></span><br><span class="line">  Vue = _Vue</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任务1：使用混入来做router挂载这件事情</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="comment">// 只有根实例才有router选项</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$options.router) &#123;</span><br><span class="line">        Vue.prototype.$router = <span class="keyword">this</span>.$options.router</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任务2：实现两个全局组件</span></span><br><span class="line">  <span class="comment">// router-link: 生成一个a标签，在url后面添加#</span></span><br><span class="line">  <span class="comment">// &lt;a href="#/about"&gt;aaaa&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">// &lt;router-link to="/about"&gt;aaa&lt;/router-link&gt;</span></span><br><span class="line">  Vue.component(<span class="string">'router-link'</span>, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      to: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="comment">// h(tag, props, children)</span></span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">'a'</span>,</span><br><span class="line">        &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">'#'</span> + <span class="keyword">this</span>.to &#125; &#125;,</span><br><span class="line">        <span class="keyword">this</span>.$slots.default</span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 使用jsx</span></span><br><span class="line">      <span class="comment">// return &lt;a href=&#123;'#'+this.to&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.component(<span class="string">'router-view'</span>, &#123;</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="comment">// 根据current获取组件并render</span></span><br><span class="line">      <span class="comment">// current怎么获取?</span></span><br><span class="line">      <span class="comment">// console.log('render',this.$router.current);</span></span><br><span class="line">      <span class="comment">// 获取要渲染的组件</span></span><br><span class="line">      <span class="keyword">let</span> component = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">const</span> &#123; routeMap, current &#125; = <span class="keyword">this</span>.$router</span><br><span class="line">      <span class="keyword">if</span> (routeMap[current]) &#123;</span><br><span class="line">        component = routeMap[current].component</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h(component)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VueRouter</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><blockquote><p>Vuex 集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化</p></blockquote><h3 id="整合vuex"><a href="#整合vuex" class="headerlink" title="整合vuex"></a>整合<strong>vuex</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue add vuex</span><br></pre></td></tr></table></figure><p>核心概念</p><ul><li>state 状态、数据 </li><li>mutations 更改状态的函数 </li><li>actions 异步操作</li><li>store 包含以上概念的容器</li></ul><ol><li>状态 <strong>- state</strong></li></ol><p>state保存应用状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123; <span class="attr">state</span>: &#123; <span class="attr">counter</span>:<span class="number">0</span> &#125;,&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>状态变更 <strong>- mutations</strong></li></ol><p>mutations用于修改状态，store.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    mutations:</span><br><span class="line">    &#123;</span><br><span class="line">      add(state) &#123;</span><br><span class="line">        state.counter++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>派生状态 <strong>- getters</strong></li></ol><p>从state派生出新状态，类似计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    getters:</span><br><span class="line">    &#123;</span><br><span class="line">      doubleCounter(state) &#123; <span class="comment">// 计算剩余数量 return state.counter * 2;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>动作 <strong>- actions</strong></li></ol><p>加业务逻辑，类似于controller</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions:</span><br><span class="line">    &#123;</span><br><span class="line">      add(&#123;</span><br><span class="line">        commit</span><br><span class="line">      &#125;) &#123;</span><br><span class="line">        setTimeout(() = &gt;&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;p @click=<span class="string">"$store.commit('add')"</span>&gt;counter: &#123;&#123;$store.state.counter&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p @click="$store.dispatch('add')"&gt;async counter: &#123;&#123;$store.state.counter&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;double:&#123;&#123;$store.getters.doubleCounter&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vuex原理解析"><a href="#vuex原理解析" class="headerlink" title="vuex原理解析"></a><strong>vuex</strong>原理解析</h3><ul><li>实现一个插件:声明Store类，挂载$store </li><li>Store具体实现:<ul><li>创建响应式的state，保存mutations、actions和getters </li><li>实现commit根据用户传入type执行对应mutation </li><li>实现dispatch根据用户传入type执行对应action，同时传递上下文 </li><li>实现getters，按照getters定义对state做派生</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标1：实现Store类，管理state（响应式的），commit方法和dispatch方法</span></span><br><span class="line"><span class="comment">// 目标2：封装一个插件，使用更容易使用</span></span><br><span class="line"><span class="keyword">let</span> Vue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 定义响应式的state</span></span><br><span class="line">    <span class="comment">// this.$store.state.xx</span></span><br><span class="line">    <span class="comment">// 借鸡生蛋</span></span><br><span class="line">    <span class="keyword">this</span>._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        $$state: options.state</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>._mutations = options.mutations</span><br><span class="line">    <span class="keyword">this</span>._actions = options.actions</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定this指向</span></span><br><span class="line">    <span class="keyword">this</span>.commit = <span class="keyword">this</span>.commit.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.dispatch = <span class="keyword">this</span>.dispatch.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只读</span></span><br><span class="line">  <span class="keyword">get</span> state() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._vm._data.$$state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> state(val) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'不能直接赋值呀，请换别的方式！！天王盖地虎！！'</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实现commit方法，可以修改state</span></span><br><span class="line">  commit(type, payload) &#123;</span><br><span class="line">    <span class="comment">// 拿出mutations中的处理函数执行它</span></span><br><span class="line">    <span class="keyword">const</span> entry = <span class="keyword">this</span>._mutations[type]</span><br><span class="line">    <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'未知mutaion类型'</span>);</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry(<span class="keyword">this</span>.state, payload)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch(type, payload) &#123;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="keyword">this</span>._actions[type]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'未知action类型'</span>);</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文可以传递当前store实例进去即可</span></span><br><span class="line">    entry(<span class="keyword">this</span>, payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>)</span>&#123;</span><br><span class="line">  Vue = _Vue</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 混入store实例</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$options.store) &#123;</span><br><span class="line">        Vue.prototype.$store = <span class="keyword">this</span>.$options.store</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; Store, install &#125;相当于Vuex</span></span><br><span class="line"><span class="comment">// 它必须实现install方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; Store, install &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue-router&quot;&gt;&lt;a href=&quot;#vue-router&quot; class=&quot;headerlink&quot; title=&quot;vue-router&quot;&gt;&lt;/a&gt;vue-router&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Vue Router 是 Vue.js 官方的路由
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Vue" scheme="http://blog.poetries.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件化实践详解</title>
    <link href="http://blog.poetries.top/2021/03/13/vue-comp/"/>
    <id>http://blog.poetries.top/2021/03/13/vue-comp/</id>
    <published>2021-03-13T04:12:12.000Z</published>
    <updated>2021-05-11T03:46:23.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote><p> vue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界 面都可以抽象为一个组件树。组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护 性，便于多人协同开发。</p></blockquote><p><img src="http://img-repo.poetries.top/images/20210313133919.png" alt></p><h2 id="组件通信常用方式"><a href="#组件通信常用方式" class="headerlink" title="组件通信常用方式"></a>组件通信常用方式</h2><h3 id="1-props"><a href="#1-props" class="headerlink" title="1. props"></a><strong>1. props</strong></h3><blockquote><p>父给子传值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// child</span></span><br><span class="line">props: &#123; <span class="attr">msg</span>: <span class="built_in">String</span> &#125;</span><br><span class="line"><span class="comment">// parent</span></span><br><span class="line">&lt;HelloWorld msg=<span class="string">"Welcome to Your Vue.js App"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="2-自定义事件"><a href="#2-自定义事件" class="headerlink" title="2. 自定义事件"></a>2. 自定义事件</h3><blockquote><p>子给父传值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// child this.$emit('add', good)</span></span><br><span class="line"><span class="comment">// parent</span></span><br><span class="line">&lt;Cart @add=<span class="string">"cartAdd($event)"</span>&gt;&lt;<span class="regexp">/Cart&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-事件总线"><a href="#3-事件总线" class="headerlink" title="3. 事件总线"></a>3. 事件总线</h3><blockquote><p>任意两个组件之间传值常用事件总线 或 vuex的方式。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// Bus:事件派发、监听和回调管理 class Bus &#123;</span></span><br><span class="line"><span class="keyword">constructor</span>()&#123; <span class="keyword">this</span>.callbacks = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  $on(name, fn)&#123;</span><br><span class="line"><span class="keyword">this</span>.callbacks[name] = <span class="keyword">this</span>.callbacks[name] || []</span><br><span class="line"><span class="keyword">this</span>.callbacks[name].push(fn) &#125;</span><br><span class="line">$emit(name, args)&#123; <span class="keyword">if</span>(<span class="keyword">this</span>.callbacks[name])&#123;</span><br><span class="line"><span class="keyword">this</span>.callbacks[name].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(args)) &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Bus()</span><br><span class="line"><span class="comment">// child1</span></span><br><span class="line"><span class="keyword">this</span>.$bus.$on(<span class="string">'foo'</span>, handle) <span class="comment">// child2 this.$bus.$emit('foo')</span></span><br></pre></td></tr></table></figure><blockquote><p>实践中通常用Vue代替Bus，因为Vue已经实现了相应接口</p></blockquote><h3 id="4-vuex"><a href="#4-vuex" class="headerlink" title="4. vuex"></a><strong>4. vuex</strong></h3><blockquote><p>创建唯一的全局数据管理者store，通过它管理数据并通知组件状态变更。</p></blockquote><h3 id="5-parent-root"><a href="#5-parent-root" class="headerlink" title="5. $parent/$root"></a>5. <strong>$parent/$root</strong></h3><blockquote><p>兄弟组件之间通信可通过共同祖辈搭桥，<code>$parent</code>或<code>$root</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// brother1</span></span><br><span class="line"><span class="keyword">this</span>.$parent.$on(<span class="string">'foo'</span>, handle)</span><br><span class="line"><span class="comment">// brother2 </span></span><br><span class="line"><span class="keyword">this</span>.$parent.$emit(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><h3 id="6-children"><a href="#6-children" class="headerlink" title="6. $children"></a>6. <strong>$children</strong></h3><blockquote><p>父组件可以通过<code>$children</code>访问子组件实现父子通信。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent </span></span><br><span class="line"><span class="keyword">this</span>.$children[<span class="number">0</span>].xx = <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><h3 id="7-attrs-listeners"><a href="#7-attrs-listeners" class="headerlink" title="7. $attrs/$listeners"></a>7. <strong>$attrs/$listeners</strong></h3><blockquote><p>包含了父作用域中不作为 <strong>prop</strong> 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有 声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 <code>v- bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// child:并未在props中声明foo </span></span><br><span class="line">&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ parent</span></span><br><span class="line"><span class="regexp">&lt;HelloWorld foo="foo"/</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="8-refs"><a href="#8-refs" class="headerlink" title="8. refs"></a>8. <strong>refs</strong></h3><blockquote><p>获取子节点引用</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// parent</span></span><br><span class="line">&lt;HelloWorld ref=<span class="string">"hw"</span>/&gt;</span><br><span class="line">mounted() &#123; </span><br><span class="line">  <span class="keyword">this</span>.$refs.hw.xx = <span class="string">'xxx'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-provide-inject"><a href="#9-provide-inject" class="headerlink" title="9. provide/inject"></a>9. <strong>provide/inject</strong></h3><blockquote><p>能够实现祖先和后代之间传值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">// ancestor</span></span><br><span class="line">provide() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">foo</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// descendant</span></span><br><span class="line">inject: [<span class="string">'foo'</span>]</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;组件通信&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- props, 自定义事件 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Child1 msg="some msg from parent" @some-event="onSomeEvent"&gt;&lt;/</span>Child1&gt;</span><br><span class="line">    &lt;!-- 事件总线 --&gt;</span><br><span class="line">    &lt;Child2 msg=<span class="string">"other msg"</span>&gt;&lt;<span class="regexp">/Child2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  import Child1 from '@/</span>components/communication/Child1.vue<span class="string">'</span></span><br><span class="line"><span class="string">  import Child2 from '</span>@/components/communication/Child2.vue<span class="string">'</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    components: &#123;</span></span><br><span class="line"><span class="string">      Child1, Child2,</span></span><br><span class="line"><span class="string">      // Child3: () =&gt; import('</span>./Child3.vue<span class="string">')</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    methods: &#123;</span></span><br><span class="line"><span class="string">      onSomeEvent(msg) &#123;</span></span><br><span class="line"><span class="string">        console.log('</span>Communition:<span class="string">', msg);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    mounted () &#123;</span></span><br><span class="line"><span class="string">      // $children持有所有自定义组件</span></span><br><span class="line"><span class="string">      // 它不保证顺序</span></span><br><span class="line"><span class="string">      console.log(this.$children);</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child1.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click=<span class="string">"$emit('some-event', 'msg from child1')"</span>&gt;</span><br><span class="line">    &lt;h3&gt;child1&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      msg: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="comment">// this.$bus.$on('event-from-child2', msg =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//   console.log('Child1:', msg);</span></span><br><span class="line">      <span class="comment">// &#125;);</span></span><br><span class="line">      <span class="keyword">this</span>.$parent.$on(<span class="string">'event-from-child2'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Child1:'</span>, msg);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child2.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 展开$attrs对象 --&gt;</span><br><span class="line">    &lt;h3 v-bind=<span class="string">"$attrs"</span>&gt;child2&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="sendToChild1"&gt;给child1发送消息&lt;/</span>button&gt;</span><br><span class="line">    &lt;!-- $attrs --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;$attrs.msg&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- inject --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;&#123;&#123;foo&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">    inject: [<span class="string">'foo'</span>],</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendToChild1() &#123;</span><br><span class="line">        <span class="comment">// 利用事件总线发送事件</span></span><br><span class="line">        <span class="comment">// this.$bus.$emit('event-from-child2', 'some msg from child2')</span></span><br><span class="line">        <span class="keyword">this</span>.$parent.$emit(<span class="string">'event-from-child2'</span>, <span class="string">'some msg from child2'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote><p>插槽语法是Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用</p></blockquote><h3 id="1-匿名插槽"><a href="#1-匿名插槽" class="headerlink" title="1. 匿名插槽"></a>1. 匿名插槽</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// comp1</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"><span class="comment">// parent</span></span><br><span class="line">&lt;comp&gt;hello&lt;<span class="regexp">/comp&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2. 具名插槽"></a>2. 具名插槽</h3><blockquote><p>将内容分发到子组件指定位置</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// comp2</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">&lt;slot name="content"&gt;&lt;/</span>slot&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ parent</span></span><br><span class="line"><span class="regexp">&lt;Comp2&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- 默认插槽用default做参数 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;template v-slot:default&gt;具名插槽&lt;/</span>template&gt; &lt;!-- 具名插槽用插槽名做参数 --&gt;</span><br><span class="line">&lt;template v-slot:content&gt;内容...&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Comp2&gt;</span><br></pre></td></tr></table></figure><h3 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h3><blockquote><p>分发内容要用到子组件中的数据</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// comp3</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot :foo=<span class="string">"foo"</span>&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"><span class="comment">// parent</span></span><br><span class="line">&lt;Comp3&gt;</span><br><span class="line">&lt;!-- 把v-slot的值指定为作用域上下文对象 --&gt; <span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span> 来自子组件数据:&#123;&#123;slotProps.foo&#125;&#125; <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/Comp3&gt;</span></span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件 Layout.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"header"</span>&gt;</span><br><span class="line">      &lt;slot name=<span class="string">"header"</span>&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"body"</span>&gt;</span><br><span class="line">      &lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"footer"</span>&gt;</span><br><span class="line">      &lt;slot name=<span class="string">"footer"</span> :fc=<span class="string">"footerContent"</span>&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        remark: [</span><br><span class="line">          <span class="string">'好好学习，天天向上'</span>,</span><br><span class="line">          <span class="string">'学习永远不晚'</span>,</span><br><span class="line">          <span class="string">'学习知识要善于思考,思考,再思考'</span>,</span><br><span class="line">          <span class="string">'学习的敌人是自己的满足,要认真学习一点东西,必须从不自满开始'</span>,</span><br><span class="line">          <span class="string">'构成我们学习最大障碍的是已知的东西,而不是未知的东西'</span>,</span><br><span class="line">          <span class="string">'在今天和明天之间,有一段很长的时间;趁你还有精神的时候,学习迅速办事'</span>,</span><br><span class="line">          <span class="string">'三人行必有我师焉；择其善者而从之，其不善者而改之'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      footerContent() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.remark[<span class="keyword">new</span> <span class="built_in">Date</span>().getDay() - <span class="number">1</span>] </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">.header &#123;</span></span><br><span class="line"><span class="regexp">  background-color: rgb(252, 175, 175);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">.body &#123;</span></span><br><span class="line"><span class="regexp">  display: flex;</span></span><br><span class="line"><span class="regexp">  background-color: rgb(144, 250, 134);</span></span><br><span class="line"><span class="regexp">  min-height: 100px;</span></span><br><span class="line"><span class="regexp">  align-items: center;</span></span><br><span class="line"><span class="regexp">  justify-content: center;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">.footer &#123;</span></span><br><span class="line"><span class="regexp">  background-color: rgb(114, 116, 255);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件 index.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;插槽&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 插槽 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Layout&gt;</span></span><br><span class="line"><span class="regexp">      &lt;!-- 具名插槽 --&gt;</span></span><br><span class="line"><span class="regexp">      &lt;template v-slot:header&gt;全栈工程师&lt;/</span>template&gt;</span><br><span class="line">      &lt;!-- 匿名插槽 --&gt;</span><br><span class="line">      &lt;template&gt;content...&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">      &lt;!-- 作用域插槽 --&gt;</span></span><br><span class="line"><span class="regexp">      &lt;template v-slot:footer="&#123;fc&#125;"&gt;&#123;&#123;fc&#125;&#125;&lt;/</span>template&gt;</span><br><span class="line">    &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  import Layout from '@/</span>components/slots/Layout.vue<span class="string">'</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    components: &#123;</span></span><br><span class="line"><span class="string">      Layout</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件化实战"><a href="#组件化实战" class="headerlink" title="组件化实战"></a>组件化实战</h2><h3 id="通用表单组件"><a href="#通用表单组件" class="headerlink" title="通用表单组件"></a>通用表单组件</h3><blockquote><p>收集数据、校验数据并提交。</p></blockquote><ul><li><p>实现KForm 指定数据、校验规则</p></li><li><p>KformItem </p><ul><li>label标签添加 </li><li>执行校验 </li><li>显示错误信息</li></ul></li><li><p>KInput</p><ul><li>维护数据</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form :model=<span class="string">"userInfo"</span> :rules=<span class="string">"rules"</span> ref=<span class="string">"loginForm"</span>&gt;</span><br><span class="line">    &lt;el-form-item label=<span class="string">"用户名"</span> prop=<span class="string">"name"</span>&gt;</span><br><span class="line">      &lt;el-input v-model=<span class="string">"userInfo.name"</span>&gt;&lt;<span class="regexp">/el-input&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=<span class="string">"密码"</span> prop=<span class="string">"password"</span>&gt;</span><br><span class="line">      &lt;el-input v-model=<span class="string">"userInfo.password"</span> type=<span class="string">"password"</span>&gt;&lt;<span class="regexp">/el-input&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>el-form-item&gt;</span><br><span class="line">    &lt;el-form-item&gt;</span><br><span class="line">      &lt;el-button @click=<span class="string">"login"</span>&gt;登录&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>el-form-item&gt;</span><br><span class="line">  &lt;<span class="regexp">/el-form&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      userInfo: &#123;</span><br><span class="line">        username: <span class="string">""</span>,</span><br><span class="line">        password: <span class="string">""</span></span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        username: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">"请输入用户名称"</span> &#125;],</span><br><span class="line">        password: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">"请输入密码"</span> &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs[<span class="string">"loginForm"</span>].validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">          alert(<span class="string">"submit"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"error submit!"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p><strong>1. </strong>KInput</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建components/form/KInput.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 管理数据：实现双绑 --&gt;</span><br><span class="line">    &lt;!-- :value, @input --&gt;</span><br><span class="line">    &lt;input :type=<span class="string">"type"</span> :value=<span class="string">"value"</span> @input=<span class="string">"onInput"</span></span><br><span class="line">      v-bind=<span class="string">"$attrs"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span> , <span class="comment">// 关闭特性继承</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">      &#125;,</span><br><span class="line">      type: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'text'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onInput(e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, e.target.value)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值发生变化的时候就是需要校验的时候</span></span><br><span class="line">        <span class="keyword">this</span>.$parent.$emit(<span class="string">'validate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<strong>KInput</strong></li></ol><p>创建components/form/index.vue，添加如下代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">&lt;h3&gt;KForm表单&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">&lt;hr&gt;</span></span><br><span class="line"><span class="regexp">&lt;k-input v-model="model.username"&gt;&lt;/</span>k-input&gt;</span><br><span class="line">&lt;k-input type=<span class="string">"password"</span> v-model=<span class="string">"model.password"</span>&gt;&lt;<span class="regexp">/k-input&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  components: &#123;</span></span><br><span class="line"><span class="regexp">  KInput</span></span><br><span class="line"><span class="regexp">&#125;, </span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">   return &#123;</span></span><br><span class="line"><span class="regexp">      model: &#123; username: "tom", password: "" &#125;,</span></span><br><span class="line"><span class="regexp">    &#125;; </span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>实现<strong>KFormItem</strong></li></ol><p>创建components/form/KFormItem.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- label标签 --&gt;</span><br><span class="line">    &lt;label v-<span class="keyword">if</span>=<span class="string">"label"</span>&gt;&#123;&#123;label&#125;&#125;&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 容器，放插槽 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;slot&gt;&lt;/</span>slot&gt;</span><br><span class="line">    &lt;!-- 错误信息展示 --&gt;</span><br><span class="line">    &lt;p v-<span class="keyword">if</span>=<span class="string">"error"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"error"</span>&gt;&#123;&#123;error&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  import Schema from 'async-validator'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    inject: ['form'],</span></span><br><span class="line"><span class="regexp">    data() &#123;</span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        error: ''</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    props: &#123;</span></span><br><span class="line"><span class="regexp">      label: &#123;</span></span><br><span class="line"><span class="regexp">        type: String,</span></span><br><span class="line"><span class="regexp">        default: ''</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      prop: &#123;</span></span><br><span class="line"><span class="regexp">        type: String,</span></span><br><span class="line"><span class="regexp">        default: ''</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    mounted () &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 监听校验事件</span></span><br><span class="line"><span class="regexp">      this.$on('validate', () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        this.validate()</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      validate() &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 执行校验</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 1.获取值和校验规则</span></span><br><span class="line"><span class="regexp">        const rules = this.form.rules[this.prop]</span></span><br><span class="line"><span class="regexp">        const value = this.form.model[this.prop]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 2.执行校验：使用官方也使用的async-validator</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 创建描述对象</span></span><br><span class="line"><span class="regexp">        const descriptor = &#123;[this.prop]:rules&#125;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 创建校验器</span></span><br><span class="line"><span class="regexp">        const validator = new Schema(descriptor)</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 执行校验</span></span><br><span class="line"><span class="regexp">        return validator.validate(&#123;[this.prop]:value&#125;, errors =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ 如果errors存在，则说明校验失败</span></span><br><span class="line"><span class="regexp">          if (errors) &#123;</span></span><br><span class="line"><span class="regexp">            this.error = errors[0].message</span></span><br><span class="line"><span class="regexp">          &#125; else &#123;</span></span><br><span class="line"><span class="regexp">            this.error = ''</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.error&#123;</span><br><span class="line">  color: red</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用<strong>KFormItem</strong></li></ol><p>components/form/index.vue，添加基础代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">&lt;h3&gt;KForm表单&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">&lt;hr&gt;</span></span><br><span class="line"><span class="regexp">&lt;k-form-item label="用户名" prop="username"&gt;</span></span><br><span class="line"><span class="regexp">&lt;k-input v-model="model.username"&gt;&lt;/</span>k-input&gt; &lt;<span class="regexp">/k-form-item&gt;</span></span><br><span class="line"><span class="regexp">&lt;k-form-item label="确认密码" prop="password"&gt;</span></span><br><span class="line"><span class="regexp">&lt;k-input type="password" v-model="model.password"&gt;&lt;/</span>k-input&gt;</span><br><span class="line">&lt;<span class="regexp">/k-form-item&gt; &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>实现<strong>KForm</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 容器：存放所有表单项 --&gt;</span><br><span class="line">    &lt;!-- 存储值载体：保存大家数据和校验规则 --&gt;</span><br><span class="line">    &lt;slot&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 我们平时写的组件是一个组件配置对象</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  provide() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 直接把当前组件实例传递下去</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 传递下去的对象是响应式的则还可以响应式</span></span><br><span class="line"><span class="regexp">      form: this</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 数据模型</span></span><br><span class="line"><span class="regexp">    model: &#123;</span></span><br><span class="line"><span class="regexp">      type: Object,</span></span><br><span class="line"><span class="regexp">      required: true</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    rules: Object</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    validate(cb) &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 遍历肚子里面的所有FormItem，执行他们的validate方法</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 全部通过才算通过</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ tasks是校验结果的Promise组成的数组</span></span><br><span class="line"><span class="regexp">      const tasks = this.$children</span></span><br><span class="line"><span class="regexp">        .filter(item =&gt; item.prop)</span></span><br><span class="line"><span class="regexp">        .map(item =&gt; item.validate());</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 统一判断</span></span><br><span class="line"><span class="regexp">      Promise.all(tasks)</span></span><br><span class="line"><span class="regexp">        .then(() =&gt; cb(true))</span></span><br><span class="line"><span class="regexp">        .catch(() =&gt; cb(false));</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>使用<strong>KForm</strong></li></ol><p>components/form/index.vue，添加基础代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt; template &gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span> <span class="tag">&lt;<span class="name">h3</span> &gt;</span> KForm表单 <span class="tag">&lt; /<span class="attr">h3</span>&gt;</span></span></span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;k-form :model="model" :rules="rules" ref="loginForm"&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/k - form &gt; &lt;/div&gt;</span><br><span class="line">&lt;/template &gt; &lt;script &gt; import KForm from "./KForm";</span><br><span class="line">export default &#123;</span><br><span class="line">        components:</span><br><span class="line">        &#123;</span><br><span class="line">            KForm,</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                rules: &#123;</span><br><span class="line">                    username: [&#123;</span><br><span class="line">                        required: true,</span><br><span class="line">                        message: "请输入用户名"</span><br><span class="line">                    &#125;],</span><br><span class="line">                    password: [&#123;</span><br><span class="line">                        required: true,</span><br><span class="line">                        message: "请输入密码"</span><br><span class="line">                    &#125;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            submitForm() &#123;</span><br><span class="line">                this.$refs['loginForm'].validate(valid = &gt;&#123;</span><br><span class="line">                    if (valid) &#123;</span><br><span class="line">                        alert("请求登录!");</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        alert("校验失败!");</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; &lt; /script&gt;/</span><br></pre></td></tr></table></figure><ol start="7"><li>数据校验</li></ol><p>Input通知校验</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onInput(e) &#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// $parent指FormItem</span></span><br><span class="line">    <span class="keyword">this</span>.$parent.$emit(<span class="string">'validate'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FormItem监听校验通知，获取规则并执行校验</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inject: [<span class="string">'form'</span>],</span><br><span class="line"><span class="comment">// 注入 mounted()&#123;// 监听校验事件</span></span><br><span class="line"><span class="keyword">this</span>.$on(<span class="string">'validate'</span>, () = &gt;&#123;</span><br><span class="line">    <span class="keyword">this</span>.validate()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    validate() &#123;</span><br><span class="line">        <span class="comment">// 获取对应FormItem校验规则 console.log(this.form.rules[this.prop]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Schema <span class="keyword">from</span> <span class="string">"async-validator"</span>;</span><br><span class="line"></span><br><span class="line">validate() &#123;</span><br><span class="line">    <span class="comment">// 获取对应FormItem校验规则</span></span><br><span class="line">    <span class="keyword">const</span> rules = <span class="keyword">this</span>.form.rules[<span class="keyword">this</span>.prop];</span><br><span class="line">    <span class="comment">// 获取校验值</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.form.model[<span class="keyword">this</span>.prop];</span><br><span class="line">    <span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(descriptor);</span><br><span class="line">    <span class="comment">// 返回Promise，没有触发catch就说明验证通过</span></span><br><span class="line">    <span class="keyword">return</span> schema.validate(&#123; [<span class="keyword">this</span>.prop] : value</span><br><span class="line">    &#125;,</span><br><span class="line">    errors = &gt;&#123;</span><br><span class="line">        <span class="keyword">if</span> (errors) &#123;</span><br><span class="line">            <span class="comment">// 将错误信息显示</span></span><br><span class="line">            <span class="keyword">this</span>.error = errors[<span class="number">0</span>].message;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 校验通过 this.error = "";</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表单全局验证，为<code>Form</code>提供<code>validate</code>方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">validate(cb) &#123;</span><br><span class="line">    <span class="comment">// 调用所有含有prop属性的子组件的validate方法并得到Promise数组 const tasks = this.$children</span></span><br><span class="line">    .filter(item = &gt;item.prop).map(item = &gt;item.validate());</span><br><span class="line">    <span class="comment">// 所有任务必须全部成功才算校验通过，任一失败则校验失败</span></span><br><span class="line">    <span class="built_in">Promise</span>.all(tasks).then(() = &gt;cb(<span class="literal">true</span>)).catch(() = &gt;cb(<span class="literal">false</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现弹窗组件"><a href="#实现弹窗组件" class="headerlink" title="实现弹窗组件"></a>实现弹窗组件</h3><blockquote><p>弹窗这类组件的特点是它们在当前<strong>vue</strong>实例之外独立存在，通常挂载于body;它们是通过JS动态创建的，不需要在任何组件中声明。常⻅使用姿势</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$create(Notice, &#123;</span><br><span class="line">    title: <span class="string">'喊你来搬砖'</span>,</span><br><span class="line">    message: <span class="string">'提示信息'</span>,</span><br><span class="line">    duration: <span class="number">1000</span></span><br><span class="line">&#125;).show();</span><br></pre></td></tr></table></figure><p>create函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="comment">// 创建函数接收要创建组件定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Component, props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Vue新实例 const vm = new Vue(&#123;</span></span><br><span class="line">    render(h) &#123;</span><br><span class="line">        <span class="comment">// render函数将传入组件配置对象转换为虚拟dom console.log(h(Component, &#123; props &#125;)); return h(Component, &#123; props &#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).$mount(); <span class="comment">//执行挂载函数，但未指定挂载目标，表示只执行初始化工作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将生成dom元素追加至</span></span><br><span class="line">  body <span class="built_in">document</span>.body.appendChild(vm.$el);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给组件实例添加销毁方法</span></span><br><span class="line">  <span class="keyword">const</span> comp = vm.$children[<span class="number">0</span>];</span><br><span class="line">  comp.remove = () = &gt;&#123;</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(vm.$el);</span><br><span class="line">      vm.$destroy();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> comp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暴露调用接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> create</span><br></pre></td></tr></table></figure><blockquote><p>另一种创建组件实例的方式: <code>Vue.extend(Component)</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Ctor = Vue.extend(Component) </span><br><span class="line"><span class="keyword">const</span> comp = <span class="keyword">new</span> Ctor(&#123;</span><br><span class="line">    propsData: props</span><br><span class="line">&#125;) </span><br><span class="line">comp.$mount();</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(comp.$el) </span><br><span class="line"></span><br><span class="line">comp.remove = () = &gt;&#123;</span><br><span class="line">    <span class="comment">// 移除dom document.body.removeChild(comp.$el) // 销毁组件</span></span><br><span class="line">    comp.$destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通知组件"><a href="#通知组件" class="headerlink" title="通知组件"></a>通知组件</h3><p>建通知组件，Notice.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span> v-<span class="keyword">if</span>=<span class="string">"isShow"</span>&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p class="box-content"&gt;&#123;&#123;message&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    message: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    duration: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">2000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isShow: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      <span class="keyword">this</span>.isShow = <span class="literal">true</span>;</span><br><span class="line">      setTimeout(<span class="keyword">this</span>.hide, <span class="keyword">this</span>.duration);</span><br><span class="line">    &#125;,</span><br><span class="line">    hide() &#123;</span><br><span class="line">      <span class="keyword">this</span>.isShow = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">this</span>.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">.box &#123;</span></span><br><span class="line"><span class="regexp">  position: fixed;</span></span><br><span class="line"><span class="regexp">  width: 100%;</span></span><br><span class="line"><span class="regexp">  top: 16px;</span></span><br><span class="line"><span class="regexp">  left: 0;</span></span><br><span class="line"><span class="regexp">  text-align: center;</span></span><br><span class="line"><span class="regexp">  pointer-events: none;</span></span><br><span class="line"><span class="regexp">  background-color: #fff;</span></span><br><span class="line"><span class="regexp">  border: grey 3px solid;</span></span><br><span class="line"><span class="regexp">  box-sizing: border-box;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">.box-content &#123;</span></span><br><span class="line"><span class="regexp">  width: 200px;</span></span><br><span class="line"><span class="regexp">  margin: 10px auto;</span></span><br><span class="line"><span class="regexp">  font-size: 14px;  </span></span><br><span class="line"><span class="regexp">  padding: 8px 16px;</span></span><br><span class="line"><span class="regexp">  background: #fff;</span></span><br><span class="line"><span class="regexp">  border-radius: 3px;</span></span><br><span class="line"><span class="regexp">  margin-bottom: 8px;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>使用插件进一步封装便于使用，<code>create.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Notice <span class="keyword">from</span> <span class="string">'@/components/Notice.vue'</span> <span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">      Vue.prototype.$notice = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> create(Notice, options)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件化&quot;&gt;&lt;a href=&quot;#组件化&quot; class=&quot;headerlink&quot; title=&quot;组件化&quot;&gt;&lt;/a&gt;组件化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; vue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界 面都可以抽
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Vue" scheme="http://blog.poetries.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3之Composition API详解</title>
    <link href="http://blog.poetries.top/2021/02/17/vue3-composition-api/"/>
    <id>http://blog.poetries.top/2021/02/17/vue3-composition-api/</id>
    <published>2021-02-17T12:12:12.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<p><code>Composition API</code>也叫组合式API，是Vue3.x的新特性。</p><blockquote><p>通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和灵活性方面走得更远。然而，我们的经验已经证明，光靠这一点可能是不够的，尤其是当你的应用程序变得非常大的时候——想想几百个组件。在处理如此大的应用程序时，共享和重用代码变得尤为重要</p></blockquote><p><strong>通俗的讲：</strong></p><p>没有<code>Composition API</code>之前vue相关业务的代码需要配置到option的特定的区域，中小型项目是没有问题的，但是在大型项目中会导致后期的维护性比较复杂，同时代码可复用性不高。Vue3.x中的composition-api就是为了解决这个问题而生的</p><p><strong>compositon api提供了以下几个函数：</strong></p><ul><li><code>setup</code></li><li><code>ref</code></li><li><code>reactive</code></li><li><code>watchEffect</code></li><li><code>watch</code></li><li><code>computed</code></li><li><code>toRefs</code></li><li>生命周期的<code>hooks</code></li></ul><h2 id="一、setup组件选项"><a href="#一、setup组件选项" class="headerlink" title="一、setup组件选项"></a>一、setup组件选项</h2><blockquote><p>新的 <code>setup</code> 组件选项在<strong>创建组件之前</strong>执行，一旦 <code>props</code> 被解析，并充当合成 <code>API</code> 的入口点</p></blockquote><p><strong>提示：</strong></p><blockquote><p>由于在执行 <code>setup</code> 时尚未创建组件实例，因此在 <code>setup</code> 选项中没有 <code>this</code>。这意味着，除了<code>props</code> 之外，你将无法访问组件中声明的任何属性——本地状态、计算属性或方法。</p></blockquote><p>使用 <code>setup</code> 函数时，它将接受两个参数：</p><ol><li><code>props</code></li><li><code>context</code></li></ol><p>让我们更深入地研究如何使用每个参数</p><h3 id="1-Props"><a href="#1-Props" class="headerlink" title="1. Props"></a>1. Props</h3><blockquote><p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 <code>prop</code> 时，它将被更新</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>但是，因为 <code>props</code> 是响应式的，你不能使用 <code>ES6</code> 解构，因为它会消除 <code>prop</code> 的响应性。</p></blockquote><p>如果需要解构 prop，可以通过使用 <code>setup</code> 函数中的 <a href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#响应式状态解构" target="_blank" rel="noopener"><code>toRefs</code></a> 来安全地完成此操作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">setup(props) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; title &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-上下文"><a href="#2-上下文" class="headerlink" title="2. 上下文"></a>2. 上下文</h3><blockquote><p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通的 JavaScript 对象，它暴露三个组件的 property</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    <span class="comment">// Attribute (非响应式对象)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插槽 (非响应式对象)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.slots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件 (方法)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>context</code> 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 ES6 解构</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup(props, &#123; attrs, slots, emit &#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 property。请注意，与 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 是<strong>非</strong>响应式的。如果你打算根据 <code>attrs</code> 或 <code>slots</code> 更改应用副作用，那么应该在 <code>onUpdated</code> 生命周期钩子中执行此操作。</p></blockquote><h3 id="3-setup组件的-property"><a href="#3-setup组件的-property" class="headerlink" title="3. setup组件的 property"></a>3. setup组件的 property</h3><blockquote><p>执行 <code>setup</code> 时，组件实例尚未被创建。因此，你只能访问以下 property：</p></blockquote><ul><li><code>props</code></li><li><code>attrs</code></li><li><code>slots</code></li><li><code>emit</code></li></ul><p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p><ul><li><code>data</code></li><li><code>computed</code></li><li><code>methods</code></li></ul><h3 id="4-ref-reactive-以及setup结合模板使用"><a href="#4-ref-reactive-以及setup结合模板使用" class="headerlink" title="4. ref reactive 以及setup结合模板使用"></a>4. ref reactive 以及setup结合模板使用</h3><p>在看<code>setup</code>结合模板使用之前，我们首先得知道<code>ref</code> 和 <code>reactive</code> 方法。</p><p>如果 <code>setup</code> 返回一个对象则可以在模板中绑定对象中的属性和方法，但是要定义响应式数据的时候可以使用<code>ref</code>, <code>reactive</code>方法定义响应式的数据</p><h5 id="错误写法："><a href="#错误写法：" class="headerlink" title="错误写法："></a><strong>错误写法：</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;button @click=<span class="string">"updateMsg"</span>&gt;改变etup中的msg&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;br&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">let</span> msg = <span class="string">"这是setup中的msg"</span>;</span><br><span class="line">        <span class="keyword">let</span> updateMsg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            alert(<span class="string">"触发方法"</span>)</span><br><span class="line">            msg = <span class="string">"改变后的值"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg,</span><br><span class="line">            updateMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="scss"&gt;</span></span><br><span class="line"><span class="regexp">.home &#123;</span></span><br><span class="line"><span class="regexp">    position: relative;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h5 id="正确写法一："><a href="#正确写法一：" class="headerlink" title="正确写法一："></a><strong>正确写法一：</strong></h5><blockquote><p> <strong>ref</strong>用来定义响应式的 字符串、 数值、 数组、<code>Bool</code>类型</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;  </span><br><span class="line">    ref</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button @click=<span class="string">"updateMsg"</span>&gt;改变etup中的msg&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;br&gt;</span></span><br><span class="line"><span class="regexp">&lt;br&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li v-for="(item,index) in list" :key="index"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;&#123;item&#125;&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;br&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line"></span><br><span class="line">    ref</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">let</span> msg = ref(<span class="string">"这是setup中的msg"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> list = ref([<span class="string">"马总"</span>, <span class="string">"李总"</span>, <span class="string">"刘总"</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> updateMsg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            alert(<span class="string">"触发方法"</span>);</span><br><span class="line">            msg.value = <span class="string">"改变后的值"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg,</span><br><span class="line">            list,</span><br><span class="line">            updateMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="scss"&gt;</span></span><br><span class="line"><span class="regexp">.home &#123;</span></span><br><span class="line"><span class="regexp">    position: relative;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h5 id="正确写法二："><a href="#正确写法二：" class="headerlink" title="正确写法二："></a><strong>正确写法二：</strong></h5><p><strong>reactive</strong> 用来定义响应式的对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    reactive   </span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateMsg"</span>&gt;</span>改变setup中的msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;&#123;setupData.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateTitle"</span>&gt;</span>更新setup中的title<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;</span></span><br><span class="line">    reactive,</span><br><span class="line">    ref</span><br><span class="line"><span class="javascript">&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> msg = ref(<span class="string">"这是setup中的msg"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> setupData = reactive(&#123;</span></span><br><span class="line"><span class="javascript">            title: <span class="string">"reactive定义响应式数据的title"</span>,</span></span><br><span class="line">            userinfo: &#123;</span><br><span class="line"><span class="javascript">                username: <span class="string">"张三"</span>,</span></span><br><span class="line">                age: 20</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> updateMsg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"触发方法"</span>);</span></span><br><span class="line"><span class="javascript">            msg.value = <span class="string">"改变后的值"</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> updateTitle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"触发方法"</span>);</span></span><br><span class="line"><span class="javascript">            setupData.title = <span class="string">"我是改变后的title"</span></span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            msg,</span><br><span class="line">            setupData,</span><br><span class="line">            updateMsg,</span><br><span class="line">            updateTitle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.home</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong>要改变ref定义的属性名称需要通过 <code>属性名称.value</code>来修改，要改变<code>reactive</code>中定义的对象名称可以直接</p><h3 id="5-使用-this"><a href="#5-使用-this" class="headerlink" title="5. 使用 this"></a>5. 使用 <code>this</code></h3><blockquote><p><strong>在 <code>setup()</code> 内部，<code>this</code> 不会是该活跃实例的引用</strong>，因为 <code>setup()</code> 是在解析其它组件选项之前被调用的，所以 <code>setup()</code> 内部的 <code>this</code> 的行为与其它选项中的 <code>this</code> 完全不同。这在和其它选项式 API 一起使用 <code>setup()</code> 时可能会导致混淆</p></blockquote><h2 id="二、toRefs-解构响应式对象数据"><a href="#二、toRefs-解构响应式对象数据" class="headerlink" title="二、toRefs - 解构响应式对象数据"></a>二、toRefs - 解构响应式对象数据</h2><blockquote><p>把一个响应式对象转换成普通对象，该普通对象的每个 <code>property</code> 都是一个 <code>ref</code> ，和响应式对象 <code>property</code> 一一对应</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;解构响应式对象数据&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;Username: &#123;&#123;username&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;Age: &#123;&#123;age&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import &#123;</span></span><br><span class="line"><span class="regexp">    reactive,</span></span><br><span class="line"><span class="regexp">    toRefs</span></span><br><span class="line"><span class="regexp">&#125; from "vue";</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    name: "解构响应式对象数据",</span></span><br><span class="line"><span class="regexp">    setup() &#123;</span></span><br><span class="line"><span class="regexp">        const user = reactive(&#123;</span></span><br><span class="line"><span class="regexp">            username: "张三",</span></span><br><span class="line"><span class="regexp">            age: 10000,</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">            ...toRefs(user)</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 <code>…</code>操作符）返回的对象，并不会丢失响应性：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFeatureX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 state 的逻辑操作</span></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回时将属性都转为 ref</span></span><br><span class="line">  <span class="keyword">return</span> toRefs(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// 可以解构，不会丢失响应性</span></span><br><span class="line">    <span class="keyword">const</span> &#123; foo, bar &#125; = useFeatureX()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo,</span><br><span class="line">      bar,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、computed-计算属性"><a href="#三、computed-计算属性" class="headerlink" title="三、computed - 计算属性"></a>三、computed - 计算属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;解构响应式对象数据+computed&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;input type="text" v-model="firstName" placeholder="firstName" /</span>&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"lastName"</span> placeholder=<span class="string">"lastName"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &#123;&#123;fullName&#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    toRefs,</span><br><span class="line">    computed</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"解构响应式对象数据"</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> user = reactive(&#123;</span><br><span class="line">            firstName: <span class="string">""</span>,</span><br><span class="line">            lastName: <span class="string">""</span>,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fullName = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> user.firstName + <span class="string">" "</span> + user.lastName</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...toRefs(user),</span><br><span class="line">            fullName</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、readonly-“深层”的只读代理"><a href="#四、readonly-“深层”的只读代理" class="headerlink" title="四、readonly “深层”的只读代理"></a>四、readonly “深层”的只读代理</h2><blockquote><p>传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;readonly - “深层”的只读代理&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;original.count: &#123;&#123;original.count&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;copy.count: &#123;&#123;copy.count&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import &#123; reactive, readonly &#125; from "vue";</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: "Readonly",</span></span><br><span class="line"><span class="regexp">  setup() &#123;</span></span><br><span class="line"><span class="regexp">    const original = reactive(&#123; count: 0 &#125;);</span></span><br><span class="line"><span class="regexp">    const copy = readonly(original);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      original.count++;</span></span><br><span class="line"><span class="regexp">      copy.count++; /</span><span class="regexp">/ 报警告，Set operation on key "count" failed: target is readonly. Proxy &#123;count: 1&#125;</span></span><br><span class="line"><span class="regexp">    &#125;, 1000);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return &#123; original, copy &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="五、watchEffect"><a href="#五、watchEffect" class="headerlink" title="五、watchEffect"></a>五、watchEffect</h2><blockquote><p>在响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watchEffect - 侦听器&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;&#123;&#123;data.count&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"stop"</span>&gt;手动关闭侦听器&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import &#123;</span></span><br><span class="line"><span class="regexp">    reactive,</span></span><br><span class="line"><span class="regexp">    watchEffect</span></span><br><span class="line"><span class="regexp">&#125; from "vue";</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    name: "WatchEffect",</span></span><br><span class="line"><span class="regexp">    setup() &#123;</span></span><br><span class="line"><span class="regexp">        const data = reactive(&#123;</span></span><br><span class="line"><span class="regexp">            count: 1,</span></span><br><span class="line"><span class="regexp">            num: 1</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp">        const stop = watchEffect(() =&gt; console.log(`侦听器：$&#123;data.count&#125;`));</span></span><br><span class="line"><span class="regexp">        setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            data.count++;</span></span><br><span class="line"><span class="regexp">        &#125;, 1000);</span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">            data,</span></span><br><span class="line"><span class="regexp">            stop</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="六、watch-、watch-与watchEffect区别"><a href="#六、watch-、watch-与watchEffect区别" class="headerlink" title="六、watch 、watch 与watchEffect区别"></a>六、watch 、watch 与watchEffect区别</h2><p>对比<code>watchEffect</code>，<strong><code>watch</code>允许我们</strong>：</p><ul><li>懒执行，也就是说仅在侦听的源变更时才执行回调；</li><li>更明确哪些状态的改变会触发侦听器重新运行；</li><li>访问侦听状态变化前后的值</li></ul><p><strong>更明确哪些状态的改变会触发侦听器重新运行</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;count1: &#123;&#123;data.count1&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;count2: &#123;&#123;data.count2&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="stopAll"&gt;Stop All&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    watch</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"Watch"</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">            count1: <span class="number">0</span>,</span><br><span class="line">            count2: <span class="number">0</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 侦听单个数据源</span></span><br><span class="line">        <span class="keyword">const</span> stop1 = watch(data, () =&gt;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"watch1"</span>, data.count1, data.count2)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 侦听多个数据源</span></span><br><span class="line">        <span class="keyword">const</span> stop2 = watch([data], () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"watch2"</span>, data.count1, data.count2);</span><br><span class="line">        &#125;);</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            data.count1++;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            data,</span><br><span class="line">            stopAll: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                stop1();</span><br><span class="line">                stop2();</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong>访问侦听状态变化前后的值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="text" v-model="keywords" /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    ref,</span><br><span class="line">    watch</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">"Watch"</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">let</span> keywords = ref(<span class="string">"111"</span>);</span><br><span class="line">        <span class="comment">// 侦听单个数据源</span></span><br><span class="line">        watch(keywords, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            keywords</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong>懒执行，也就是说仅在侦听的源变更时才执行回调</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;num1=&#123;&#123;num1&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;num2=&#123;&#123;num2&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import &#123;</span></span><br><span class="line"><span class="regexp">    ref,</span></span><br><span class="line"><span class="regexp">    watch,</span></span><br><span class="line"><span class="regexp">    watchEffect</span></span><br><span class="line"><span class="regexp">&#125; from "vue";</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    name: "Watch",</span></span><br><span class="line"><span class="regexp">    setup() &#123;</span></span><br><span class="line"><span class="regexp">        let num1 = ref(10);</span></span><br><span class="line"><span class="regexp">        let num2 = ref(10);</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 侦听单个数据源</span></span><br><span class="line"><span class="regexp">        watch(num1, (newValue, oldValue) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            console.log(newValue, oldValue)</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        watchEffect(() =&gt; console.log(`watchEffect侦听器：$&#123;num2.value&#125;`));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">            num1,</span></span><br><span class="line"><span class="regexp">            num2</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="七、组合式api生命周期钩子"><a href="#七、组合式api生命周期钩子" class="headerlink" title="七、组合式api生命周期钩子"></a>七、组合式api生命周期钩子</h2><p>你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。</p><p>下表包含如何在 <a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html" target="_blank" rel="noopener">setup ()</a> 内部调用生命周期钩子：</p><table><thead><tr><th style="text-align:left">选项式 API</th><th style="text-align:left">Hook inside <code>setup</code></th></tr></thead><tbody><tr><td style="text-align:left"><code>beforeCreate</code></td><td style="text-align:left">不需要*</td></tr><tr><td style="text-align:left"><code>created</code></td><td style="text-align:left">不需要*</td></tr><tr><td style="text-align:left"><code>beforeMount</code></td><td style="text-align:left"><code>onBeforeMount</code></td></tr><tr><td style="text-align:left"><code>mounted</code></td><td style="text-align:left"><code>onMounted</code></td></tr><tr><td style="text-align:left"><code>beforeUpdate</code></td><td style="text-align:left"><code>onBeforeUpdate</code></td></tr><tr><td style="text-align:left"><code>updated</code></td><td style="text-align:left"><code>onUpdated</code></td></tr><tr><td style="text-align:left"><code>beforeUnmount</code></td><td style="text-align:left"><code>onBeforeUnmount</code></td></tr><tr><td style="text-align:left"><code>unmounted</code></td><td style="text-align:left"><code>onUnmounted</code></td></tr><tr><td style="text-align:left"><code>errorCaptured</code></td><td style="text-align:left"><code>onErrorCaptured</code></td></tr><tr><td style="text-align:left"><code>renderTracked</code></td><td style="text-align:left"><code>onRenderTracked</code></td></tr><tr><td style="text-align:left"><code>renderTriggered</code></td><td style="text-align:left"><code>onRenderTriggered</code></td></tr></tbody></table><blockquote><p>因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// mounted</span></span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Component is mounted!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、Provider-Inject"><a href="#八、Provider-Inject" class="headerlink" title="八、Provider Inject"></a>八、Provider Inject</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用 <a href="https://v3.cn.vuejs.org/guide/component-props.html" target="_blank" rel="noopener">props</a>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人</p><blockquote><p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据</p></blockquote><h3 id="1-非组合式api中的写法"><a href="#1-非组合式api中的写法" class="headerlink" title="1. 非组合式api中的写法"></a>1. <strong>非组合式api中的写法</strong></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/components/MyMap.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MyMarker</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> MyMarker <span class="keyword">from</span> <span class="string">'./MyMarker.vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    MyMarker</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line"><span class="javascript">    location: <span class="string">'North Pole'</span>,</span></span><br><span class="line">    geolocation: &#123;</span><br><span class="line">      longitude: 90,</span><br><span class="line">      latitude: 135</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- src/components/MyMarker.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  inject: [<span class="string">'location'</span>, <span class="string">'geolocation'</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-组合式api中的写法"><a href="#2-组合式api中的写法" class="headerlink" title="2. 组合式api中的写法"></a>2. <strong>组合式api中的写法</strong></h3><h5 id="Provider："><a href="#Provider：" class="headerlink" title="Provider："></a>Provider：</h5><blockquote><p>在 <code>setup()</code> 中使用 <code>provide</code> 时，我们首先从 <code>vue</code> 显式导入 <code>provide</code> 方法。这使我们能够调用 <code>provide</code> 时来定义每个 <code>property</code></p></blockquote><p><code>provide</code> 函数允许你通过两个参数定义 <code>property</code>：</p><ol><li><code>property</code> 的 <code>name</code> (<code>&lt;String&gt;</code> 类型)</li><li><code>property</code> 的 <code>value</code></li></ol><p>使用 <code>MyMap</code> 组件，我们提供的值可以按如下方式重构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/components/MyMap.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MyMarker</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> MyMarker <span class="keyword">from</span> <span class="string">'./MyMarker.vue</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    MyMarker</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line"><span class="javascript">    provide(<span class="string">'location'</span>, <span class="string">'North Pole'</span>)</span></span><br><span class="line"><span class="javascript">    provide(<span class="string">'geolocation'</span>, &#123;</span></span><br><span class="line">      longitude: 90,</span><br><span class="line">      latitude: 135</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Inject"><a href="#Inject" class="headerlink" title="Inject:"></a>Inject:</h5><blockquote><p>在 <code>setup()</code> 中使用 <code>inject</code> 时，还需要从 <code>vue</code> 显式导入它。一旦我们这样做了，我们就可以调用它来定义如何将它暴露给我们的组件。</p></blockquote><p><code>inject</code> 函数有两个参数：</p><ol><li>要注入的 <code>property</code> 的名称</li><li>一个默认的值 (<strong>可选</strong>)</li></ol><p>使用 <code>MyMarker</code> 组件，可以使用以下代码对其进行重构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/components/MyMarker.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  setup() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> userLocation = inject(<span class="string">'location'</span>, <span class="string">'The Universe'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> userGeolocation = inject(<span class="string">'geolocation'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      userLocation,</span><br><span class="line">      userGeolocation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Provider Inject 响应性</strong></p><p><strong>父组件：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    provide,</span><br><span class="line">    ref,</span><br><span class="line">    reactive</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> location = ref(<span class="string">'北京'</span>)</span><br><span class="line">        <span class="keyword">const</span> geolocation = reactive(&#123;</span><br><span class="line">            longitude: <span class="number">90</span>,</span><br><span class="line">            latitude: <span class="number">135</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> updateLocation = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            location.value = <span class="string">'上海'</span></span><br><span class="line">        &#125;</span><br><span class="line">        provide(<span class="string">'location'</span>, location);</span><br><span class="line">        provide(<span class="string">'geolocation'</span>, geolocation);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            updateLocation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateLocation"</span>&gt;</span>改变location<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>子组件：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> userLocation = inject(<span class="string">'location'</span>, <span class="string">'The Universe'</span>)</span><br><span class="line">    <span class="keyword">const</span> userGeolocation = inject(<span class="string">'geolocation'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      userLocation,</span><br><span class="line">      userGeolocation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Composition API&lt;/code&gt;也叫组合式API，是Vue3.x的新特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和灵活性方面
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Vue" scheme="http://blog.poetries.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3基础小结</title>
    <link href="http://blog.poetries.top/2021/02/16/vue3-base/"/>
    <id>http://blog.poetries.top/2021/02/16/vue3-base/</id>
    <published>2021-02-16T08:12:12.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、vue环境搭建"><a href="#一、vue环境搭建" class="headerlink" title="一、vue环境搭建"></a>一、vue环境搭建</h1><h2 id="安装Vue官方脚手架以及创建项目"><a href="#安装Vue官方脚手架以及创建项目" class="headerlink" title="安装Vue官方脚手架以及创建项目"></a>安装Vue官方脚手架以及创建项目</h2><p><strong>注意:</strong>    安装脚手架创建项目之前之前，我们的电脑上必须得安装Nodejs，推荐安装nodejs稳定版本</p><p><strong>文档地址：</strong> <a href="https://v3.vuejs.org/guide/installation.html#cli" target="_blank" rel="noopener">https://v3.vuejs.org/guide/installation.html#cli</a></p><p><strong>Vue-cli地址：</strong> <a href="https://cli.vuejs.org/" target="_blank" rel="noopener">https://cli.vuejs.org/</a></p><p><strong>Vite地址：</strong> <a href="https://github.com/vitejs/vite" target="_blank" rel="noopener">https://github.com/vitejs/vite</a></p><p>通过Vue-cli脚手架工具可以让我们快速的搭建vue项目，目前Vue官方给我们提供了2个脚手架，Vue-cli和Vite。</p><h2 id="通过Vue-cli创建我们的项目"><a href="#通过Vue-cli创建我们的项目" class="headerlink" title="通过Vue-cli创建我们的项目"></a>通过Vue-cli创建我们的项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br><span class="line"># OR</span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"># OR</span><br><span class="line">cnpm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>如果电脑上面没有安装过cnpm可以通过下面命令安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>如果电脑上面没有安装过yarn可以通过下面命令安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g yarn</span><br></pre></td></tr></table></figure><p>创建项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create hello-vue3</span><br><span class="line"></span><br><span class="line">yarn serve</span><br></pre></td></tr></table></figure><h2 id="通过Vite脚手架创建我们的项目"><a href="#通过Vite脚手架创建我们的项目" class="headerlink" title="通过Vite脚手架创建我们的项目"></a>通过Vite脚手架创建我们的项目</h2><p><strong>1. 使用npm创建</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><strong>2. 使用yarn创建</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn create vite-app &lt;project-name&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="http://img-repo.poetries.top/images/image-20210217182003600.png" alt="image-20210217182003600"></p><h3 id="开发工具以及插件配置"><a href="#开发工具以及插件配置" class="headerlink" title="开发工具以及插件配置"></a>开发工具以及插件配置</h3><p><img src="http://img-repo.poetries.top/images/image-20210217182033814.png" alt="image-20210217182033814"></p><h1 id="二、父组件给子组件传值、Props验证、单向数据流"><a href="#二、父组件给子组件传值、Props验证、单向数据流" class="headerlink" title="二、父组件给子组件传值、Props验证、单向数据流"></a>二、父组件给子组件传值、Props验证、单向数据流</h1><h2 id="父子组件介绍"><a href="#父子组件介绍" class="headerlink" title="父子组件介绍"></a>父子组件介绍</h2><p><img src="http://img-repo.poetries.top/images/image-20210217182834168.png" alt="image-20210217182834168"></p><h2 id="父组件给子组件传值"><a href="#父组件给子组件传值" class="headerlink" title="父组件给子组件传值"></a>父组件给子组件传值</h2><h3 id="父组件调用子组件的时候传值"><a href="#父组件调用子组件的时候传值" class="headerlink" title="父组件调用子组件的时候传值"></a>父组件调用子组件的时候传值</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v-header</span> <span class="attr">:title</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">v-header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./Header'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            title: <span class="string">"首页组件title"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,  </span><br><span class="line">    components: &#123;</span><br><span class="line"><span class="javascript">        <span class="string">"v-header"</span>: Header</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件接收父组件传值"><a href="#子组件接收父组件传值" class="headerlink" title="子组件接收父组件传值"></a>子组件接收父组件传值</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">"title"</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Props验证"><a href="#Props验证" class="headerlink" title="Props验证"></a>Props验证</h2><blockquote><p>我们可以为组件的 <code>prop</code> 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 <code>Vue</code> 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助</p></blockquote><p><strong>props验证：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">   <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">   propA: <span class="built_in">Number</span>,</span><br><span class="line">   <span class="comment">// 多个可能的类型</span></span><br><span class="line">   propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">   <span class="comment">// 必填的字符串</span></span><br><span class="line">   propC: &#123;</span><br><span class="line">     type: <span class="built_in">String</span>,</span><br><span class="line">     required: <span class="literal">true</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">// 带有默认值的数字</span></span><br><span class="line">   propD: &#123;</span><br><span class="line">     type: <span class="built_in">Number</span>,</span><br><span class="line">     <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">// 带有默认值的对象</span></span><br><span class="line">   propE: &#123;</span><br><span class="line">     type: <span class="built_in">Object</span>,</span><br><span class="line">     <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">     <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">// 自定义验证函数</span></span><br><span class="line">   propF: &#123;</span><br><span class="line">     validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">       <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">// 具有默认值的函数</span></span><br><span class="line">   propG: &#123;</span><br><span class="line">     type: <span class="built_in">Function</span>,</span><br><span class="line">     <span class="comment">// 与对象或数组默认值不同，这不是一个工厂函数 —— 这是一个用作默认值的函数</span></span><br><span class="line">     <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'Default function'</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>另外，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><h2 id="父组件主动获取子组件的数据和执行子组件方法"><a href="#父组件主动获取子组件的数据和执行子组件方法" class="headerlink" title="父组件主动获取子组件的数据和执行子组件方法"></a>父组件主动获取子组件的数据和执行子组件方法</h2><h3 id="调用子组件的时候定义一个ref"><a href="#调用子组件的时候定义一个ref" class="headerlink" title="调用子组件的时候定义一个ref"></a>调用子组件的时候定义一个ref</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v-header</span> <span class="attr">ref</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">v-header</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父组件主动获取子组件数据"><a href="#父组件主动获取子组件数据" class="headerlink" title="父组件主动获取子组件数据"></a>父组件主动获取子组件数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.header.属性</span><br></pre></td></tr></table></figure><h3 id="父组件主动执行子组件方法"><a href="#父组件主动执行子组件方法" class="headerlink" title="父组件主动执行子组件方法"></a>父组件主动执行子组件方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.header.方法</span><br></pre></td></tr></table></figure><h2 id="子组件主动获取父组件的数据和执行父组件方法"><a href="#子组件主动获取父组件的数据和执行父组件方法" class="headerlink" title="子组件主动获取父组件的数据和执行父组件方法"></a>子组件主动获取父组件的数据和执行父组件方法</h2><h3 id="子组件主动获取父组件的数据"><a href="#子组件主动获取父组件的数据" class="headerlink" title="子组件主动获取父组件的数据"></a>子组件主动获取父组件的数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$parent.数据</span><br></pre></td></tr></table></figure><h3 id="子组件主动获取父组件的数据-1"><a href="#子组件主动获取父组件的数据-1" class="headerlink" title="子组件主动获取父组件的数据"></a>子组件主动获取父组件的数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$parent.方法</span><br></pre></td></tr></table></figure><h1 id="三、组件的生命周期函数、-this-nextTick、动态组件-keep-alive"><a href="#三、组件的生命周期函数、-this-nextTick、动态组件-keep-alive" class="headerlink" title="三、组件的生命周期函数、 this.$nextTick、动态组件 keep-alive"></a>三、组件的生命周期函数、 this.$nextTick、动态组件 keep-alive</h1><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p><img src="http://bbs.itying.com/public/upload/02e3b550-2d3b-11eb-8ac2-41a88e51bce8.png" alt="img"></p><table><thead><tr><th style="text-align:left">Vue2</th><th style="text-align:left">Vue3</th></tr></thead><tbody><tr><td style="text-align:left">beforeCreate</td><td style="text-align:left">❌setup(替代)</td></tr><tr><td style="text-align:left">created</td><td style="text-align:left">❌setup(替代)</td></tr><tr><td style="text-align:left">beforeMount</td><td style="text-align:left">onBeforeMount</td></tr><tr><td style="text-align:left">mounted</td><td style="text-align:left">onMounted</td></tr><tr><td style="text-align:left">beforeUpdate</td><td style="text-align:left">onBeforeUpdate</td></tr><tr><td style="text-align:left">updated</td><td style="text-align:left">onUpdated</td></tr><tr><td style="text-align:left">beforeDestroy</td><td style="text-align:left">onBeforeUnmount</td></tr><tr><td style="text-align:left">destroyed</td><td style="text-align:left">onUnmounted</td></tr><tr><td style="text-align:left">errorCaptured</td><td style="text-align:left">onErrorCaptured</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">🎉onRenderTracked</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">🎉onRenderTriggered</td></tr></tbody></table><p><strong>setup中调用生命周期钩子</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onBeforeMount,onMounted &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    onBeforeMount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Before Mount!'</span>)</span><br><span class="line">    &#125;) </span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Before Mount!'</span>)</span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态组件-keep-alive"><a href="#动态组件-keep-alive" class="headerlink" title="动态组件 keep-alive"></a>动态组件 keep-alive</h2><ul><li>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题，这个时候就用用<code>keep-alive</code></li><li>在不同路由切换的时候想保持组件的状态也可以使用<code>keep-alive</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">       &lt;life-cycle v-<span class="keyword">if</span>=<span class="string">"isShow"</span>&gt;&lt;<span class="regexp">/life-cycle&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>keep-alive&gt;</span><br></pre></td></tr></table></figure><h2 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick"></a>this.$nextTick</h2><blockquote><p>Vue中可以把获取Dom节点的代码放在<code>mounted</code>里面，但是如果要在渲染完成数据后获取DOM节点就需要用到<code>this.$nextTick</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">     <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 仅在渲染整个视图之后运行的代码</span></span><br><span class="line">     &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">      </span><br><span class="line">       <span class="keyword">var</span> oDiv1 = <span class="built_in">document</span>.querySelector(<span class="string">"#msg"</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"1-"</span> + oDiv1.innerHTML);</span><br><span class="line">       <span class="keyword">this</span>.msg = <span class="string">"$nextTick演示"</span>;</span><br><span class="line">       <span class="keyword">var</span> oDiv2 = <span class="built_in">document</span>.querySelector(<span class="string">"#msg"</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"2-"</span> + oDiv2.innerHTML);</span><br><span class="line">       <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="comment">// 仅在渲染整个视图之后运行的代码</span></span><br><span class="line">           <span class="keyword">var</span> oDiv3 = <span class="built_in">document</span>.querySelector(<span class="string">"#msg"</span>);</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"3-"</span> + oDiv3.innerHTML);</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h1 id="四、Mixin实现组件功能的复用"><a href="#四、Mixin实现组件功能的复用" class="headerlink" title="四、Mixin实现组件功能的复用"></a><strong>四、Mixin实现组件功能的复用</strong></h1><h2 id="mixin介绍使用"><a href="#mixin介绍使用" class="headerlink" title="mixin介绍使用"></a>mixin介绍使用</h2><blockquote><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项</p></blockquote><h3 id="新建mixin-base-js"><a href="#新建mixin-base-js" class="headerlink" title="新建mixin/base.js"></a><strong>新建mixin/base.js</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> baseMixin = &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">       <span class="keyword">return</span>&#123;</span><br><span class="line">            apiDomain: <span class="string">"http://www.itying.com"</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        success() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'succss'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        error() &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'error'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> baseMixin;</span><br></pre></td></tr></table></figure><h3 id="使用mixin"><a href="#使用mixin" class="headerlink" title="使用mixin"></a><strong>使用mixin</strong></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    首页模板--&#123;&#123;apiDomain&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> BaseMixin <span class="keyword">from</span> <span class="string">'../mixin/base'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    mixins: [BaseMixin],</span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="关于Mixin的选项合并"><a href="#关于Mixin的选项合并" class="headerlink" title="关于Mixin的选项合并"></a>关于Mixin的选项合并</h2><blockquote><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”</p></blockquote><p><strong>1. 数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span>,</span><br><span class="line">      foo: <span class="string">'abc'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  mixins: [myMixin],</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'goodbye'</span>,</span><br><span class="line">      bar: <span class="string">'def'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data) <span class="comment">// =&gt; &#123; message: "goodbye", foo: "abc", bar: "def" &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>2. 同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mixin hook called'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  mixins: [myMixin],</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'component hook called'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; "混入对象的钩子被调用"</span></span><br><span class="line"><span class="comment">// =&gt; "组件钩子被调用"</span></span><br></pre></td></tr></table></figure><p><strong>3. 值为对象的选项，例如 <code>methods</code>、<code>components</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    conflicting() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'from mixin'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  mixins: [myMixin],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    bar() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    conflicting() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'from self'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = app.mount(<span class="string">'#mixins-basic'</span>)</span><br><span class="line"></span><br><span class="line">vm.foo() <span class="comment">// =&gt; "foo"</span></span><br><span class="line">vm.bar() <span class="comment">// =&gt; "bar"</span></span><br><span class="line">vm.conflicting() <span class="comment">// =&gt; "from self"</span></span><br></pre></td></tr></table></figure><h2 id="全局配置Mixin"><a href="#全局配置Mixin" class="headerlink" title="全局配置Mixin"></a>全局配置Mixin</h2><p>你还可以为 Vue 应用程序全局应用 mixin</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  myOption: <span class="string">'hello!'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义的选项 'myOption' 注入一个处理器。</span></span><br><span class="line">app.mixin(&#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">const</span> myOption = <span class="keyword">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#mixins-global'</span>) <span class="comment">// =&gt; "hello!"</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> BaseMixin <span class="keyword">from</span> <span class="string">'./mixin/base'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原来的代码</span></span><br><span class="line"><span class="comment">// createApp(App).mount('#app')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后的代码</span></span><br><span class="line"><span class="keyword">const</span> app=createApp(App);</span><br><span class="line"></span><br><span class="line">app.mixin(BaseMixin)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><h1 id="五、使用Teleport自定义一个模态对话框的组件"><a href="#五、使用Teleport自定义一个模态对话框的组件" class="headerlink" title="五、使用Teleport自定义一个模态对话框的组件"></a>五、使用Teleport自定义一个模态对话框的组件</h1><h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><blockquote><p>Vue3.x中的组件模板属于该组件，有时候我们想把模板的内容移动到当前组件之外的DOM 中，这个时候就可以使用 Teleport。</p></blockquote><p>表示<code>teleport</code>内包含的内容显示到<code>body</code>中</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"body"</span>&gt;</span></span><br><span class="line">内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"#app"</span>&gt;</span></span><br><span class="line">内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用Teleport实现一个模态对话框的组件"><a href="#使用Teleport实现一个模态对话框的组件" class="headerlink" title="使用Teleport实现一个模态对话框的组件"></a>使用Teleport实现一个模态对话框的组件</h2><p><strong>Modal.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"model-bg"</span> <span class="attr">v-show</span>=<span class="string">"visible"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"close"</span> @<span class="attr">click</span>=<span class="string">"$emit('close-model')"</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"model-title"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"model-body"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">                    第一个对话框</span><br><span class="line">                <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">"title"</span>, <span class="string">"visible"</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.model-bg</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">opacity</span>: 0<span class="selector-class">.7</span>;</span></span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.modal-content</span> &#123;</span></span><br><span class="line">    width: 600px;</span><br><span class="line">    min-height: 300px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#eee</span>;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.model-title</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#eee</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">        height: 32px;</span><br><span class="line">        line-height: 32px;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.model-body</span> &#123;</span></span><br><span class="line">        padding: 40px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.close</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        right: 10px;</span><br><span class="line">        top: 5px;</span><br><span class="line">        padding: 5px;</span><br><span class="line">        border: none;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Home.vue</code>使用<code>model</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"home"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"isVisible=true"</span>&gt;</span>弹出一个模态对话框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modal</span> <span class="attr">:visible</span>=<span class="string">"isVisible"</span> <span class="attr">title</span>=<span class="string">"用户登录"</span> @<span class="attr">close-model</span>=<span class="string">"isVisible=false"</span>&gt;</span><span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Modal <span class="keyword">from</span> <span class="string">"./Modal"</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            isVisible: <span class="literal">false</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Modal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.home</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、vue环境搭建&quot;&gt;&lt;a href=&quot;#一、vue环境搭建&quot; class=&quot;headerlink&quot; title=&quot;一、vue环境搭建&quot;&gt;&lt;/a&gt;一、vue环境搭建&lt;/h1&gt;&lt;h2 id=&quot;安装Vue官方脚手架以及创建项目&quot;&gt;&lt;a href=&quot;#安装Vue官方脚手
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Vue" scheme="http://blog.poetries.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>异步编程入门之RxJs（一）</title>
    <link href="http://blog.poetries.top/2021/02/08/rxjs-summary/"/>
    <id>http://blog.poetries.top/2021/02/08/rxjs-summary/</id>
    <published>2021-02-08T12:10:43.000Z</published>
    <updated>2021-05-11T03:46:23.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-1-Promise缺点"><a href="#1-1-Promise缺点" class="headerlink" title="1.1 Promise缺点"></a>1.1 Promise缺点</h2><ul><li><code>Promise</code> 的特点是无论有没有人关心它的执行结果，它都会立即开始执行，并且你没有机会取消这次执行。显然，在某些情况下这么做是浪费的甚至错误的</li><li>以电商为例，如果某商户的订单不允许取消，你还会去买吗？</li><li>如果你发起了一个 <code>Ajax</code> 请求，然后用户导航到了另一个路由，显然，你这个请求如果还没有完成就应该被取消，而不应该发出去</li><li>使用 <code>Promise</code>，你做不到，不是因为实现方面的原因，而是因为它在概念层（接口定义上）就无法支持取消</li><li>由于 <code>Promise</code> 只会承载一个值，因此当我们要处理的是一个集合的时候就比较困难了。比如对于一个随机数列（总数未知），如果我们要借助 <code>Web API</code> 检查每个数字的有效性，然后对前一百个有效数字进行求和，那么用 <code>Promise</code> 写就比较麻烦了</li></ul><h2 id="1-2-Observable"><a href="#1-2-Observable" class="headerlink" title="1.2 Observable"></a>1.2 Observable</h2><ul><li>它就是可观察对象，<code>Observable</code> 顾名思义就是可以被别人观察的对象，当它变化时，观察者就可以得到通知。换句话说，它负责生产数据，别人可以消费它生产的数据</li><li><code>Observable</code> 就像个传送带。这个传送带不断运行，围绕这个传送带建立了一条生产线，包括一系列工序，不同的工序承担单一而确定的职责。每个工位上有一个工人</li><li>整个传送带的起点是原料箱，原料箱中的原料不断被放到传送带上。工人只需要待在自己的工位上，对面前的原料进行加工，然后放回传送带上或放到另一条传送带上即可，简单、高效、无意外 </li></ul><h2 id="1-3-ReactiveX宝石图"><a href="#1-3-ReactiveX宝石图" class="headerlink" title="1.3 ReactiveX宝石图"></a>1.3 ReactiveX宝石图</h2><p><img src="http://img-repo.poetries.top/images/image-20210208204624236.png" alt="image-20210208204624236"></p><ul><li>中间的带箭头的线就像传送带，用来表示数据序列，这个数据序列被称为“流”。上方的流叫做输入流，下方的流叫做输出流。输入流可能有多个，但是输出流只会有一个（不过，流中的每个数据项也可以是别的流）</li><li>数据序列上的每个圆圈表示一个数据项，圆圈的位置表示数据出现的先后顺序，但是一般不会表示精确的时间比例，比如在一毫秒内接连出现的两个数据之间仍然会有较大的距离。只有少数涉及到时间的操作，其宝石图才会表现出精确的时间比例</li><li>圆圈的最后，通常会有一条竖线或者一个叉号。竖线表示这个流正常终止了，也就是说不会再有更多的数据提供出来了。而叉号表示这个流抛出错误导致异常中止了。还有一种流，既没有竖线也没有叉号，这种叫做无尽流，比如一个由所有自然数组成的流就不会主动终止。但是要注意，无尽流仍然是可以处理的，因为需要多少项是由消费者决定的。你可以把这个“智能”传送带理解为由下一个工位“叫号”的，没“叫号”下一项数据就不会过来</li><li>中间的大方框表示一个操作，也就是 operator —— 一个函数，比如这个图中的操作就是把输入流中的条目乘以十后放入输出流中。</li><li>看懂了宝石图，就能很形象的理解各种操作符了</li></ul><h1 id="二、Rxjs介绍"><a href="#二、Rxjs介绍" class="headerlink" title="二、Rxjs介绍"></a>二、Rxjs介绍</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><blockquote><ul><li><code>RxJS</code> 是 <code>ReactiveX</code> 编程理念的 <code>JavaScript</code> 版本。<code>ReactiveX</code> 来自微软，它是一种针对异步数据 流的编程。简单来说，它将一切数据，包括 <code>HTTP</code> 请求，<code>DOM</code> 事件或者普通数据等包装成流的形式，然后用强大丰富的操作符对流进行处理，使你能以同步编程的方式处理异步数据，并组合不同的操作符来轻松优雅的实现你所需要的功能</li><li><code>RxJS</code> 是一种针对异步数据流编程工具，或者叫响应式扩展编程;可不管如何解释 <code>RxJS</code> 其目 标就是异步编程，<code>Angular</code> 引入 <code>RxJS</code> 为了就是让异步可控、更简单。</li></ul></blockquote><p><strong>目前常见的异步编程的几种方法:</strong></p><ul><li>回调函数</li><li>事件监听/发布订阅</li><li><code>Promise</code></li><li><code>Rxjs</code></li></ul><h2 id="2-2-Promise和RxJS处理异步对比"><a href="#2-2-Promise和RxJS处理异步对比" class="headerlink" title="2.2 Promise和RxJS处理异步对比"></a>2.2 Promise和RxJS处理异步对比</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise异步处理</span></span><br><span class="line"><span class="comment">// Promise 处理异步</span></span><br><span class="line">  getPromiseData() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve = &gt;&#123;</span><br><span class="line">    setTimeout(() = &gt;&#123;</span><br><span class="line">        resolve(<span class="string">'---promise timeout---'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line">getPromiseData().then(<span class="function"><span class="params">d</span>=&gt;</span><span class="built_in">console</span>.log(d))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RxJS 处理异步:</span></span><br><span class="line">getRxjsData() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Observable(observer = &gt;&#123;</span><br><span class="line">      setTimeout(() = &gt;&#123;</span><br><span class="line">        observer.next(<span class="string">'observable timeout'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="number">2000</span>);</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">getRxjsData().subscribe(<span class="function"><span class="params">d</span>=&gt;</span><span class="built_in">console</span>.log(d))</span><br></pre></td></tr></table></figure><blockquote><p>从上面列子可以看到 <code>RxJS</code> 和 <code>Promise</code>的基本用法非常类似，除了一些关键词不同。<code>Promise</code> 里面用的是 <code>then()</code> 和 <code>resolve()</code>，而 <code>RxJS</code>里面用的是 <code>next()</code> 和 <code>subscribe()</code><br><code>Rxjs</code>相比<code>Promise</code>要强大很多。 比如 <code>Rxjs</code> 中可以中途撤回、<code>Rxjs</code> 可以发射多个值、<code>Rxjs</code> 提供了多种工具函数等等</p></blockquote><h2 id="2-3-Rxjs基本概念"><a href="#2-3-Rxjs基本概念" class="headerlink" title="2.3 Rxjs基本概念"></a>2.3 Rxjs基本概念</h2><ul><li><code>Observable</code> (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li><li><code>Observer</code> (观察者): 一个回调函数的集合，它知道如何去监听由 <code>Observable</code> 提供的值。</li><li><code>Subscription</code> (订阅): 表示 <code>Observable</code> 的执行，主要用于取消 <code>Observable</code> 的执行。</li><li><code>Operators</code> (操作符): 采用函数式编程风格的纯函数 (<code>pure function</code>)，使用像 <code>map</code>、<code>filter</code>、<code>concat</code>、<code>flatMap</code> 等这样的操作符来处理集合。<br><code>Subject</code> (主体): 相当于 <code>EventEmitter</code>，并且是将值或事件多路推送给多个 <code>Observer</code> 的唯一方式。</li><li><code>Schedulers</code> (调度器):用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 或其他</li></ul><h2 id="2-4-Rxjs使用场景"><a href="#2-4-Rxjs使用场景" class="headerlink" title="2.4 Rxjs使用场景"></a>2.4 Rxjs使用场景</h2><ul><li>涉及复杂的时序操作：在游戏的某一关卡中，连续按下上上下下左右左右baba，每次点按间隔不超过0.4ms，就发送信息到服务器<code>A</code></li><li>涉及复杂的条件处理：用户输入时，每输入一个字符，发送信息给服务器<code>A</code>，如果服务器<code>A</code>返回的数据有问题，则请求服务器<code>B</code>，如果用户输入’fuck’则停止上述操作并请求服务器<code>c</code></li><li>涉及复杂的状态管理：早上的时候每隔<code>10</code>秒检查一次用户信息，晚上的时候每隔5秒检查一次用户信息，检测到变更后响应式更新所有视图</li><li>真要用<code>Rx</code>建议还是<code>Angular</code>环境下</li></ul><h1 id="三、基础入门"><a href="#三、基础入门" class="headerlink" title="三、基础入门"></a>三、基础入门</h1><h2 id="3-1-典型的写法"><a href="#3-1-典型的写法" class="headerlink" title="3.1 典型的写法"></a>3.1 典型的写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).pipe(</span><br><span class="line">  filter(<span class="function"><span class="params">item</span>=&gt;</span>item % <span class="number">2</span> === <span class="number">1</span>),</span><br><span class="line">  map(<span class="function"><span class="params">item</span>=&gt;</span>item * <span class="number">3</span>),</span><br><span class="line">).subscribe(<span class="function"><span class="params">item</span>=&gt;</span> <span class="built_in">console</span>.log(item))</span><br></pre></td></tr></table></figure><ul><li><code>of</code> 称为创建器，用来创建流，它返回一个 <code>Observable</code> 类型的对象，<code>filter</code> 和 map 称为操作符（<code>operator</code>），用来对条目进行处理。这些操作符被当作 <code>Observable</code> 对象的 <code>pipe</code> 方法的参数传进去</li><li><code>Observable</code> 对象的 <code>subscribe</code> 方法表示消费者要订阅这个流，当流中出现数据时，传给 <code>subscribe</code> 方法的回调函数就会被调用，并且把这个数据传进去。这个回调函数可能被调用很多次，取决于这个流中有多少条数据</li><li>注意，<code>Observable</code> 必须被 <code>subscribe</code> 之后才会开始生产数据。如果没人 <code>subscribe</code> 它，那就什么都不会做</li></ul><h2 id="3-2-简单创建器"><a href="#3-2-简单创建器" class="headerlink" title="3.2 简单创建器"></a>3.2 简单创建器</h2><ul><li>广义上，创建器也是操作符的一种，不过这里我们把它单独拿出来讲。要启动生产线，我们得先提供原料。本质上，这个提供者就是一组函数，当流水线需要拿新的原料时，就会调用它</li><li>你当然可以自己实现这个提供者，但通常是不用的。<code>RxJS</code> 提供了很多预定义的创建器，而且将来可能还会增加新的。不过，那些眼花缭乱的创建器完全没必要全记住，只要记住少数几个就够了，其它的有时间慢慢看。</li></ul><h3 id="3-2-1-of-–-单一值转为流"><a href="#3-2-1-of-–-单一值转为流" class="headerlink" title="3.2.1  of – 单一值转为流"></a>3.2.1  of – 单一值转为流</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204644634.png" alt="image-20210208204644634"></p><blockquote><p>它接收任意多个参数，参数可以是任意类型，然后它会把这些参数逐个放入流中</p></blockquote><h3 id="3-2-2-from-–-数组转为流"><a href="#3-2-2-from-–-数组转为流" class="headerlink" title="3.2.2 from – 数组转为流"></a>3.2.2 from – 数组转为流</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204656811.png" alt="image-20210208204656811"></p><blockquote><p>它接受一个数组型参数，数组中可以有任意数据，然后把数组的每个元素逐个放入流中</p></blockquote><h3 id="3-2-3-range-–-范围转为流"><a href="#3-2-3-range-–-范围转为流" class="headerlink" title="3.2.3 range – 范围转为流"></a>3.2.3 range – 范围转为流</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204705194.png" alt="image-20210208204705194"></p><blockquote><p>它接受两个数字型参数，一个起点，一个终点，然后按 <code>1</code> 递增，把中间的每个数字（含边界值）放入流中</p></blockquote><h3 id="3-2-4-fromPromise-–-Promise-转为流"><a href="#3-2-4-fromPromise-–-Promise-转为流" class="headerlink" title="3.2.4 fromPromise – Promise 转为流"></a>3.2.4 fromPromise – Promise 转为流</h3><ul><li>接受一个 <code>Promise</code>，当这个 <code>Promise</code> 有了输出时，就把这个输出放入流中。</li><li>要注意的是，当 <code>Promise</code> 作为参数传给 <code>fromPromise</code> 时，这个 <code>Promise</code> 就开始执行了，你没有机会防止它被执行。</li><li>如果你需要这个 <code>Promise</code> 被消费时才执行，那就要改用接下来要讲的 <code>defer</code> 创建器</li></ul><h3 id="3-2-5-defer-–-惰性创建流"><a href="#3-2-5-defer-–-惰性创建流" class="headerlink" title="3.2.5 defer – 惰性创建流"></a>3.2.5 defer – 惰性创建流</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204715704.png" alt="image-20210208204715704"></p><ul><li>它的参数是一个用来生产流的工厂函数。也就是说，当消费方需要流（注意不是需要流中的值）的时候，就会调用这个函数，创建一个流，并从这个流中进行消费（取数据）</li><li>因此，当我们定义 <code>defer</code>的时候，实际上还不存在一个真正的流，只是给出了创建这个流的方法，所以叫惰性创建流</li></ul><h3 id="3-2-6-timer-–-定时器流"><a href="#3-2-6-timer-–-定时器流" class="headerlink" title="3.2.6 timer – 定时器流"></a>3.2.6 timer – 定时器流</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204727266.png" alt="image-20210208204727266"></p><ul><li>它有两个数字型的参数，第一个是首次等待时间，第二个是重复间隔时间。从图上可以看出，它实际上是个无尽流 —— 没有终止线。因此它会按照预定的规则往流中不断重复发出数据。</li><li>要注意，虽然名字有相关性，但它不是 <code>setTimeout</code>的等价物，事实上它的行为更像是 <code>setInterval</code></li></ul><h3 id="3-2-7-interval-–-定时器流"><a href="#3-2-7-interval-–-定时器流" class="headerlink" title="3.2.7 interval – 定时器流"></a>3.2.7 interval – 定时器流</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204736607.png" alt="image-20210208204736607"></p><ul><li>它和 <code>timer</code> 唯一的差别是它只接受一个参数。事实上，它就是一个语法糖，相当于 <code>timer(1000, 1000)</code>，也就是说初始等待时间和间隔时间是一样的。</li><li>如果需求确实是 <code>interval</code> 的语义，那么就优先使用这个语法糖，毕竟，从行为上它和 <code>setInterval</code> 几乎是一样的</li></ul><h2 id="3-3-Subject-–-主体对象"><a href="#3-3-Subject-–-主体对象" class="headerlink" title="3.3 Subject – 主体对象"></a>3.3 Subject – 主体对象</h2><blockquote><p>它和创建器不同，创建器是供直接调用的函数，而 <code>Subject</code> 则是一个实现了 <code>observable</code> 接口的类。也就是说，你要先把它 <code>new</code> 出来（假设实例叫 <code>subject</code>），然后你就可以通过程序控制的方式往流里手动放数据了。它的典型用法是用来管理事件，比如当用户点击了某个按钮时，你希望发出一个事件，那么就可以调用 <code>subject.next(someValue)</code> 来把事件内容放进流中</p></blockquote><ul><li>当你希望手动控制往这个流中放数据的时机时，这种特性非常有用。</li><li>当然，<code>Subject</code> 其实并没有这么简单，用法也很多</li></ul><h2 id="3-4-合并创建器"><a href="#3-4-合并创建器" class="headerlink" title="3.4 合并创建器"></a>3.4 合并创建器</h2><blockquote><p>我们不但可以直接创建流，还可以对多个现有的流进行不同形式的合并，创建一个新的流。常见的合并方式有三种：并联、串联、拉链</p></blockquote><h3 id="3-4-1-merge-–-并联"><a href="#3-4-1-merge-–-并联" class="headerlink" title="3.4.1 merge – 并联"></a>3.4.1 merge – 并联</h3><p><img src="http://img-repo.poetries.top/images/1240.png" alt="img"></p><ul><li>从图上我们可以看到两个流中的内容被合并到了一个流中。只要任何一个流中出现了值就会立刻被输出，哪怕其中一个流是完全空的也不影响结果 —— 等同于原始流。</li><li>这种工作方式非常像电路中的并联行为，因此我称其为并联创建器。</li><li>并联在什么情况下起作用呢？举个例子吧：有一个列表需要每隔 <code>5</code> 秒钟定时刷新一次，但是一旦用户按了搜索按钮，就必须立即刷新，而不能等待 <code>5</code> 秒间隔。这时候就可以用一个定时器流和一个自定义的用户操作流（<code>subject</code>）<code>merge</code> 在一起。这样，无论哪个流中出现了数据，都会进行刷新</li></ul><h3 id="3-4-2-concat-–-串联"><a href="#3-4-2-concat-–-串联" class="headerlink" title="3.4.2 concat – 串联"></a>3.4.2 concat – 串联</h3><p><img src="http://img-repo.poetries.top/images/1240-20210208204820976.png" alt="img"></p><ul><li>从图中我们可以看到两个流中的内容被按照顺序放进了输出流中。前面的流尚未结束时（注意竖线），后面的流就会一直等待</li><li>这种工作方式非常像电路中的串联行为，因此我称其为串联创建器。</li><li>串联的适用场景就很容易想象了，比如我们需要先通过 <code>Web API</code> 进行登录，然后取学生名册。这两个操作就是异步且串联工作的</li></ul><h3 id="3-4-3-zip-–-拉链"><a href="#3-4-3-zip-–-拉链" class="headerlink" title="3.4.3 zip – 拉链"></a>3.4.3 zip – 拉链</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204828426.png" alt="image-20210208204828426"></p><ul><li><code>zip</code> 的直译就是拉链，事实上，有些压缩软件的图标就是一个带拉链的钥匙包。拉链的特点是两边各有一个“齿”，两者会啮合在一起。这里的 <code>zip</code> 操作也是如此。</li></ul><blockquote><p>从图上我们可以看到，两个输入流中分别出现了一些数据，当仅仅输入流 <code>A</code> 中出现了数据时，输出流中什么都没有，因为它还在等另一个“齿”。当输出流 <code>B</code> 中出现了数据时，两个“齿”都凑齐了，于是对这两个齿执行中间定义的运算（取 <code>A</code> 的形状，<code>B</code> 的颜色，并合成为输出数据）</p></blockquote><ul><li>可以看到，当任何一个流先行结束之后，整个输出流也就结束了。</li><li>拉链创建器适用的场景要少一些，通常用于合并两个数据有对应关系的数据源。比如一个流中是姓名，另一个流中是成绩，还有一个流中是年龄，如果这三个流中的每个条目都有精确的对应关系，那么就可以通过 <code>zip</code> 把它们合并成一个由表示学生成绩的对象组成的流。</li></ul><h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h2><blockquote><p><code>RxJS</code> 有很多操作符，事实上比创建器还要多一些，但是我们并不需要一一讲解，因为它们中的很大一部分都是函数式编程中的标配，比如 <code>map</code>、<code>reduce</code>、<code>filter</code> 等</p></blockquote><h3 id="3-5-1-retry-–-失败时重试"><a href="#3-5-1-retry-–-失败时重试" class="headerlink" title="3.5.1 retry – 失败时重试"></a>3.5.1 retry – 失败时重试</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204837805.png" alt="image-20210208204837805"></p><ul><li>有些错误是可以通过重试进行恢复的，比如临时性的网络丢包。甚至一些流程的设计还会故意借助重试机制，比如当你发起请求时，如果后端发现你没有登录过，就会给你一个 <code>401</code> 错误，然后你可以完成登录并重新开始整个流程。</li><li><code>retry</code> 操作符就是负责在失败时自动发起重试的，它可以接受一个参数，用来指定最大重试次数。</li></ul><p>这里我为什么一直在强调失败时重试呢？因为还有一个操作符负责成功时重试</p><h3 id="3-5-2-repeat-–-成功时重试"><a href="#3-5-2-repeat-–-成功时重试" class="headerlink" title="3.5.2 repeat – 成功时重试"></a>3.5.2 repeat – 成功时重试</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204846757.png" alt="image-20210208204846757"></p><ul><li>除了重复的条件之外，<code>repeat</code> 的行为几乎和 <code>retry</code> 一模一样。</li><li><code>repeat</code> 很少会单独用，一般会组合上 <code>delay</code> 操作，以提供暂停时间，否则就容易 DoS 了服务器</li></ul><h3 id="3-5-3-delay-–-延迟"><a href="#3-5-3-delay-–-延迟" class="headerlink" title="3.5.3 delay – 延迟"></a>3.5.3 delay – 延迟</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204856423.png" alt="image-20210208204856423"></p><ul><li>这才是真正的 <code>setTimeout</code> 的等价操作。它接受一个毫秒数（图中是 <code>20</code> 毫秒），每当它从输入流中读取一个数据之后，会先等待 <code>20</code> 毫秒，然后再放到输出流中。</li><li>可以看到，输入流和输出流内容是完全一样的，只是时机上，输出流中的每个条目都恰好比输入流晚 <code>20</code> 毫秒出现</li></ul><h3 id="3-5-4-toArray-–-收集为数组"><a href="#3-5-4-toArray-–-收集为数组" class="headerlink" title="3.5.4 toArray – 收集为数组"></a>3.5.4 toArray – 收集为数组</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204905368.png" alt="image-20210208204905368"></p><ul><li>事实上，你几乎可以把它看做是 <code>from</code> 的逆运算。 <code>from</code> 把数组打散了逐个放进流中，而 <code>toArray</code> 恰好相反，把流中的内容收集到一个数组中 —— 直到这个流结束。</li><li>这个操作符几乎总是放在最后一步，因为 <code>RxJS</code> 的各种 <code>operator</code> 本身就可以对流中的数据进行很多类似数组的操作，比如查找最小值、最大值、过滤等。所以通常会先使用各种 operator 对数据流进行处理，等到要脱离 <code>RxJS</code> 的体系时，再转换成数组传出去</li></ul><h3 id="3-5-5-debounceTime-–-防抖"><a href="#3-5-5-debounceTime-–-防抖" class="headerlink" title="3.5.5 debounceTime – 防抖"></a>3.5.5 debounceTime – 防抖</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204912979.png" alt="image-20210208204912979"></p><ul><li>在 <code>underscore/lodash</code> 中这是常用函数。 所谓防抖其实就是“等它平静下来”。比如预输入（type ahead）功能，当用户正在快速打字的时候，你没必要立刻去查服务器，否则可能直接让服务器挂了，而应该等用户稍作停顿（平静下来）时再发起查询。</li><li><code>debounceTime</code> 就是这样，你传入一个最小平静时间，在这个时间窗口内连续过来的数据一概被忽略，一旦平静时间超过它，就会往把接收到的下一条数据放到流中。这样消费者就只能看到平静时间超时之后发来的最后一条数据</li></ul><h3 id="3-5-6-switchMap-–-切换成另一个流"><a href="#3-5-6-switchMap-–-切换成另一个流" class="headerlink" title="3.5.6 switchMap – 切换成另一个流"></a>3.5.6 switchMap – 切换成另一个流</h3><p><img src="http://img-repo.poetries.top/images/image-20210208204929447.png" alt="image-20210208204929447"></p><ul><li>有时候，我们会希望根据一个立即数发起一个远程查询，并且把这个异步取回的结果放进流中。比如，流中是一些学生的 <code>id</code>，每过来一个 <code>id</code>，你要发起一个 <code>Ajax</code> 请求来根据这个 <code>id</code> 获取这个学生的详情，并且把详情放进输出流中。</li><li>注意，这是一个异步操作，所以你没法用普通的 <code>map</code> 来实现，否则映射出来的结果就会是一个个 <code>Observable</code> 对象。</li><li><code>switchMap</code> 就是用来解决这个问题的。它在回调函数中接受从输入流中传来的数据，并转换成一个新的 <code>Observable</code> 对象（新的流，每个流中包括三个值，每个值都等于输入值的十倍），<code>switchMap</code> 会订阅这个 <code>Observable</code> 对象，并把它的值放入输出流中。注意图中竖线的位置 —— 只有当所有新的流都结束时，输出流才会结束</li></ul><h1 id="四、进一步使用"><a href="#四、进一步使用" class="headerlink" title="四、进一步使用"></a>四、进一步使用</h1><h2 id="4-1-Rxjs-unsubscribe-取消订阅"><a href="#4-1-Rxjs-unsubscribe-取消订阅" class="headerlink" title="4.1 Rxjs unsubscribe 取消订阅"></a>4.1 Rxjs unsubscribe 取消订阅</h2><blockquote><p><code>Promise</code> 的创建之后，动作是无法撤回的。<code>Observable</code> 不一样，动作可以通过 <code>unsbscribe()</code> 方法中途撤回，而且 <code>Observable</code> 在内部做了智能的处理.</p></blockquote><p><strong>Promise 创建之后动作无法撤回</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve = &gt;&#123;</span><br><span class="line">    setTimeout(() = &gt;&#123;</span><br><span class="line">        resolve(<span class="string">'---promise timeout---'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(value = &gt;<span class="built_in">console</span>.log(value));</span><br></pre></td></tr></table></figure><p><strong>Rxjs 可以通过 unsubscribe() 可以撤回 subscribe 的动作</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stream = <span class="keyword">new</span> Observable(observer = &gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = setTimeout(() = &gt;&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        observer.next(<span class="string">'observable timeout'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> disposable = stream.subscribe(value = &gt;<span class="built_in">console</span>.log(value));</span><br><span class="line">setTimeout(() = &gt;&#123;</span><br><span class="line">    <span class="comment">//取消执行 disposable.unsubscribe();</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="4-2-Rxjs-订阅后多次执行"><a href="#4-2-Rxjs-订阅后多次执行" class="headerlink" title="4.2 Rxjs 订阅后多次执行"></a>4.2 Rxjs 订阅后多次执行</h2><blockquote><p>如果我们想让异步里面的方法多次执行，比如下面代码。<br>这一点 <code>Promise</code>是做不到的，对于 <code>Promise</code>来说，最终结果要么 <code>resolve</code>(兑现)、要么 <code>reject</code> (拒绝)，而且都只能触发一次。如果在同一个 <code>Promise</code> 对象上多次调用 <code>resolve</code> 方法， 则会抛异常。而 <code>Observable</code>不一样，它可以不断地触发下一个值，就像 <code>next()</code>这个方法的 名字所暗示的那样。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve = &gt;&#123;</span><br><span class="line">    setInterval(() = &gt;&#123;</span><br><span class="line">        resolve(<span class="string">'---promise setInterval---'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(value = &gt;<span class="built_in">console</span>.log(value));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rxjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stream = <span class="keyword">new</span> Observable &lt; number &gt; (observer = &gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    setInterval(() = &gt;&#123;</span><br><span class="line">        observer.next(count++);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">stream.subscribe(value = &gt;<span class="built_in">console</span>.log(<span class="string">"Observable&gt;"</span> + value));</span><br></pre></td></tr></table></figure><h2 id="五、RXJS-实例操作符小结"><a href="#五、RXJS-实例操作符小结" class="headerlink" title="五、RXJS 实例操作符小结"></a>五、RXJS 实例操作符小结</h2><p><strong>常用的实例方法</strong></p><ul><li><code>pip</code> ：功能类似于 <code>let</code> 操作符</li><li><code>map</code> ：转换输出的数据</li><li><code>pluck</code> ：提取属性值并输出</li><li><code>do</code> ：不做数据格式化，可用于调试</li><li><code>filter</code> ：用于过滤一些<code>Observable</code></li><li><code>take</code>：表示取几条数据</li><li><code>takeWhile</code> ：满足什么条件时开始取数据</li><li><code>skip</code> ：表示跳过多少条数据后开始取</li><li><code>distinctUntilChanged</code> ：比较输入的<code>Observable</code>计算得出的值当前与后最后的值是否相等使用<code>===</code>判断</li><li><code>scan</code> ：功能有点类似于<code>reduce</code>这个方法，可用于累加数据同时可以使用<code>startWith</code>的数据用途<code>scan</code>的初始值，最后返回累加的数据</li><li><code>delay</code> ：表示<code>Observable</code>延时多久开始处理订阅数据</li><li><code>toArray</code> ：把输出值格式化成数据形式</li><li><code>toMap</code> ：给当前的输出取个名字或标签</li><li><code>expand</code> ：实现递归</li><li><code>forkJoin</code> ：类似于<code>Promise.all</code>，只有数据全部返回且状态为<code>complete</code>时，表示成功处理了请求，否则失败</li><li><code>let</code> ：这个操作符可以获取完整的输入<code>Observable</code>对象，做相应的处理后返回新的<code>Observable</code>对象</li><li><code>catch</code> ：用于<code>Observable</code>处理数据异常的处理</li><li><code>combineLatest</code> ：用于组且各个输入的<code>Observable</code>，并获取和返回各个<code>Observable</code>最新的数据</li><li><code>merge</code> ：用于把两个<code>Observable</code>合成一个处理</li></ul><h1 id="六、更多参考"><a href="#六、更多参考" class="headerlink" title="六、更多参考"></a>六、更多参考</h1><ul><li><a href="https://cn.rx.js.org" target="_blank" rel="noopener">Rxjs中文文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;h2 id=&quot;1-1-Promise缺点&quot;&gt;&lt;a href=&quot;#1-1-Promise缺点&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="JavaScript" scheme="http://blog.poetries.top/tags/JavaScript/"/>
    
      <category term="RxJs" scheme="http://blog.poetries.top/tags/RxJs/"/>
    
  </entry>
  
  <entry>
    <title>前端页面性能优化方式</title>
    <link href="http://blog.poetries.top/2021/02/08/fe-youhua/"/>
    <id>http://blog.poetries.top/2021/02/08/fe-youhua/</id>
    <published>2021-02-08T02:50:03.000Z</published>
    <updated>2021-05-11T03:46:23.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、调试工具"><a href="#一、调试工具" class="headerlink" title="一、调试工具"></a>一、调试工具</h2><h3 id="1、Network"><a href="#1、Network" class="headerlink" title="1、Network"></a>1、Network</h3><p><img src="http://img-repo.poetries.top/images/image-20210208102537169.png" alt="image-20210208102537169"></p><p>这里可以看到资源加载详情，初步评估影响<code>页面性能</code>的因素。鼠标右键可以自定义选项卡，页面底部是当前加载资源的一个概览。<code>DOMContentLoaded</code> DOM渲染完成的时间，<code>Load</code>：当前页面所有资源加载完成的时间</p><p><strong>思考：如何判断哪些资源对当前页面加载无用，做对应优化？</strong></p><p><strong>shift + cmd + P 调出控制台的扩展工具，添加规则</strong></p><p><img src="http://img-repo.poetries.top/images/image-20210208102549961.png" alt="image-20210208102549961"></p><p><strong>监控页面性能变化</strong></p><p><img src="http://img-repo.poetries.top/images/image-20210208102650825.png" alt="image-20210208102650825"></p><h4 id="瀑布流waterfal"><a href="#瀑布流waterfal" class="headerlink" title="瀑布流waterfal"></a>瀑布流waterfal</h4><p><img src="http://img-repo.poetries.top/images/image-20210208102723253.png" alt="image-20210208102723253"></p><ul><li><p><code>Queueing</code> 浏览器将资源放入队列时间</p></li><li><p><code>Stalled</code> 因放入队列时间而发生的停滞时间</p></li><li><p><code>DNS Lookup</code> DNS解析时间</p></li><li><p><code>Initial connection</code>  建立HTTP连接的时间</p></li><li><p><code>SSL</code> 浏览器与服务器建立安全性连接的时间</p></li><li><p><code>TTFB</code> 等待服务端返回数据的时间</p></li><li><p><code>Content Download</code>  浏览器下载资源的时间</p></li></ul><h3 id="2、Lighthouse"><a href="#2、Lighthouse" class="headerlink" title="2、Lighthouse"></a>2、Lighthouse</h3><p><img src="http://img-repo.poetries.top/images/image-20210208102851752.png" alt="image-20210208102851752"></p><ul><li><code>First Contentful Paint</code> 首屏渲染时间，1s以内绿色</li><li><code>Speed Index</code> 速度指数，4s以内绿色</li><li><code>Time to Interactive</code> 到页面可交换的时间</li></ul><blockquote><p>根据chrome的一些策略自动对网站做一个质量评估，并且会给出一些优化的建议</p></blockquote><h3 id="3、Peformance"><a href="#3、Peformance" class="headerlink" title="3、Peformance"></a>3、Peformance</h3><p><img src="http://img-repo.poetries.top/images/image-20210208102949596.png" alt="image-20210208102949596"></p><p>对网站最专业的分析</p><h3 id="4、webPageTest"><a href="#4、webPageTest" class="headerlink" title="4、webPageTest"></a>4、webPageTest</h3><blockquote><p>可以模拟不同场景下访问的情况，比如模拟不同浏览器、不同国家等等，在线测试地址：<a href="https://www.webpagetest.org/" target="_blank" rel="noopener">webPageTest</a></p></blockquote><p><img src="http://img-repo.poetries.top/images/image-20210208103032419.png" alt="image-20210208103032419"></p><p><img src="http://img-repo.poetries.top/images/image-20210208103054016.png" alt="image-20210208103054016"></p><h3 id="5、资源打包分析"><a href="#5、资源打包分析" class="headerlink" title="5、资源打包分析"></a>5、资源打包分析</h3><h4 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h4><p><img src="http://img-repo.poetries.top/images/image-20210208103127992.png" alt="image-20210208103127992"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br><span class="line"><span class="comment">// webpack.config.js 文件</span></span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">          analyzerMode: <span class="string">'server'</span>,</span><br><span class="line">          analyzerHost: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">          analyzerPort: <span class="number">8889</span>,</span><br><span class="line">          reportFilename: <span class="string">'report.html'</span>,</span><br><span class="line">          defaultSizes: <span class="string">'parsed'</span>,</span><br><span class="line">          openAnalyzer: <span class="literal">true</span>,</span><br><span class="line">          generateStatsFile: <span class="literal">false</span>,</span><br><span class="line">          statsFilename: <span class="string">'stats.json'</span>,</span><br><span class="line">          statsOptions: <span class="literal">null</span>,</span><br><span class="line">          logLevel: <span class="string">'info'</span></span><br><span class="line">        &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"analyz"</span>: <span class="string">"NODE_ENV=production npm_config_report=true npm run build"</span></span><br></pre></td></tr></table></figure><h4 id="开启source-map"><a href="#开启source-map" class="headerlink" title="开启source-map"></a>开启source-map</h4><blockquote><p> <code>webpack.config.js</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;production&apos;,</span><br><span class="line">    devtool: &apos;hidden-source-map&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package.json</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"analyze"</span>: <span class="string">"source-map-explorer 'build/*.js'"</span>,</span><br></pre></td></tr></table></figure><p>npm run analyze</p><p><img src="http://img-repo.poetries.top/images/image-20210208103321371.png" alt="image-20210208103321371"></p><h2 id="二、WEB-API"><a href="#二、WEB-API" class="headerlink" title="二、WEB API"></a>二、WEB API</h2><p>工欲善其事，必先利其器。浏览器提供的一些分析API<code>至关重要</code></p><h3 id="1、监听视窗激活状态"><a href="#1、监听视窗激活状态" class="headerlink" title="1、监听视窗激活状态"></a>1、监听视窗激活状态</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b7ab11fc7b94fcf8c79bd3b28706b2c~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 窗口激活状态监听</span></span><br><span class="line"><span class="keyword">let</span> vEvent = <span class="string">'visibilitychange'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.webkitHidden != <span class="literal">undefined</span>) &#123;</span><br><span class="line">    vEvent = <span class="string">'webkitvisibilitychange'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibilityChanged</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden || <span class="built_in">document</span>.webkitHidden) &#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'客官，别走啊~'</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Web page is hidden."</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'客官，你又回来了呢~'</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Web page is visible."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(vEvent, visibilityChanged, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>其实有很多隐藏的api，这里大家有兴趣的可以去试试看：</p><h3 id="2、观察长任务（performance-中Task）"><a href="#2、观察长任务（performance-中Task）" class="headerlink" title="2、观察长任务（performance 中Task）"></a>2、观察长任务（performance 中Task）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> PerformanceObserver(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.getEntries()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(entry)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observer.observe(&#123;<span class="attr">entryTypes</span>: [<span class="string">'longtask'</span>]&#125;)</span><br></pre></td></tr></table></figure><h3 id="3、监听网络变化"><a href="#3、监听网络变化" class="headerlink" title="3、监听网络变化"></a>3、监听网络变化</h3><p>网络变化时给用户反馈网络问题，有时候看直播的时候自己的网络卡顿，直播平台也会提醒你或者自动给你切换清晰度</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;</span><br><span class="line"><span class="keyword">var</span> type = connection.effectiveType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateConnectionStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection type changed from "</span> + type + <span class="string">" to "</span> + connection.effectiveType);</span><br><span class="line">  type = connection.effectiveType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection.addEventListener(<span class="string">'change'</span>, updateConnectionStatus);</span><br></pre></td></tr></table></figure><h3 id="4、计算DOMContentLoaded时间"><a href="#4、计算DOMContentLoaded时间" class="headerlink" title="4、计算DOMContentLoaded时间"></a>4、计算DOMContentLoaded时间</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timing = performance.getEntriesByType(<span class="string">'navigation'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(timing.domInteractive);</span><br><span class="line">    <span class="built_in">console</span>.log(timing.fetchStart);</span><br><span class="line">    <span class="keyword">let</span> diff = timing.domInteractive - timing.fetchStart;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"TTI: "</span> + diff);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5、更多计算规则"><a href="#5、更多计算规则" class="headerlink" title="5、更多计算规则"></a>5、更多计算规则</h3><ul><li><code>DNS</code> 解析耗时: <code>domainLookupEnd - domainLookupStart</code></li><li><code>TCP</code> 连接耗时: <code>connectEnd - connectStart</code></li><li><code>SSL</code> 安全连接耗时: <code>connectEnd - secureConnectionStart</code></li><li>网络请求耗时 (<code>TTFB</code>): <code>responseStart - requestStart</code></li><li>数据传输耗时: <code>responseEnd - responseStart</code></li><li><code>DOM</code> 解析耗时: <code>domInteractive - responseEnd</code></li><li>资源加载耗时:<code>loadEventStart - domContentLoadedEventEnd</code></li><li><code>First Byte</code>时间: <code>responseStart - domainLookupStart</code></li><li>白屏时间: <code>responseEnd - fetchStart</code></li><li>首次可交互时间: <code>domInteractive - fetchStart</code></li><li><code>DOM Ready</code> 时间: <code>domContentLoadEventEnd - fetchStart</code></li><li>页面完全加载时间: <code>loadEventStart - fetchStart</code></li><li><code>http</code> 头部大小： <code>transferSize - encodedBodySize</code></li><li>重定向次数：<code>performance.navigation.redirectCount</code></li><li>重定向耗时: <code>redirectEnd - redirectStart</code></li></ul><h2 id="三、雅虎军规"><a href="#三、雅虎军规" class="headerlink" title="三、雅虎军规"></a>三、雅虎军规</h2><p>关于雅虎军规，你知道的有多少条，平时写用到的又有哪些？针对以下规则，我们可以做很多优化工作</p><p><img src="http://img-repo.poetries.top/images/image-20210208103918197.png" alt="image-20210208103918197"></p><h3 id="1、减少cookie传输"><a href="#1、减少cookie传输" class="headerlink" title="1、减少cookie传输"></a>1、减少cookie传输</h3><blockquote><p> <code>cookie</code>传输会造成带宽浪费，可以：</p></blockquote><ul><li>减少<code>cookie</code>中存储的东西</li><li>静态资源不需要<code>cookie</code>，可以采用其他的域名，不会主动带上<code>cookie</code></li></ul><h3 id="2、避免过多的回流与重绘"><a href="#2、避免过多的回流与重绘" class="headerlink" title="2、避免过多的回流与重绘"></a>2、避免过多的回流与重绘</h3><p>连续触发页面回流操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cards = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"MuiPaper-rounded"</span>);</span><br><span class="line"><span class="keyword">const</span> update = <span class="function">(<span class="params">timestamp</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;cards.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = cards[i].offsetTop;</span><br><span class="line">    cards[i].style.width = ((<span class="built_in">Math</span>.sin(cards[i].offsetTop + timestamp / <span class="number">100</span> + <span class="number">1</span>) * <span class="number">500</span>) + <span class="string">'px'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(update)</span><br><span class="line">&#125;</span><br><span class="line">update(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>看下效果，很明显的卡顿</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7618dea1a4774c8685e9926b08d67fdd~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><blockquote><p><code>performance</code>分析结果，<code>load</code>事件之后存在大量的回流，并且<code>chrome</code>都给标记了红色</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b543d68fab7445da1dedb72bb224f69~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><blockquote><p>使用<code>fastDom</code>进行优化，将对dom的<code>读和写</code>分离，合并</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cards = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"MuiPaper-rounded"</span>);</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function">(<span class="params">timestamp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cards.length; i++) &#123;</span><br><span class="line">      fastdom.measure(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> top = cards[i].offsetTop;</span><br><span class="line">        fastdom.mutate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          cards[i].style.width =</span><br><span class="line">            <span class="built_in">Math</span>.sin(top + timestamp / <span class="number">100</span> + <span class="number">1</span>) * <span class="number">500</span> + <span class="string">"px"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(update)</span><br><span class="line">  &#125;</span><br><span class="line">  update(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df5c32c30494c13b3402305f866b327~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><blockquote><p><code>performance</code>分析结果，load事件之后也没有了那么多的红色标记</p></blockquote><p>感兴趣的可以去了解一下fastDom：<a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">github fastdom</a> 在线预览：<a href="http://wilsonpage.github.io/fastdom/examples/animation.html" target="_blank" rel="noopener">fastdom demo</a></p><p>关于任务拆分与组合的思想，<code>react fiber</code>架构做的很牛逼，有兴趣的可以去了解一下调度算法在fiber中的实践</p><h2 id="四、压缩"><a href="#四、压缩" class="headerlink" title="四、压缩"></a>四、压缩</h2><h3 id="1、Gzip"><a href="#1、Gzip" class="headerlink" title="1、Gzip"></a>1、Gzip</h3><p>开启方式可参考：<a href="https://juejin.cn/post/6844903605187641357" target="_blank" rel="noopener">nginx开启gzip</a></p><p><img src="http://img-repo.poetries.top/images/image-20210208104535672.png" alt="image-20210208104535672"></p><blockquote><p> 还有一种方式：打包的时候生成gz文件，上传到服务器端，这样就不需要nginx来压缩了，可以降低服务器压力。 可参考：<a href="https://segmentfault.com/a/1190000020976930" target="_blank" rel="noopener">gzip压缩文件&amp;webPack配置Compression-webpack-plugin</a></p></blockquote><h3 id="2、服务端压缩"><a href="#2、服务端压缩" class="headerlink" title="2、服务端压缩"></a>2、服务端压缩</h3><p>server.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> compression = <span class="built_in">require</span>(<span class="string">'compression'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(compression());</span><br><span class="line">app.use(express.static(<span class="string">'build'</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'*'</span>, (req,res) =&gt;&#123;</span><br><span class="line">    res.sendFile(path.join(__dirname+<span class="string">'/build/index.html'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> listener = app.listen(process.env.PORT || <span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;listener.address().port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>package.json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;start&quot;: &quot;npm run build &amp;&amp; node server.js&quot;,</span><br></pre></td></tr></table></figure><p><img src="http://img-repo.poetries.top/images/image-20210208104641677.png" alt="image-20210208104641677"></p><h3 id="3、JavaScript、Css、Html压缩"><a href="#3、JavaScript、Css、Html压缩" class="headerlink" title="3、JavaScript、Css、Html压缩"></a>3、JavaScript、Css、Html压缩</h3><p>工程化项目中直接使用对应的插件即可，webpack的主要有下面三个：</p><ul><li><code>UglifyJS</code></li><li><code>webpack-parallel-uglify-plugin</code></li><li><code>terser-webpack-plugin</code></li></ul><blockquote><p> 具体优缺点可参考：<a href="https://blog.csdn.net/qq_24147051/article/details/103557728" target="_blank" rel="noopener">webpack常用的三种JS压缩插件</a>。<code>压缩原理</code>简单的讲就是去除一些空格、换行、注释，借助es6模块化的功能，做了一些<code>tree-shaking</code>的优化。同时做了一些代码混淆，一方面是为了更小的体积，另一方面也是为了源码的安全性。</p></blockquote><p>css压缩主要是<code>mini-css-extract-plugin</code>，当然前面的js压缩插件也会给你做好css压缩。使用姿势</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">plugins:[</span><br><span class="line"> new MiniCssExtractPlugin(&#123;</span><br><span class="line">       filename: &quot;[name].css&quot;,</span><br><span class="line">       chunkFilename: &quot;[id].css&quot;</span><br><span class="line">   &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>html压缩可以用<code>HtmlWebpackPlugin</code>，单页项目就一个index.html,性能提升微乎其微~</p><h3 id="4、http2首部压缩"><a href="#4、http2首部压缩" class="headerlink" title="4、http2首部压缩"></a>4、http2首部压缩</h3><p><strong>http2的特点</strong></p><ul><li>二进制分帧</li><li>首部压缩</li><li>流量控制</li><li>多路复用</li><li>请求优先级</li><li>服务器推送<code>http2_push: &#39;xxx.jpg&#39;</code></li></ul><p>具体升级方式也很简单，修改一下<code>nginx</code>配置，方法请自行<code>Google</code></p><h2 id="五、webpack优化"><a href="#五、webpack优化" class="headerlink" title="五、webpack优化"></a>五、webpack优化</h2><p>上文中也提到了部分webpack插件，下面我再来看看还有哪些~</p><h3 id="1、DllPlugin-提升构建速度"><a href="#1、DllPlugin-提升构建速度" class="headerlink" title="1、DllPlugin 提升构建速度"></a>1、DllPlugin 提升构建速度</h3><blockquote><p>通过<code>DllPlugin</code>插件，将一些比较大的，基本很少升级的包拆分出来，生成<code>xx.dll.js</code>文件,通过<code>manifest.json</code>引用</p></blockquote><p>webpack.dll.config.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"production"</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        react: [<span class="string">"react"</span>, <span class="string">"react-dom"</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].dll.js"</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"dll"</span>),</span><br><span class="line">        library: <span class="string">"[name]"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: <span class="string">"[name]"</span>,</span><br><span class="line">            path: path.resolve(__dirname, <span class="string">"dll/[name].manifest.json"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>package.json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dll-build&quot;: &quot;NODE_ENV=production webpack --config webpack.dll.config.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>webpack4不需要配置dll了，因为webpack4打包性能已经足够优化，vue-cli3都已经移除<code>dll</code></p></blockquote><h3 id="2、splitChunks-拆包"><a href="#2、splitChunks-拆包" class="headerlink" title="2、splitChunks 拆包"></a>2、splitChunks 拆包</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                vendor: &#123;</span><br><span class="line">                    name: <span class="string">'vendor'</span>,</span><br><span class="line">                    test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                    minSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    priority: <span class="number">10</span>,</span><br><span class="line">                    chunks: <span class="string">'initial'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                common: &#123;</span><br><span class="line">                    name: <span class="string">'common'</span>,</span><br><span class="line">                    test: <span class="regexp">/[\\/]src[\\/]/</span>,</span><br><span class="line">                    chunks: <span class="string">'all'</span>,</span><br><span class="line">                    minSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h2 id="六、骨架屏"><a href="#六、骨架屏" class="headerlink" title="六、骨架屏"></a>六、骨架屏</h2><blockquote><p>用css提前占好位置，当资源加载完成即可填充，减少页面的回流与重绘，同时还能给用户最直接的反馈。 图中使用插件：<a href="https://github.com/buildo/react-placeholder" target="_blank" rel="noopener">react-placeholder</a></p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3666ae07b9eb4d839f7a893b89d83f47~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>关于实现骨架屏还有很多种方案，用<code>Puppeteer</code>服务端渲染的挺多的</p><p>使用css伪类：<a href="https://segmentfault.com/a/1190000020437426" target="_blank" rel="noopener">只要css就能实现的骨架屏方案</a></p><h2 id="七、窗口化"><a href="#七、窗口化" class="headerlink" title="七、窗口化"></a>七、窗口化</h2><blockquote><p>原理：只加载当前窗口能显示的DOM元素，当视图变化时，删除隐藏的，添加要显示的DOM就可以保证页面上存在的dom元素数量永远不多，页面就不会卡顿</p></blockquote><p>图中使用的插件：<a href="https://github.com/bvaughn/react-window" target="_blank" rel="noopener">react-window</a></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a459cc811844b7793aff6c9878d19ad~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>安装：<code>npm i react-window</code></p><p>引入：<code>import { FixedSizeList as List } from &#39;react-window&#39;;</code></p><p>使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Row = (&#123; index, style &#125;) =&gt; (</span><br><span class="line">  &lt;div style=&#123;style&#125;&gt;Row &#123;index&#125;&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">const Example = () =&gt; (</span><br><span class="line">  &lt;List</span><br><span class="line">    height=&#123;150&#125;</span><br><span class="line">    itemCount=&#123;1000&#125;</span><br><span class="line">    itemSize=&#123;35&#125;</span><br><span class="line">    width=&#123;300&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;Row&#125;</span><br><span class="line">  &lt;/List&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="八、缓存"><a href="#八、缓存" class="headerlink" title="八、缓存"></a>八、缓存</h2><h3 id="1、http缓存"><a href="#1、http缓存" class="headerlink" title="1、http缓存"></a>1、http缓存</h3><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>判断是否开启：看<code>response headers</code>中有没有<code>Connection: keep-alive</code> 。开启以后，看<code>network</code>的瀑布流中就没有 <code>Initial connection</code>耗时了</p><p><code>nginx</code>设置<code>keep-alive</code>（默认开启）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 0 为关闭</span><br><span class="line">#keepalive_timeout 0;</span><br><span class="line"># 65s无连接 关闭</span><br><span class="line">keepalive_timeout 65;</span><br><span class="line"># 连接数，达到100断开</span><br><span class="line">keepalive_requests 100;</span><br></pre></td></tr></table></figure><h4 id="Cache-Control-Expires-Max-Age"><a href="#Cache-Control-Expires-Max-Age" class="headerlink" title="Cache-Control / Expires / Max-Age"></a>Cache-Control / Expires / Max-Age</h4><p>设置资源是否缓存，以及缓存时间</p><h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h4><p>资源唯一标识作对比，如果有变化，从服务器拉取资源。如果没变化则取缓存资源，状态码304，也就是协商缓存</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h4><p>通过对比时间的差异来觉得要不要从服务器获取资源</p><p>更多HTTP缓存参数可参考：<a href="https://harttle.land/2017/04/04/using-http-cache.html" target="_blank" rel="noopener">使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control</a></p><h3 id="2、Service-Worker"><a href="#2、Service-Worker" class="headerlink" title="2、Service Worker"></a>2、Service Worker</h3><blockquote><p>借助webpack插件<code>WorkboxWebpackPlugin</code>和<code>ManifestPlugin</code>,加载serviceWorker.js,通过<code>serviceWorker.register()</code>注册</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">    clientsClaim: <span class="literal">true</span>,</span><br><span class="line">    exclude: [<span class="regexp">/\.map$/</span>, /asset-manifest\.json$/],</span><br><span class="line">    importWorkboxFrom: <span class="string">'cdn'</span>,</span><br><span class="line">    navigateFallback: paths.publicUrlOrPath + <span class="string">'index.html'</span>,</span><br><span class="line">    navigateFallbackBlacklist: [</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^/_'</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'/[^/?]+\\.[^/]+$'</span>),</span><br><span class="line">    ],</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ManifestPlugin(&#123;</span><br><span class="line">    fileName: <span class="string">'asset-manifest.json'</span>,</span><br><span class="line">    publicPath: paths.publicUrlOrPath,</span><br><span class="line">    generate: <span class="function">(<span class="params">seed, files, entrypoints</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> manifestFiles = files.reduce(<span class="function">(<span class="params">manifest, file</span>) =&gt;</span> &#123;</span><br><span class="line">            manifest[file.name] = file.path;</span><br><span class="line">            <span class="keyword">return</span> manifest;</span><br><span class="line">        &#125;, seed);</span><br><span class="line">        <span class="keyword">const</span> entrypointFiles = entrypoints.app.filter(</span><br><span class="line">            fileName =&gt; !fileName.endsWith(<span class="string">'.map'</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            files: manifestFiles,</span><br><span class="line">            entrypoints: entrypointFiles,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p><img src="http://img-repo.poetries.top/images/image-20210208105415279.png" alt="image-20210208105415279"></p><h2 id="九、预加载-amp-amp-懒加载"><a href="#九、预加载-amp-amp-懒加载" class="headerlink" title="九、预加载 &amp;&amp; 懒加载"></a>九、预加载 &amp;&amp; 懒加载</h2><h3 id="1、preload"><a href="#1、preload" class="headerlink" title="1、preload"></a>1、preload</h3><p>就拿demo中的字体举例，正常情况下的加载顺序是这样的：</p><p><img src="http://img-repo.poetries.top/images/image-20210208105446451.png" alt="image-20210208105446451"></p><p>加入preload：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.119.woff2"</span> <span class="attr">as</span>=<span class="string">"font"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.118.woff2"</span> <span class="attr">as</span>=<span class="string">"font"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.116.woff2"</span> <span class="attr">as</span>=<span class="string">"font"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://img-repo.poetries.top/images/image-20210208105522277.png" alt="image-20210208105522277"></p><h3 id="2、prefetch"><a href="#2、prefetch" class="headerlink" title="2、prefetch"></a>2、prefetch</h3><blockquote><p> 场景：首页不需要这样的字体文件，下个页面需要：首页会以最低优先级<code>Lowest</code>来提前加载</p></blockquote><p>加入<code>prefetch</code>：</p><p>需要的页面，从<code>prefetch cache</code>中取</p><p><img src="http://img-repo.poetries.top/images/image-20210208105625448.png" alt="image-20210208105625448"></p><p>webpack也是支持这两个属性的:<a href="https://www.cnblogs.com/skychx/p/webpack-webpackChunkName-webpackPreload-webpackPreload.html" target="_blank" rel="noopener">webpackPrefetch 和 webpackPreload</a></p><h3 id="3、懒加载"><a href="#3、懒加载" class="headerlink" title="3、懒加载"></a>3、懒加载</h3><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>机械图片</p><p><img src="http://img-repo.poetries.top/images/image-20210208105717958.png" alt="image-20210208105717958"></p><p><code>渐进式图片（类似高斯模糊）</code> 需要UI小姐姐出稿的时候指定这种格式</p><p><img src="http://img-repo.poetries.top/images/image-20210208105747314.png" alt="image-20210208105747314"></p><p><code>响应式图片</code></p><p>原生模式：<code>&lt;img src=&quot;./img/index.jpg&quot; sizes=&quot;100vw&quot; srcset=&quot;./img/dog.jpg 800w, ./img/index.jpg 1200w&quot;/&gt;</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7427e9243791461b8ffa49f47981cfba~tplv-k3u1fbpfcp-watermark.image?imageslim" alt="img"></p><h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p>通过<code>函数 + import</code>实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Page404 = () =&gt; import(/* webpackChunkName: &quot;error&quot; */&apos;@views/errorPage/404&apos;);</span><br></pre></td></tr></table></figure><h2 id="十、ssr-amp-amp-react-snap"><a href="#十、ssr-amp-amp-react-snap" class="headerlink" title="十、ssr &amp;&amp; react-snap"></a>十、ssr &amp;&amp; react-snap</h2><ul><li>服务端渲染<code>SSR</code>，vue使用<code>nuxt.js</code>，<code>react</code>使用<code>next.js</code></li><li><code>react-snap</code>可以借助<code>Puppeteer</code>实现先渲染单页，然后保留<code>DOM</code>，发送到客户端</li></ul><h2 id="十一、体验优化"><a href="#十一、体验优化" class="headerlink" title="十一、体验优化"></a>十一、体验优化</h2><h3 id="白屏loading"><a href="#白屏loading" class="headerlink" title="白屏loading"></a>白屏loading</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41557f3a361c4cf899a4eab3bde79154~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p><strong>loading.html</strong> 需要自取哦，还有种方式，使用<code>webpack</code>插件<code>HtmlWebpackPlugin</code>将loading资源插入到页面中</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Loading<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-id">#loadding</span> &#123;</span></span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        display: flex;</span><br><span class="line">        width: 100%;</span><br><span class="line">        align-items: center;</span><br><span class="line">        justify-content: center;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-id">#loadding</span> &gt; <span class="selector-tag">span</span> &#123;</span></span><br><span class="line">        display: inline-block;</span><br><span class="line">        width: 8px;</span><br><span class="line">        height: 100%;</span><br><span class="line">        margin-right: 5px;</span><br><span class="line">        border-radius: 4px;</span><br><span class="line"><span class="css">        <span class="selector-tag">-webkit-animation</span>: <span class="selector-tag">load</span> 1<span class="selector-class">.04s</span> <span class="selector-tag">ease</span> <span class="selector-tag">infinite</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">animation</span>: <span class="selector-tag">load</span> 1<span class="selector-class">.04s</span> <span class="selector-tag">ease</span> <span class="selector-tag">infinite</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="keyword">@keyframes</span> load &#123;</span></span><br><span class="line">        0%,</span><br><span class="line">        100% &#123;</span><br><span class="line">          height: 40px;</span><br><span class="line"><span class="css">          <span class="selector-tag">background</span>: <span class="selector-id">#98beff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">          height: 60px;</span><br><span class="line">          margin-top: -20px;</span><br><span class="line"><span class="css">          <span class="selector-tag">background</span>: <span class="selector-id">#3e7fee</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"loadding"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"animation-delay: 0.13s"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"animation-delay: 0.26s"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"animation-delay: 0.39s"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"animation-delay: 0.52s"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $loadding = <span class="built_in">document</span>.getElementById(<span class="string">"loadding"</span>);</span></span><br><span class="line">      if (!$loadding) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      $loadding.style.display = <span class="string">"none"</span>;</span></span><br><span class="line">      $loadding.parentNode.removeChild($loadding);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、调试工具&quot;&gt;&lt;a href=&quot;#一、调试工具&quot; class=&quot;headerlink&quot; title=&quot;一、调试工具&quot;&gt;&lt;/a&gt;一、调试工具&lt;/h2&gt;&lt;h3 id=&quot;1、Network&quot;&gt;&lt;a href=&quot;#1、Network&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="性能优化" scheme="http://blog.poetries.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浅析Nginx之try_files</title>
    <link href="http://blog.poetries.top/2021/02/08/nginx-try-files/"/>
    <id>http://blog.poetries.top/2021/02/08/nginx-try-files/</id>
    <published>2021-02-08T01:58:20.000Z</published>
    <updated>2021-05-11T03:46:23.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Nginx</code>的配置语法灵活，可控制度非常高。在0.7以后的版本中加入了一个<code>try_files</code>指令，配合命名<code>location</code>，可以部分替代原本常用的<code>rewrite</code>配置方式，提高解析效率。</p></blockquote><h3 id="try-files指令："><a href="#try-files指令：" class="headerlink" title="try_files指令："></a><strong>try_files指令：</strong></h3><ul><li>语法：<code>try_files file ... uri</code> 或 <code>try_files file ... = code</code></li><li>默认值：无</li><li>作用域：<code>server location</code></li></ul><p><img src="http://img-repo.poetries.top/images/image-20210208093424322.png" alt="image-20210208093424322"></p><ul><li>当用户在浏览器输入<code>blog.zsc.com</code>或者<code>blog.zsc.com/index.html</code>或者<code>blog.zsc.com/index.php</code>时，根据<code>try_files</code>规则，可以找到该域名对应的<code>web</code>页面</li><li>当用户在浏览器输入<code>blog.zsc.com/fjdklfjaldkfjlads/zjklfjdslfjds</code>等不存在的域名时，根据<code>try_files</code>规则，<code>“$uri”</code>和<code>“$uri”</code>都不符合，所以<code>nginx</code>就自动把域名转换为<code>blog.zsc.com/index.php</code>，然后将<code>blog.zsc.com/index.php</code>页面内容反馈给客户端。</li><li><code>try_files</code>的作用是按顺序检查文件是否存在，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。</li></ul><blockquote><p>需要注意的是，只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部URI的指向（如下图）。最后一个参数是回退<code>URI</code>且必须存在，否则会出现内部<code>500</code>错误。命名的<code>location</code>也可以使用在最后一个参数中。与<code>rewrite</code>指令不同，如果回退<code>URI</code>不是命名的<code>location</code>那么<code>$args</code>不会自动保留，如果你想保留<code>$args</code>，则必须明确声明。</p></blockquote><p><img src="http://img-repo.poetries.top/images/image-20210208093626879.png" alt="image-20210208093626879"></p><blockquote><p>将<code>try_files</code>的最后一个参数设置为<code>@tornado</code>（<code>@</code>，内部重定向时会用到），当<code>“$uri”</code>找不到时，就做一个内部重定向，将请求抛给`“location @tornado”</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Nginx&lt;/code&gt;的配置语法灵活，可控制度非常高。在0.7以后的版本中加入了一个&lt;code&gt;try_files&lt;/code&gt;指令，配合命名&lt;code&gt;location&lt;/code&gt;，可以部分替代原本常用的&lt;code&gt;rewrite
      
    
    </summary>
    
      <category term="Back-end" scheme="http://blog.poetries.top/categories/Back-end/"/>
    
    
      <category term="部署" scheme="http://blog.poetries.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Nginx" scheme="http://blog.poetries.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Typora+PicGo+阿里云OSS实现自动上传图片</title>
    <link href="http://blog.poetries.top/2021/02/07/oss-typora-picgo-upload-img/"/>
    <id>http://blog.poetries.top/2021/02/07/oss-typora-picgo-upload-img/</id>
    <published>2021-02-07T01:30:12.000Z</published>
    <updated>2021-05-11T03:46:23.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Typora 是一款简单、高效而且优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验。它把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果。Typora 的一切都围绕纯粹的生产效率而设计。</p></blockquote><h2 id="阿里云OSS设置"><a href="#阿里云OSS设置" class="headerlink" title="阿里云OSS设置"></a>阿里云OSS设置</h2><h3 id="创建储存空间"><a href="#创建储存空间" class="headerlink" title="创建储存空间"></a><strong>创建储存空间</strong></h3><p><img src="http://img-repo.poetries.top/images/image-20210207102313573.png" alt="image-20210207102313573"></p><ul><li>存储空间名称：按规则随便取</li><li>存储区域：选择离靠近的地区</li><li>读写权限：选择<strong>公开</strong>，否则<strong>外网无法访问，没法作为图床</strong></li></ul><p><strong>绑定已备案的域名</strong></p><blockquote><p>需要前往域名服务商创建解析</p></blockquote><p><img src="http://img-repo.poetries.top/images/image-20210207102411339.png" alt="image-20210207102411339"></p><p><strong>获取访问OSS的秘钥</strong></p><p><img src="http://img-repo.poetries.top/images/image-20210207102428005.png" alt="image-20210207102428005"></p><p><img src="http://img-repo.poetries.top/images/image-20210207102438448.png" alt="image-20210207102438448"></p><h2 id="图床管理工具PicGo设置"><a href="#图床管理工具PicGo设置" class="headerlink" title="图床管理工具PicGo设置"></a>图床管理工具PicGo设置</h2><blockquote><p><code>PicGo</code>用于免费搭建个人图床，并且跨平台支持 Windows、macOS 和 Linux 系统，它的使用非常简单，只需先设置好图床网站 / 云存储服务的账号之后，用鼠标将图片拖放到 PicGo 主窗口的图片上传框，即可完成图片的上传并返回一个url链接到剪切板。</p></blockquote><p>现在图床基本可以使用了，但是为了能更方便的管理，最重要的是能跟Typora无缝衔接，我们还需要PicGo辅助，</p><p>PicGo<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">下载地址</a>，选择版本并且根据自己的操作系统选择对应的安装包即可。</p><p><img src="http://img-repo.poetries.top/images/image-20210207102450970.png" alt="image-20210207102450970"></p><p>安装好后打开界面如下所示：</p><p><img src="http://img-repo.poetries.top/images/image-20210207102501215.png" alt="image-20210207102501215"></p><p>在左侧的图床设置中，有非常多的图床可供选择，大家可以根据自己的使用进行选择，这儿我们选择“阿里云OSS图床”</p><p><img src="http://img-repo.poetries.top/images/image-20210207102511487.png" alt="image-20210207102511487"></p><ul><li>上传图片成功后剪贴板会自动获取图片引用的外链</li><li>在相册可以查看通过PicGo上传过的图片</li></ul><h2 id="实现Typora中图片自动的上传"><a href="#实现Typora中图片自动的上传" class="headerlink" title="实现Typora中图片自动的上传"></a>实现Typora中图片自动的上传</h2><p>我们需要设置<code>PicGo Server</code>，如下图所示。</p><p><img src="http://img-repo.poetries.top/images/image-20210207102521859.png" alt="image-20210207102521859"></p><p><img src="http://img-repo.poetries.top/images/image-20210207102534331.png" alt="image-20210207102534331"></p><p>默认配置即可，只要保证端口没有被占用。</p><h3 id="Typora配置图片上传"><a href="#Typora配置图片上传" class="headerlink" title="Typora配置图片上传"></a>Typora配置图片上传</h3><p>设置好PicGo后来到Typora进行配置，打开Typora的文件菜单，选择“偏好设置”，选择“图像”，如下图所示。</p><p><img src="http://img-repo.poetries.top/images/image-20210207102543849.png" alt="image-20210207102543849"></p><ul><li>上传服务：选择PicGo</li><li>PicGo路径：选择PicGo安装根目录的文件</li></ul><p>配置好后，可以单击上图中的“验证图片上传选项”，来确定配置的正确性。</p><blockquote><p>之后就可以直接上传图片了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Typora 是一款简单、高效而且优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验。它把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果。Typora 的一切都围绕纯粹
      
    
    </summary>
    
      <category term="工欲善其事必先利其器" scheme="http://blog.poetries.top/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
      <category term="图床" scheme="http://blog.poetries.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>vue响应式原理</title>
    <link href="http://blog.poetries.top/2021/01/16/vue-reative/"/>
    <id>http://blog.poetries.top/2021/01/16/vue-reative/</id>
    <published>2021-01-16T09:20:22.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Vue 的响应式原理是核心是通过 ES5 的保护对象的 <code>Object.defindeProperty</code> 中的访问器属性中的 <code>get</code> 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 <code>get</code> 方法，当修改 <code>data</code> 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 <code>Wacher</code>，观察者 <code>Wacher</code>自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 <code>DOM</code> 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 <code>DOM</code>树上。</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2021/01/15.png" alt></p><blockquote><p>虚拟DOM (Virtaul DOM): 用 js 对象模拟的，保存当前视图内所有 DOM 节点对象基本描述属性和节点间关系的树结构。用 js 对象，描述每个节点，及其父子关系，形成虚拟 DOM 对象树结构。</p></blockquote><blockquote><p>因为只要在 <code>data</code> 中声明的基本数据类型的数据，基本不存在数据不响应问题，所以重点介绍数组和对象在<code>vue</code>中的数据响应问题，vue可以检测对象属性的修改，但无法监听数组的所有变动及对象的新增和删除，只能使用数组变异方法及<code>$set</code>方法。</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2021/01/16.png" alt></p><blockquote><p>可以看到，<code>arrayMethods</code> 首先继承了 <code>Array</code>，然后对数组中所有能改变数组自身的方法，如 <code>push</code>、<code>pop</code> 等这些方法进行重写。重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 <code>push</code>、<code>unshift</code>、<code>splice</code> 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 <code>ob.dep.notify()</code> 手动触发依赖通知，这就很好地解释了用 <code>vm.items.splice</code>(<code>newLength</code>) 方法可以检测到变化</p></blockquote><p><strong>向响应式的数组或者对象中修改已有的属性的方法</strong></p><blockquote><p>当想要修改对象或者属性，并非新增属性时，一个已经在 <code>data</code> 中声明过的响应式数据，可以直接操作改变，数据改变会经过上图的步骤，触发视图改变。直接<code>obj.xxx = xxx</code> 即可，数组除外，但是后台传过来的 json 数组，数组中嵌套的对象也可以直接修改数组中的对象，因为 <code>Object.defindeProperty</code> 的缺陷导致无法监听数组的变动，但始终会深度遍历data中数据，给数组中嵌套的对象添加上 get 和 set 方法，完成对对象的监听。所以数组中嵌套的对象的情况是可以直接修改数组中的对象，并且保持响应式</p></blockquote><p><strong>向响应式的数组或者对象中新增一个响应式的属性的方法this.$set()或者数组变异方法</strong></p><blockquote><p>  即使是一个后台传过来的 <code>json</code> 数组，也可以使用<code>this.$set</code>向数组中的其中一个对象中添加一个响应式的属性，例如 <code>this.$set(arr[0], &#39;xxx&#39;, xxx)</code> 。或者使用数组变异方法例如<code>splice</code>，更多数组变异方法可以参考vue文档</p></blockquote><p><strong>data中声明过的数组或者对象，整体替换数组或者对象保持响应式</strong></p><blockquote><p>向响应式的数组和对象替换为新的响应式数据，可直接复制，因为<code>data</code>中声明的数据已经添加了访问器属性<code>setter</code>，当重新赋值一个新的堆内存地址时，该数组或者对象也会被循环遍历添加访问器属性，所以也是有响应式的。</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2021/01/17.png" alt></p><p><strong>vue无法监听对象的新增和删除，直接通过obj.xxx = xxx新增一个没有的属性，同时修改当前组件的一个响应式的数据，会重新触发当前组件重新render，可以让非响应式数据也保持更新状态（并非响应式）</strong></p><blockquote><p>给一个数据添加一个非响应式的数据，例如一个已经在<code>data</code>中声明过的数据obj，<code>obj.xxx=xxx</code>,新增一个原本没有的数据，同时修改组件中一个其他的响应式数据，该<code>obj</code>也会同步更新到最新的数据，另一种情况，当你向一个对象或者数组中同时增加一个响应式和非响应式数据，非响应式数据也会同步更新到页面</p></blockquote><blockquote><p>总结：只要触发当前组件重新<code>render</code>,就可以让数据保持更新的状态，例如<code>this.$forceUpdate()</code></p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2021/01/18.png" alt></p><p><strong>为什么vue不能监听数组的变化</strong></p><blockquote><p><code>Object.defindProperty</code>虽然能够实现双向绑定了，但是还是有缺点，只能对对象的属性进行数据劫持，所以会深度遍历整个对象，不管层级有多深，只要数组中嵌套有对象，就能监听到对象的数据变化无法监听到数组的变化，Proxy就没有这个问题，可以监听整个对象的数据变化，所以用vue3.0会用<code>Proxy</code>代替definedProperty。</p></blockquote><p><strong>最后实现一个数据双向绑定原理</strong></p><p><img src="https://poetries1.gitee.io/img-repo/2021/01/19.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Vue 的响应式原理是核心是通过 ES5 的保护对象的 &lt;code&gt;Object.defindeProperty&lt;/code&gt; 中的访问器属性中的 &lt;code&gt;get&lt;/code&gt; 和 set 方法，data 中声明的属性都被添加了访问器属性，当读
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="vue" scheme="http://blog.poetries.top/tags/vue/"/>
    
      <category term="响应式原理" scheme="http://blog.poetries.top/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JS内存泄漏与垃圾回收机制</title>
    <link href="http://blog.poetries.top/2021/01/16/js-memory-leak/"/>
    <id>http://blog.poetries.top/2021/01/16/js-memory-leak/</id>
    <published>2021-01-16T07:55:24.000Z</published>
    <updated>2021-05-11T03:46:23.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><ul><li>程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存</li><li>对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃</li><li>不再用到的内存，没有及时释放，就叫做内存泄漏。</li><li>有些语言（比如c语言）必须手动释放内存，程序员负责内存管理</li><li>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”。</li></ul><blockquote><p>javascript垃圾回收机制原理：解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。</p></blockquote><h2 id="垃圾回收的必要性"><a href="#垃圾回收的必要性" class="headerlink" title="垃圾回收的必要性"></a>垃圾回收的必要性</h2><blockquote><p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃</p></blockquote><p>这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"before"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"override a"</span>;</span><br><span class="line"><span class="keyword">var</span> a = b; <span class="comment">//重写a</span></span><br></pre></td></tr></table></figure><blockquote><p>这段代码运行之后，“before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p></blockquote><h2 id="垃圾回收原理"><a href="#垃圾回收原理" class="headerlink" title="垃圾回收原理"></a>垃圾回收原理</h2><blockquote><p>现在各大浏览器通常用采用的垃圾回收有两种方法：<strong>标记清除</strong>、<strong>引用计数</strong></p></blockquote><h3 id="策略1：标记清除"><a href="#策略1：标记清除" class="headerlink" title="策略1：标记清除"></a>策略1：标记清除</h3><blockquote><p>这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p></blockquote><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间</p><ul><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记</li><li>去掉环境中的变量以及被环境中的变量引用的变量的标记</li><li>此后再被加上标记的变量将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了</li></ul><h3 id="策略2：引用计数"><a href="#策略2：引用计数" class="headerlink" title="策略2：引用计数"></a>策略2：引用计数</h3><blockquote><p>语言引擎有一张”引用表”，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。</p></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041703.png" alt></p><p>上图中，左下角的两个值，没有任何引用，所以可以释放</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，数组<code>[1,2,3,4]</code>是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存</p></blockquote><p>如果增加一行代码，解除arr对<code>[1,2,3,4]</code>引用，这块内存就可以被垃圾回收机制释放了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">arr = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，arr重置为null，就解除了对<code>[1，2，3，4]</code>的引用，引用次数变成了0，内存就可以释放出来了。</p></blockquote><blockquote><p>因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用</p></blockquote><p>再来下面来看看代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    objA.someOtherObject = objB;</span><br><span class="line">    objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露</p></blockquote><p>不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myObj.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject =<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>这样写代码的话就可以解决循环引用的问题了，也就防止了内存泄露的问题。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>如果存在循环引用的情况，那么这个引用值占的空间就永远不会被回收。</p></blockquote><h2 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><blockquote><p>一般来说没有被引用的对象就是垃圾，就是要被清除，有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。</p></blockquote><h3 id="如何检垃圾"><a href="#如何检垃圾" class="headerlink" title="如何检垃圾"></a>如何检垃圾</h3><ul><li>一种算法是标记 标记-清除 算法</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><ul><li><h1 id="JavaScript-内存泄漏教程"><a href="#JavaScript-内存泄漏教程" class="headerlink" title="JavaScript 内存泄漏教程"></a><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">JavaScript 内存泄漏教程</a></h1></li><li><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">JavaScript 内存泄漏教程</a><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>7c58ba165b59a7a915f47ba206b544c01c8425a5</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是内存泄漏？&quot;&gt;&lt;a href=&quot;#什么是内存泄漏？&quot; class=&quot;headerlink&quot; title=&quot;什么是内存泄漏？&quot;&gt;&lt;/a&gt;什么是内存泄漏？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存&lt;/li&gt;
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="垃圾回收" scheme="http://blog.poetries.top/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>webpack plugin原理分析与实践</title>
    <link href="http://blog.poetries.top/2021/01/05/webpack-plugin-summary/"/>
    <id>http://blog.poetries.top/2021/01/05/webpack-plugin-summary/</id>
    <published>2021-01-05T04:30:23.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><blockquote><p>在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果</p></blockquote><h3 id="如何实现一个插件"><a href="#如何实现一个插件" class="headerlink" title="如何实现一个插件"></a>如何实现一个插件</h3><blockquote><p>一个最基础的 Plugin 的代码是这样的：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPlugin</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在构造函数中获取用户给该插件传入的配置</span></span><br><span class="line">  <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span></span><br><span class="line">  apply(compiler)&#123;</span><br><span class="line">    compiler.plugin(<span class="string">'compilation'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">compilation,callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 Plugin</span></span><br><span class="line"><span class="built_in">module</span>.exports = BasicPlugin;</span><br></pre></td></tr></table></figure><p><strong>在使用这个 Plugin 时，相关配置代码如下：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BasicPlugin = <span class="built_in">require</span>(<span class="string">'./BasicPlugin.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> BasicPlugin(options),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Webpack 启动后，在读取配置的过程中会先执行 <code>new BasicPlugin(options)</code> 初始化一个 <code>BasicPlugin</code> 获得其实例。</li><li>在初始化 <code>compiler</code> 对象后，再调用 <code>basicPlugin.apply(compiler)</code> 给插件实例传入 <code>compiler</code> 对象。</li><li>插件实例在获取到 compiler 对象后，就可以通过 <code>compiler.plugin(事件名称, 回调函数)</code> 监听到 Webpack 广播出来的事件。</li><li>并且可以通过 <code>compiler</code>对象去操作 Webpack。</li></ul><p>通过以上最简单的 Plugin 相信你大概明白了 Plugin 的工作原理，但实际开发中还有很多细节需要注意，下面来详细介绍。</p><h3 id="Compiler-和-Compilation"><a href="#Compiler-和-Compilation" class="headerlink" title="Compiler 和 Compilation"></a>Compiler 和 Compilation</h3><blockquote><p>在开发 Plugin 时最常用的两个对象就是 Compiler 和 Compilation，它们是 Plugin 和 Webpack 之间的桥梁。</p></blockquote><ul><li>Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</li><li>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</li></ul><p><strong>Compiler 和 Compilation 的区别在于</strong>：<code>Compiler</code> 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。</p><blockquote><p>webpack 的源码compiler钩子函数是借助tapable库实现的</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    Tapable,</span><br><span class="line">    SyncHook,</span><br><span class="line">    SyncBailHook,</span><br><span class="line">    AsyncParallelHook,</span><br><span class="line">    AsyncSeriesHook</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> <span class="keyword">extends</span> <span class="title">Tapable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(context) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncBailHook&lt;Compilation&gt;&#125;</span> </span>*/</span></span><br><span class="line">          shouldEmit: <span class="keyword">new</span> SyncBailHook([<span class="string">"compilation"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;Stats&gt;&#125;</span> </span>*/</span></span><br><span class="line">          done: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"stats"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;&gt;&#125;</span> </span>*/</span></span><br><span class="line">          additionalPass: <span class="keyword">new</span> AsyncSeriesHook([]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;Compiler&gt;&#125;</span> </span>*/</span></span><br><span class="line">          beforeRun: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;Compiler&gt;&#125;</span> </span>*/</span></span><br><span class="line">          run: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;Compilation&gt;&#125;</span> </span>*/</span></span><br><span class="line">          emit: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compilation"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;string, Buffer&gt;&#125;</span> </span>*/</span></span><br><span class="line">          assetEmitted: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"file"</span>, <span class="string">"content"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;Compilation&gt;&#125;</span> </span>*/</span></span><br><span class="line">          afterEmit: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compilation"</span>]),</span><br><span class="line"></span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;Compilation, CompilationParams&gt;&#125;</span> </span>*/</span></span><br><span class="line">          thisCompilation: <span class="keyword">new</span> SyncHook([<span class="string">"compilation"</span>, <span class="string">"params"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;Compilation, CompilationParams&gt;&#125;</span> </span>*/</span></span><br><span class="line">          compilation: <span class="keyword">new</span> SyncHook([<span class="string">"compilation"</span>, <span class="string">"params"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;NormalModuleFactory&gt;&#125;</span> </span>*/</span></span><br><span class="line">          normalModuleFactory: <span class="keyword">new</span> SyncHook([<span class="string">"normalModuleFactory"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;ContextModuleFactory&gt;&#125;</span>  </span>*/</span></span><br><span class="line">          contextModuleFactory: <span class="keyword">new</span> SyncHook([<span class="string">"contextModulefactory"</span>]),</span><br><span class="line"></span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;CompilationParams&gt;&#125;</span> </span>*/</span></span><br><span class="line">          beforeCompile: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"params"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;CompilationParams&gt;&#125;</span> </span>*/</span></span><br><span class="line">          compile: <span class="keyword">new</span> SyncHook([<span class="string">"params"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncParallelHook&lt;Compilation&gt;&#125;</span> </span>*/</span></span><br><span class="line">          make: <span class="keyword">new</span> AsyncParallelHook([<span class="string">"compilation"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;Compilation&gt;&#125;</span> </span>*/</span></span><br><span class="line">          afterCompile: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compilation"</span>]),</span><br><span class="line"></span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;AsyncSeriesHook&lt;Compiler&gt;&#125;</span> </span>*/</span></span><br><span class="line">          watchRun: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;Error&gt;&#125;</span> </span>*/</span></span><br><span class="line">          failed: <span class="keyword">new</span> SyncHook([<span class="string">"error"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;string, string&gt;&#125;</span> </span>*/</span></span><br><span class="line">          invalid: <span class="keyword">new</span> SyncHook([<span class="string">"filename"</span>, <span class="string">"changeTime"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&#125;</span> </span>*/</span></span><br><span class="line">          watchClose: <span class="keyword">new</span> SyncHook([]),</span><br><span class="line"></span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncBailHook&lt;string, string, any[]&gt;&#125;</span> </span>*/</span></span><br><span class="line">          infrastructureLog: <span class="keyword">new</span> SyncBailHook([<span class="string">"origin"</span>, <span class="string">"type"</span>, <span class="string">"args"</span>]),</span><br><span class="line"></span><br><span class="line">          <span class="comment">// TODO the following hooks are weirdly located here</span></span><br><span class="line">          <span class="comment">// TODO move them for webpack 5</span></span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&#125;</span> </span>*/</span></span><br><span class="line">          environment: <span class="keyword">new</span> SyncHook([]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&#125;</span> </span>*/</span></span><br><span class="line">          afterEnvironment: <span class="keyword">new</span> SyncHook([]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;Compiler&gt;&#125;</span> </span>*/</span></span><br><span class="line">          afterPlugins: <span class="keyword">new</span> SyncHook([<span class="string">"compiler"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncHook&lt;Compiler&gt;&#125;</span> </span>*/</span></span><br><span class="line">          afterResolvers: <span class="keyword">new</span> SyncHook([<span class="string">"compiler"</span>]),</span><br><span class="line">          <span class="comment">/** <span class="doctag">@type <span class="type">&#123;SyncBailHook&lt;string, Entry&gt;&#125;</span> </span>*/</span></span><br><span class="line">          entryOption: <span class="keyword">new</span> SyncBailHook([<span class="string">"context"</span>, <span class="string">"entry"</span>])</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的钩子函数是在<code>webpack</code>解析代码的不同周期执行的</p></blockquote><ul><li>其中同步四种，异步并行两种，异步串行3种。</li><li>同步钩子进行同步操作；异步钩子中进行异步操作。</li></ul><blockquote><p><code>compiler</code>和<code>compilation</code>中的钩子都是自称自这9种钩子。钩子的工作机制类似于浏览器的事件监听。</p></blockquote><ul><li>生成的钩子可以注册监听事件，其中同步钩子通过tap方法监听，异步钩子通过tapAsync(+回调函数)和tapPromise(+返回promise)进行监听。</li><li>还可以进行拦截，通过intercept方法。</li><li>对于监听事件的触发，同步钩子通过call方法; 异步钩子通过callAsync方法和promise</li></ul><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><ul><li>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。</li><li>这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理</li><li>插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。</li><li>Webpack 通过 Tapable 来组织这条复杂的生产线。</li><li>Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。</li><li>Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</li><li>Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。</li><li><code>Compiler</code> 和 <code>Compilation</code> 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，方法如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 广播出事件</span></span><br><span class="line"><span class="comment">* event-name 为事件名称，注意不要和现有的事件重名</span></span><br><span class="line"><span class="comment">* params 为附带的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.apply(<span class="string">'event-name'</span>,params);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。</span></span><br><span class="line"><span class="comment">* 同时函数中的 params 参数为广播事件时附带的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.plugin(<span class="string">'event-name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>同理，<code>compilation.apply</code> 和 <code>compilation.plugin</code> 使用方法和上面一致。</p></blockquote><p>在开发插件时，你可能会不知道该如何下手，因为你不知道该监听哪个事件才能完成任务。</p><p><strong>在开发插件时，还需要注意以下两点：</strong></p><ul><li>只要能拿到 <code>Compiler</code> 或 <code>Compilation</code> 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。</li><li>传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件</li><li>有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'emit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">compilation, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 支持处理逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理完毕后执行 callback 以通知 Webpack </span></span><br><span class="line">  <span class="comment">// 如果不执行 callback，运行流程将会一直卡在这不往下执行 </span></span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><blockquote><p>插件可以用来修改输出文件、增加输出文件、甚至可以提升 Webpack 性能、等等，总之插件通过调用 Webpack 提供的 API 能完成很多事情。由于 Webpack 提供的 API 非常多，有很多 API 很少用的上，又加上篇幅有限，下面来介绍一些常用的 API。</p></blockquote><h3 id="读取输出资源、代码块、模块及其依赖"><a href="#读取输出资源、代码块、模块及其依赖" class="headerlink" title="读取输出资源、代码块、模块及其依赖"></a>读取输出资源、代码块、模块及其依赖</h3><p>有些插件可能需要读取 <code>Webpack</code> 的处理结果，例如输出资源、代码块、模块及其依赖，以便做下一步处理。</p><blockquote><p>在 emit 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// compilation.chunks 存放所有代码块，是一个数组</span></span><br><span class="line">      compilation.chunks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// chunk 代表一个代码块</span></span><br><span class="line">        <span class="comment">// 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块</span></span><br><span class="line">        chunk.forEachModule(<span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// module 代表一个模块</span></span><br><span class="line">          <span class="comment">// module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组</span></span><br><span class="line">          <span class="built_in">module</span>.fileDependencies.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filepath</span>) </span>&#123;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件</span></span><br><span class="line">        <span class="comment">// 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时，</span></span><br><span class="line">        <span class="comment">// 该 Chunk 就会生成 .js 和 .css 两个文件</span></span><br><span class="line">        chunk.files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// compilation.assets 存放当前所有即将输出的资源</span></span><br><span class="line">          <span class="comment">// 调用一个输出资源的 source() 方法能获取到输出资源的内容</span></span><br><span class="line">          <span class="keyword">let</span> source = compilation.assets[filename].source();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。</span></span><br><span class="line">      <span class="comment">// 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。</span></span><br><span class="line">      callback();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听文件变化"><a href="#监听文件变化" class="headerlink" title="监听文件变化"></a>监听文件变化</h3><blockquote><p>Webpack 会从配置的入口模块出发，依次找出所有的依赖模块，当入口模块或者其依赖的模块发生变化时,就会触发一次新的 Compilation。</p></blockquote><p>在开发插件时经常需要知道是哪个文件发生变化导致了新的 Compilation，为此可以使用如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当依赖的文件发生变化时会触发 watch-run 事件</span></span><br><span class="line">compiler.plugin(<span class="string">'watch-run'</span>, (watching, callback) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取发生变化的文件列表</span></span><br><span class="line">    <span class="keyword">const</span> changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;</span><br><span class="line">    <span class="comment">// changedFiles 格式为键值对，键为发生变化的文件路径。</span></span><br><span class="line">    <span class="keyword">if</span> (changedFiles[filePath] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// filePath 对应的文件发生了变化</span></span><br><span class="line">    &#125;</span><br><span class="line">    callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。</li><li>由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。</li><li>为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'after-compile'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译</span></span><br><span class="line">    compilation.fileDependencies.push(filePath);</span><br><span class="line">    callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="修改输出资源"><a href="#修改输出资源" class="headerlink" title="修改输出资源"></a>修改输出资源</h3><blockquote><p>有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 emit 事件，因为发生 emit 事件时所有模块的转换和代码块对应的文件已经生成好，需要输出的资源即将输出，因此 emit 事件是修改 Webpack 输出资源的最后时机。</p></blockquote><p>所有需要输出的资源会存放在 <code>compilation.assets</code> 中，<code>compilation.assets</code> 是一个键值对，<strong>键为需要输出的文件名称，值为文件对应的内容</strong>。</p><p><strong>设置 compilation.assets 的代码如下：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'emit'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设置名称为 fileName 的输出资源</span></span><br><span class="line">  compilation.assets[fileName] = &#123;</span><br><span class="line">    <span class="comment">// 返回文件内容</span></span><br><span class="line">    source: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer</span></span><br><span class="line">      <span class="keyword">return</span> fileContent;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 返回文件大小</span></span><br><span class="line">    size: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Buffer.byteLength(fileContent, <span class="string">'utf8'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>读取 <code>compilation.assets</code> 的代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'emit'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取名称为 fileName 的输出资源</span></span><br><span class="line">  <span class="keyword">const</span> asset = compilation.assets[fileName];</span><br><span class="line">  <span class="comment">// 获取输出资源的内容</span></span><br><span class="line">  asset.source();</span><br><span class="line">  <span class="comment">// 获取输出资源的文件大小</span></span><br><span class="line">  asset.size();</span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="判断-Webpack-使用了哪些插件"><a href="#判断-Webpack-使用了哪些插件" class="headerlink" title="判断 Webpack 使用了哪些插件"></a>判断 Webpack 使用了哪些插件</h3><blockquote><p>在开发一个插件时可能需要根据当前配置是否使用了其它某个插件而做下一步决定，因此需要读取 Webpack 当前的插件配置情况。以判断当前是否使用了 ExtractTextPlugin 为例，可以使用如下代码：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前配置使用使用了 ExtractTextPlugin，</span></span><br><span class="line"><span class="comment">// compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasExtractTextPlugin</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前配置所有使用的插件列表</span></span><br><span class="line">  <span class="keyword">const</span> plugins = compiler.options.plugins;</span><br><span class="line">  <span class="comment">// 去 plugins 中寻找有没有 ExtractTextPlugin 的实例</span></span><br><span class="line">  <span class="keyword">return</span> plugins.find(<span class="function"><span class="params">plugin</span>=&gt;</span>plugin.__proto__.constructor === ExtractTextPlugin) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="在-Webpack-即将退出时再附加一些额外的操作"><a href="#在-Webpack-即将退出时再附加一些额外的操作" class="headerlink" title="在 Webpack 即将退出时再附加一些额外的操作"></a>在 Webpack 即将退出时再附加一些额外的操作</h3><ul><li>该插件的名称取名叫 EndWebpackPlugin，作用是在 Webpack 即将退出时再附加一些额外的操作，例如在 Webpack 成功编译和输出了文件后执行发布操作把输出的文件上传到服务器。</li><li>同时该插件还能区分 Webpack 构建是否执行成功。使用该插件时方法如下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="comment">// 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数；</span></span><br><span class="line">    <span class="keyword">new</span> EndWebpackPlugin(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作</span></span><br><span class="line">    &#125;, (err) =&gt; &#123;</span><br><span class="line">      <span class="comment">// Webpack 构建失败，err 是导致错误的原因</span></span><br><span class="line">      <span class="built_in">console</span>.error(err);        </span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要实现该插件，需要借助两个事件：</strong></p><ul><li><code>done</code>：在成功构建并且输出了文件后，Webpack 即将退出时发生；</li><li><code>failed</code>：在构建出现异常导致构建失败，Webpack 即将退出时发生；</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EndWebpackPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(doneCallback, failCallback) &#123;</span><br><span class="line">    <span class="comment">// 存下在构造函数中传入的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.doneCallback = doneCallback;</span><br><span class="line">    <span class="keyword">this</span>.failCallback = failCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.plugin(<span class="string">'done'</span>, (stats) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在 done 事件中回调 doneCallback</span></span><br><span class="line">        <span class="keyword">this</span>.doneCallback(stats);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.plugin(<span class="string">'failed'</span>, (err) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在 failed 事件中回调 failCallback</span></span><br><span class="line">        <span class="keyword">this</span>.failCallback(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出插件 </span></span><br><span class="line"><span class="built_in">module</span>.exports = EndWebpackPlugin;</span><br></pre></td></tr></table></figure><blockquote><p>找到合适的事件点去完成功能在开发插件时显得尤为重要</p></blockquote><h3 id="生成各个文件的大小到指定目录文件中"><a href="#生成各个文件的大小到指定目录文件中" class="headerlink" title="生成各个文件的大小到指定目录文件中"></a>生成各个文件的大小到指定目录文件中</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成各个文件的大小到指定目录文件中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileListPlugin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options</span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.emit.tap(<span class="string">'fileListPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> assets = compilation.assets</span><br><span class="line">            <span class="keyword">let</span> content = <span class="string">'In this build:\r\n'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历所有编译过的资源文件，</span></span><br><span class="line">            <span class="comment">// 对于每个文件名称，都添加一行内容。</span></span><br><span class="line">            <span class="built_in">Object</span>.entries(assets).forEach(<span class="function">(<span class="params">[fileName, fileSize]</span>) =&gt;</span> &#123;</span><br><span class="line">                content += <span class="string">`--<span class="subst">$&#123;fileName&#125;</span> —— <span class="subst">$&#123;<span class="built_in">Math</span>.ceil(fileSize.size() <span class="regexp">/ 1024)&#125;kb\r\n`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">            &#125;)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">            console.log('====content====', content)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">            /</span><span class="regexp">/ 将这个列表作为一个新的文件资源，插入到 webpack 构建中：</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">            assets[this.options.filename] = &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">                source() &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">                    return content</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">                &#125;,</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">                size() &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">                    return content.length</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">                &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">            &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">        &#125;)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">    &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">module.exports = FileListPlugin</span></span></span></span><br></pre></td></tr></table></figure><p><strong>在vue cli3中使用例子</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const FileListPlugin = require('./plugins/fileListPlugin.js')</span></span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="keyword">new</span> FileListPlugin(&#123;<span class="string">'filename'</span>: path.join(<span class="string">'..'</span>,<span class="string">'filelist.md'</span>)&#125;)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2021/01/13.png" alt></p><h3 id="生成版权信息"><a href="#生成版权信息" class="headerlink" title="生成版权信息"></a>生成版权信息</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyRightWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.options = options</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">      compiler.hooks.compile.tap(<span class="string">'webpackCompiler'</span>, () =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'compiler'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      compiler.hooks.emit.tapAsync(<span class="string">'CopyRightWebpackPlugin'</span>, (compilation, cb) =&gt; &#123;</span><br><span class="line">          compilation.assets[<span class="keyword">this</span>.options.filename] = &#123;</span><br><span class="line">              source() &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">'copyRight by poetries'</span></span><br><span class="line">              &#125;,</span><br><span class="line">              size() &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="number">25</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          cb()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = CopyRightWebpackPlugin</span><br></pre></td></tr></table></figure><p><strong>在vue cli3中使用例子</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const CopyRightWebpackPlugin = require('./plugins/copyRightWebpackPlugin.js')</span></span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> CopyRightWebpackPlugin(&#123;<span class="string">'filename'</span>: <span class="string">'copyRight.md'</span>&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2021/01/14.png" alt></p><h3 id="打包zip插件"><a href="#打包zip插件" class="headerlink" title="打包zip插件"></a>打包zip插件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> JsZip = <span class="built_in">require</span>(<span class="string">'jszip'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// emit是一个异步串行钩子</span></span><br><span class="line">    compiler.hooks.emit.tapPromise(<span class="string">'1'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> assets = compilation.assets;</span><br><span class="line">      <span class="keyword">const</span> zip = <span class="keyword">new</span> JsZip();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> filename <span class="keyword">in</span> assets) &#123;</span><br><span class="line">        zip.file(filename, assets[filename].source())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// nodebuffer是node环境中的二进制形式；blob是浏览器环境</span></span><br><span class="line">      <span class="keyword">return</span> zip.generateAsync(&#123;<span class="attr">type</span>: <span class="string">'nodebuffer'</span>&#125;).then(<span class="function">(<span class="params">content</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.options.filename);</span><br><span class="line">        assets[<span class="keyword">this</span>.options.filename] = &#123;</span><br><span class="line">          source() &#123;<span class="keyword">return</span> content&#125;, </span><br><span class="line">          size() &#123;<span class="keyword">return</span> content.length&#125; <span class="comment">//可以省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(compilation)</span><br><span class="line">        &#125;)   </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ZipPlugin;</span><br></pre></td></tr></table></figure><p>在<code>webpack.config.js</code>中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ZipPlugin = <span class="built_in">require</span>(<span class="string">'./plugins/ZipPlugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ZipPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'my.zip'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.webpackjs.com/contribute/writing-a-plugin/" target="_blank" rel="noopener">编写一个插件-webpack官方教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理分析&quot;&gt;&lt;a href=&quot;#原理分析&quot; class=&quot;headerlink&quot; title=&quot;原理分析&quot;&gt;&lt;/a&gt;原理分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="webpack" scheme="http://blog.poetries.top/tags/webpack/"/>
    
      <category term="插件" scheme="http://blog.poetries.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>初探vscode插件开发</title>
    <link href="http://blog.poetries.top/2021/01/03/vscode-plugin/"/>
    <id>http://blog.poetries.top/2021/01/03/vscode-plugin/</id>
    <published>2021-01-03T07:01:24.000Z</published>
    <updated>2021-05-11T03:46:23.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>趁着元旦假期最后一天，初次尝试了一下vscode插件开发，写了一个前端工具箱作为日常方便使用，记录一下</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2020/12/screenshot.png" alt></p><blockquote><p>在vscode插件里面搜索：前端工具箱。或打开该网址安装即可 <a href="https://marketplace.visualstudio.com/items?itemName=poetries.fe-tools" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=poetries.fe-tools</a></p></blockquote><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><blockquote><p>我们先准备开发环境。我使用的操作系统：mac，首先确保安装了VS Code、Node.js 和 Git：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code -v</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://code.visualstudio.com/api/get-started/your-first-extension" target="_blank" rel="noopener">https://code.visualstudio.com/api/get-started/your-first-extension</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br></pre></td></tr></table></figure><blockquote><p>使用yo code指令初始化VSCode插件项目，然后需要回答一些简单的配置问题</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yo code</span><br><span class="line"></span><br><span class="line"><span class="comment"># What type of extension do you want to create? </span></span><br><span class="line"><span class="comment"># 创建那一种类型的扩展？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># What's the name of your extension?</span></span><br><span class="line"><span class="comment"># 扩展的名称？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># What's the identifier of your extension?</span></span><br><span class="line"><span class="comment"># 扩展的标示？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># What's the description of your extension?</span></span><br><span class="line"><span class="comment"># 扩展的描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a git repository? </span></span><br><span class="line"><span class="comment"># 初始化git仓库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which package manager to use? </span></span><br><span class="line"><span class="comment"># 使用那一种包管理器</span></span><br></pre></td></tr></table></figure><h2 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h2><blockquote><p>使用 VS Code 打开项目，在编辑器内部，按F5，编译并打开一个“扩展开发宿主机”窗口运行调试插件。为了叙述方便，把新打开的窗口称为运行窗口，旧窗口称为编辑窗口。在新窗口的命令面板（<code>Ctrl+Shift+P</code>） 运行 Hello World 命令。看到右下角的 Hello World 通知信息了吗？恭喜你已经运行了一个自己编写的插件！</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2021/01/3.gif" alt></p><h2 id="调试插件"><a href="#调试插件" class="headerlink" title="调试插件"></a>调试插件</h2><blockquote><p>使用 VS Code 调试扩展插件很容易。这里演示一下如何设置断点。在编辑窗口打开 extension.js 文件， 点击编辑器行号左侧的边栏设置断点。在运行窗口 命令面板输入 Hello World 命令运行插件，命中断点。</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2021/01/4.gif" alt></p><h3 id="调试webview"><a href="#调试webview" class="headerlink" title="调试webview"></a>调试webview</h3><blockquote><p>按F5打开调试模式，在webview页面，按<code>command+shift+p</code>选择open webview</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2021/01/10.png" alt><br><img src="https://poetries1.gitee.io/img-repo/2021/01/11.png" alt></p><h2 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h2><blockquote><p>接下来我们来深入研究一下 helloworld 插件。 helloworld 的功能很简单，就是用户可以在命令面板执行 Hello World 命令，输出 Hello World 信息</p></blockquote><p><strong>从实现的角度来看，helloworld 插件做了三件事：</strong></p><ul><li>注册激活事件 <code>onCommand:extension.helloWorld</code>：插件在<code>extension.helloWorld</code> 触发时被激活。</li><li>注册贡献点 <code>contributes.commands:extension.helloWorld</code>：在命令面板中使能 <code>hello world</code> 命令，并将其绑定到 <code>extension.helloworld</code>。</li><li>调用 <code>VS Code API commands.registerCommand</code> 给注册的命令 <code>extension.helloWorld</code>绑定处理函数。</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>简单解释一下上面提到的三个概念：激活事件、贡献点和接口：</p></blockquote><ul><li><strong>激活事件</strong>，译自 Activation Events，在配置清单 package.json 中静态声明，其实就是 JSON 数组 <code>activationEvents</code> 的值。当激活事件发生时，声明的扩展将被激活。以下是目前所有可用激活事件：<code>onLanguage</code>、<code>onCommand</code>、<code>onDebug:onDebugInitialConfigurations</code>、<code>onDebugResolve</code>、<code>workspaceContains</code>、<code>onFileSystem</code>、<code>onView</code>、<code>onUri</code>、<code>onWebviewPanel</code>、*；</li><li><strong>贡献点</strong>，译自 <code>Contribution Points</code>，在配置清单 <code>package.json</code> 中静态声明，贡献点其实就是VS Code 的可以扩展的功能点。以下是目前所有可用的贡献点：<code>configuration</code>、<code>configurationDefaults</code>、<code>commands</code>、<code>menus</code>、<code>keybindings</code>、<code>languages</code>、<code>debuggers</code>、<code>breakpoints</code>、<code>grammars</code>、<code>themes</code>、<code>snippets</code>、<code>jsonValidation</code>、<code>views</code>、<code>viewsContainers</code>、<code>problemMatchers</code>、<code>problemPatterns taskDefinitions</code>、<code>colors</code>、<code>typescriptServerPlugins</code>、<code>resourceLabelFormatters</code>、<code>contributes.configur</code>。</li><li><strong>VS Code 接口</strong>：可以在扩展代码中调用的一组 JavaScript API。链接中列举了所有可用的API，熟悉基本的，其他的用到的时候按需查找就行了。</li></ul><blockquote><p>一般来说，插件都会使用到这三个概念：<strong>激活事件</strong>、<strong>贡献点</strong>和 <strong>VS Code API</strong>。接下来我们分析一下 HelloWorld 示例的源代码，看看它是如何使用这些概念的。</p></blockquote><h3 id="JavaScript-插件目录结构"><a href="#JavaScript-插件目录结构" class="headerlink" title="JavaScript 插件目录结构"></a>JavaScript 插件目录结构</h3><p><img src="https://poetries1.gitee.io/img-repo/2021/01/5.jpeg" alt></p><blockquote><p>VS Code 插件的目录结构很简单，根据命名大概就能知道作用。不同项目类型目录结构可能会有很大不同。对于 JavaScript 类型的项目来说，最重要的就是<code>package.json</code> 和 <code>extension.js</code> 。</p></blockquote><h3 id="清单文件：package-json"><a href="#清单文件：package-json" class="headerlink" title="清单文件：package.json"></a>清单文件：package.json</h3><blockquote><p>每个 VS Code 插件都必须有一个用来描述插件的清单文件 package.json。VS Code 的清单文件是声明式的 JSON 格式，用于声明插件名（name）、插件展示名（ <code>displayName</code> ）、描述信息（<code>description</code>）、版本（ version ）、引擎（ engines ）、类别（ categories ）、依赖（ devDependencies ）、脚本 （scripts）、贡献点（ contributes ）、入口文件（ main ）、激活事件（ activationEvents ）等。</p></blockquote><blockquote><p>下面是 helloworld 插件的清单文件内容，为了便于理解，我加了一些注释。</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"helloworld"</span>, <span class="comment">//插件名</span></span><br><span class="line">    <span class="attr">"displayName"</span>: <span class="string">"helloworld"</span>, <span class="comment">// 插件市场显示的插件名，支持中文</span></span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"demo"</span>, <span class="comment">// 插件市场显示的描述信息</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>, <span class="comment">// 版本号</span></span><br><span class="line">    <span class="comment">// 最低支持的 VS Code 版本</span></span><br><span class="line">    <span class="attr">"engines"</span>: &#123;</span><br><span class="line">        <span class="attr">"vscode"</span>: <span class="string">"^1.38.0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 插件市场分类</span></span><br><span class="line">    <span class="attr">"categories"</span>: [</span><br><span class="line">        <span class="string">"Other"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 激活事件</span></span><br><span class="line">    <span class="attr">"activationEvents"</span>: [</span><br><span class="line">        <span class="string">"onCommand:extension.helloWorld"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"./extension.js"</span>, <span class="comment">// 指定入口文件</span></span><br><span class="line">    <span class="comment">// 贡献点</span></span><br><span class="line">    <span class="attr">"contributes"</span>: &#123;</span><br><span class="line">        <span class="attr">"commands"</span>: [&#123;</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"extension.helloWorld"</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Hello World"</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 脚本</span></span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"test"</span>: <span class="string">"node ./test/runTest.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 依赖，包含版本信息</span></span><br><span class="line">    <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"@types/glob"</span>: <span class="string">"^7.1.1"</span>,</span><br><span class="line">        <span class="attr">"@types/mocha"</span>: <span class="string">"^5.2.6"</span>,</span><br><span class="line">        <span class="attr">"@types/node"</span>: <span class="string">"^10.12.21"</span>,</span><br><span class="line">        <span class="attr">"@types/vscode"</span>: <span class="string">"^1.38.0"</span>,</span><br><span class="line">        <span class="attr">"eslint"</span>: <span class="string">"^5.13.0"</span>,</span><br><span class="line">        <span class="attr">"glob"</span>: <span class="string">"^7.1.4"</span>,</span><br><span class="line">        <span class="attr">"mocha"</span>: <span class="string">"^6.1.4"</span>,</span><br><span class="line">        <span class="attr">"typescript"</span>: <span class="string">"^3.3.1"</span>,</span><br><span class="line">        <span class="attr">"vscode-test"</span>: <span class="string">"^1.2.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件入口文件：extension-js"><a href="#插件入口文件：extension-js" class="headerlink" title="插件入口文件：extension.js"></a>插件入口文件：extension.js</h3><blockquote><p>插件的入口文件是在清单文件中指定的，如果项目比较大，源文件比较多，也可以统一放在 src 目录里。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The module 'vscode' contains the VS Code extensibility API</span></span><br><span class="line"><span class="comment">// Import the module and reference it with the alias vscode in your code below</span></span><br><span class="line"><span class="comment">/* 导入 "vscode" 模块，这个模块包含 VS Code 的扩展接口。 */</span> </span><br><span class="line"><span class="keyword">const</span> vscode = <span class="built_in">require</span>(<span class="string">'vscode'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this method is called when your extension is activated</span></span><br><span class="line"><span class="comment">// your extension is activated the very first time the command is executed</span></span><br><span class="line"><span class="comment">// 第一次执行命令时，插件会被激活；插件被激活时，这个函数会被调用</span></span><br><span class="line"><span class="comment">// 必须在入口中实现这个函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;vscode.ExtensionContext&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the console to output diagnostic information (console.log) and errors (console.error)</span></span><br><span class="line">    <span class="comment">// This line of code will only be executed once when your extension is activated</span></span><br><span class="line">    <span class="comment">/* 输出诊断日志到控制台 */</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Congratulations, your extension "helloworld" is now active!'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The command has been defined in the package.json file</span></span><br><span class="line">    <span class="comment">// Now provide the implementation of the command with  registerCommand</span></span><br><span class="line">    <span class="comment">// The commandId parameter must match the command field in package.json</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这个命令 extension.helloWorld 已经在 package.json 文件中定义了。</span></span><br><span class="line"><span class="comment">     * 现在我们使用 registerCommand 接口给这个命令绑定实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> disposable = vscode.commands.registerCommand(<span class="string">'extension.helloWorld'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// The code you place here will be executed every time your command is executed</span></span><br><span class="line">        <span class="comment">/* 每一次执行命令，这儿的代码都会执行 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Display a message box to the user</span></span><br><span class="line">        vscode.window.showInformationMessage(<span class="string">'Hello World!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br><span class="line">exports.activate = activate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this method is called when your extension is deactivated</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    activate,</span><br><span class="line">    deactivate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个插件必须在其主模块实现并导出 <code>activate()</code>和 <code>deactivate()</code> 函数。</p></blockquote><ul><li><code>activate()</code> 函数 初始化插件。当任何指定的激活事件发生时，VS Code 会调用并且只调用它一次。</li><li><code>deactivate()</code> 函数 清理插件。如果清理过程是异步的， <code>deactivate()</code> 函数必须返回一个 Promise 对象。如果清理运行同步，则 <code>deactivate()</code> 函数返回 <code>undefined</code> 。</li></ul><h2 id="Webview"><a href="#Webview" class="headerlink" title="Webview"></a>Webview</h2><blockquote><p>插件可以分为多种，比如主题样式类型的插件，图标插件，语言支持类型的插件。Webview类型的插件只是Vscode插件的一个大类。大致的实现大家可以参考文档，文档的示例使用的是html字符串，但这不适合复杂的Webview的开发。在GameNews这个插件中，模版部分，我使用了vue以及pug。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态资源的目录。绝对路径，并且使用了vscode-resource协议</span></span><br><span class="line"><span class="comment">// vscode-resource:/Users/Desktop/game-news/views</span></span><br><span class="line"><span class="keyword">const</span> webviewDir = path.join(context.extensionPath, <span class="string">'views'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Webview的面板</span></span><br><span class="line"><span class="keyword">const</span> panel = vscode.window.createWebviewPanel(</span><br><span class="line">    viewType,</span><br><span class="line">    title,</span><br><span class="line">    vscode.ViewColumn.One,</span><br><span class="line">    &#123;</span><br><span class="line">        enableScripts: <span class="literal">true</span>, <span class="comment">// 允许运行js脚本，默认是关闭的</span></span><br><span class="line">        retainContextWhenHidden: <span class="literal">true</span>, <span class="comment">// webview不可见时，脚本就会被挂起</span></span><br><span class="line">        <span class="comment">// 指定允许加载的本地资源的根目录</span></span><br><span class="line">        localResourceRoots: [vscode.Uri.file(webviewDir)]</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版文件</span></span><br><span class="line"><span class="keyword">const</span> tpl = path.join(webviewDir, <span class="string">'index.pug'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过pug渲染模版文件，到webview上</span></span><br><span class="line">panel.webview.html = pug.renderFile(tpl, options);</span><br></pre></td></tr></table></figure><h3 id="本地资源的使用"><a href="#本地资源的使用" class="headerlink" title="本地资源的使用"></a>本地资源的使用</h3><blockquote><p>Webview中，我们会需要使用本地的css，js文件。虽然可以使用行间js或者行间样式，但是总归不太好。使用本地文件，就会涉及的静态文件路径的问题，在VScode中，我们需要使用绝对路径。并且是vscode-resource协议的路径。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webviewDir = path.join(context.extensionPath, <span class="string">'views'</span>);</span><br><span class="line"><span class="comment">// 静态资源的绝对目录</span></span><br><span class="line"><span class="keyword">let</span> URI = vscode.Uri.file(path.join(webviewDir, <span class="string">'js'</span>, <span class="string">'vue.js'</span>))</span><br><span class="line"><span class="comment">// 使用vscode-resource协议头</span></span><br><span class="line"><span class="comment">// 然后这个URL就可以使用在我们的webview的模版中了</span></span><br><span class="line">URI = URI.with(&#123; <span class="attr">scheme</span>: <span class="string">'vscode-resource'</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="Webview与插件通信"><a href="#Webview与插件通信" class="headerlink" title="Webview与插件通信"></a>Webview与插件通信</h3><blockquote><p>Webview相当于一个网页，而网页是无法调用一些本地功能的。但是插件本身是运行在node环境的，而已我们可以通过插件实现一些在网页中无法完成的功能。Webview如果通知插件呢？这涉及到了Webview于网页的通信机制。</p></blockquote><p>下面是GameNews插件的例子，我通过事件将游戏新闻的url，发送给插件。插件会调用系统的命令，使用本地的浏览器打开url。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webview</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// webview中，一个内置的全局api</span></span><br><span class="line"><span class="keyword">const</span> vscode = acquireVsCodeApi()</span><br><span class="line"></span><br><span class="line">vscode.postMessage(&#123;</span><br><span class="line">    command: <span class="string">'preview'</span>,</span><br><span class="line">    text: url</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件</span></span><br><span class="line">panel.webview.onDidReceiveMessage(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.command) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'preview'</span>:</span><br><span class="line">            <span class="comment">// 打开浏览器</span></span><br><span class="line">            open(message.text);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">undefined</span>, context.subscriptions);</span><br></pre></td></tr></table></figure><blockquote><p>更多参考文档：<a href="https://code.visualstudio.com/api/extension-guides/webview" target="_blank" rel="noopener">https://code.visualstudio.com/api/extension-guides/webview</a></p></blockquote><h2 id="打包、发布和升级"><a href="#打包、发布和升级" class="headerlink" title="打包、发布和升级"></a>打包、发布和升级</h2><blockquote><p>如何让别人也能使用自己开发的插件呢？这和移动应用开发一样，有两种方式：</p></blockquote><ul><li>把它发布到 VS Code 插件市场，这样其他人就可以找到、下载和使用你的插件。</li><li>或者，可以将插件打包为可安装的<code>vsix</code>格式，并与其他用户共享。</li></ul><blockquote><p>vsce，简写自 Visual Studio Code Extensions， 是用于打包、发布和管理 VS Code 插件的命令行工具</p></blockquote><p>先安装 <code>Node.js</code> ，然后运行 <code>npm install -g vsce</code> 安装 <code>vsce</code>。在插件的根目录下运行 <code>vsce package</code> 打包插件，运行 <code>vsce publish</code> 发布插件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g vsce</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vsce create-publisher poetry <span class="comment"># 这一步先创建一个发布账号，需要用到token，看下面步骤获取token</span></span><br><span class="line">vsce package <span class="comment">#打包插件 .vsix 格式</span></span><br><span class="line">vsce publish <span class="comment">#发布到 MarketPlace</span></span><br></pre></td></tr></table></figure><p>发布插件到 <code>VS Code</code> 插件市场，需要注册开发者账号。有关如何发布插件的内容很简单，可以参考官方文档这一部分的内容：<a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension" target="_blank" rel="noopener">https://code.visualstudio.com/api/working-with-extensions/publishing-extension</a></p><ul><li>在Visual Studio Team Services 创建一个账号</li><li><p>根据账号的名字访问主页，例如我的名字是bingou-ms，<a href="https://login.microsoftonline.com/common/oauth2/authorize?client_id=499b84ac-1321-427f-aa17-267ca6975798&amp;site_id=501454&amp;response_mode=form_post&amp;response_type=code+id_token&amp;redirect_uri=https%3A%2F%2Fspsprodea1.vssps.visualstudio.com%2F_signedin&amp;nonce=58d775e1-0aec-4083-a57d-14f1328f132c&amp;state=realm%3Dbingou-ms.visualstudio.com%26reply_to%3Dhttps%253A%252F%252Fbingou-ms.visualstudio.com%252F%26ht%3D2%26hid%3D00672ded-af5d-4302-9485-09c5e20f9667%26nonce%3D58d775e1-0aec-4083-a57d-14f1328f132c&amp;resource=https%3A%2F%2Fmanagement.core.windows.net%2F&amp;cid=58d775e1-0aec-4083-a57d-14f1328f132c&amp;wsucxt=1&amp;githubsi=true&amp;msaoauth2=true&amp;sso_reload=true" target="_blank" rel="noopener">主页链接就是</a></p></li><li><p>创建Personal Access Token</p></li></ul><p><img src="https://poetries1.gitee.io/img-repo/2021/01/7.png" alt><br><img src="https://poetries1.gitee.io/img-repo/2021/01/8.png" alt></p><blockquote><p>需要将Accounts设置为All accessible accounts</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2021/01/9.png" alt></p><blockquote><p>那么如何升级已经发布到插件市场的插件呢？修改/增加版本号，然后再执行 <code>vsce publish</code> 即可。</p></blockquote><p><strong>安装vsix文件</strong></p><blockquote><p>可以直接安装vsce package的vsix文件，方便在本地进行调试。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code --install-extension vsix文件名</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://code.visualstudio.com/api/references/vscode-api" target="_blank" rel="noopener">vscode API文档</a></li><li><a href="https://code.visualstudio.com/api/extension-guides/overview" target="_blank" rel="noopener">vscode插件开发文档</a></li><li><a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/get-started/your-first-extension" target="_blank" rel="noopener">中文文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;趁着元旦假期最后一天，初次尝试了一下vscode插件开发，写了一个前端工具箱作为日常方便使用，记录一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://poetries1.gitee.io/img-repo/2020/
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="插件" scheme="http://blog.poetries.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="vscode" scheme="http://blog.poetries.top/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>小程序绘制海报总结</title>
    <link href="http://blog.poetries.top/2021/01/02/weapp-post/"/>
    <id>http://blog.poetries.top/2021/01/02/weapp-post/</id>
    <published>2021-01-02T04:01:24.000Z</published>
    <updated>2021-05-11T03:46:23.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成海报方式一"><a href="#生成海报方式一" class="headerlink" title="生成海报方式一"></a>生成海报方式一</h2><p><strong>封装成组件方便调用</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"component"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"van-popup"</span>: <span class="string">"@vant/weapp/popup/index"</span>,</span><br><span class="line">    <span class="attr">"van-icon"</span>: <span class="string">"@vant/weapp/icon/index"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas canvas-id=&quot;poster-share&quot; class=&quot;poster&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;view bind:tap=&quot;handleShare&quot;&gt;</span><br><span class="line">&lt;slot wx:if=&quot;&#123;&#123;useSlot&#125;&#125;&quot; /&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;van-popup custom-class=&quot;page-van-popup&quot; show=&quot;&#123;&#123; showShare &#125;&#125;&quot; bind:close=&quot;shareClose&quot;&gt;</span><br><span class="line">&lt;view class=&quot;df fxdc h100v w100v&quot; wx:if=&quot;&#123;&#123;showShare&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;view class=&quot;df jcc aic fxa posr mt120&quot; bind:tap=&quot;shareClose&quot;&gt;</span><br><span class="line">&lt;image class=&quot;poster-image&quot; src=&quot;&#123;&#123; tempFilePath &#125;&#125;&quot; mode=&quot;aspectFit&quot; /&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;fxn h238 bgfff df aic jcc bdrs16t&quot;&gt;</span><br><span class="line">&lt;view class=&quot;fxa w0 df aic jcc&quot;&gt;</span><br><span class="line">&lt;view class=&quot;df fxdc posr&quot;&gt;</span><br><span class="line">&lt;button class=&quot;posa t0 l0 w100p h100p op0&quot; open-type=&quot;share&quot; /&gt;</span><br><span class="line">&lt;image class=&quot;h108 w108&quot; src=&quot;./assets/ic_fenxiang.svg&quot; /&gt;</span><br><span class="line">&lt;text class=&quot;mt16 c333 fz28&quot;&gt;分享好友&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;fxa w0 df aic jcc&quot;&gt;</span><br><span class="line">&lt;view class=&quot;df fxdc&quot; bind:tap=&quot;savePicture&quot;&gt;</span><br><span class="line">&lt;image class=&quot;h108 w108&quot; src=&quot;./assets/ic_baocun.svg&quot; /&gt;</span><br><span class="line">&lt;text class=&quot;mt16 c333 fz28&quot;&gt;保存图片&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/van-popup&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"../../../../libs/wxss/index.wxss"</span>;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.h377</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">377</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.h417</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">417</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pb70</span> &#123;</span><br><span class="line"><span class="attribute">padding-bottom</span>: <span class="number">70</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bgview</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">651</span>rpx;</span><br><span class="line"><span class="attribute">opacity</span>: .<span class="number">63</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tip</span>,</span><br><span class="line"><span class="selector-class">.share</span> &#123;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">100</span>rpx <span class="number">0</span> <span class="number">0</span> <span class="number">100</span>rpx;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">88</span>rpx;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">36</span>rpx;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#ffd300</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#007142</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tip</span> &#123;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">75</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.share</span> &#123;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">140</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title-wrap</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">85</span>rpx;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#fff0e5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shopping-num</span> &#123;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">15</span>rpx;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">28</span>rpx;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, rgba(<span class="number">255</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="number">0%</span>, <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">163</span>, <span class="number">41</span>, <span class="number">1</span>) <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.page-van-popup</span> &#123;</span><br><span class="line"><span class="attribute">--popup-background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.popup__content</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">590</span>rpx;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">800</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.poster</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: fixed;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">top</span>: -<span class="number">1000000px</span>;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">1000</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">570px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">920px</span>;</span><br><span class="line"><span class="attribute">pointer-events</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nodata</span> &#123;</span><br><span class="line"><span class="attribute">padding-top</span>: <span class="number">150</span>rpx;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">700</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.count-down</span> <span class="selector-class">.van-count-down</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200</span>rpx;</span><br><span class="line"><span class="attribute">line-height</span>: unset;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20</span>rpx;</span><br><span class="line"><span class="attribute">color</span>: unset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.poster-image</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">690</span>rpx;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">920</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cffffff88</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#fff88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.w252</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">252</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// layer/component/sharePoster/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; rGetShareErCode &#125; <span class="keyword">from</span> <span class="string">'../../../../netapi/redPackets/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; KEY_APP_ID &#125; <span class="keyword">from</span> <span class="string">'../../../../constants/config'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; stringLimit &#125; <span class="keyword">from</span> <span class="string">'../../../../utils/string'</span></span><br><span class="line"></span><br><span class="line">Component(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的属性列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  properties: &#123;</span><br><span class="line">    useSlot: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      value: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    showShare: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      value: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    pagePath: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">'/pages/packagesSection/redPacketsDistribute/index'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    showShare: <span class="literal">false</span>,</span><br><span class="line">    tempFilePath: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  query: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  observers: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的方法列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    shareClose() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123; <span class="attr">showShare</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> sharePoster(&#123;sharePic&#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; token &#125; = <span class="keyword">await</span> getApp().getAuthInfo();</span><br><span class="line">      <span class="keyword">if</span> (!token) &#123;</span><br><span class="line">        <span class="keyword">this</span>.triggerEvent(<span class="string">'isLogin'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.data.tempFilePath) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123; <span class="attr">showShare</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      wx.showLoading(&#123; <span class="attr">title</span>: <span class="string">'正在生成海报...'</span> &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; userId = <span class="string">''</span>, userInfo, mobile &#125; = getApp().data.authinfo;</span><br><span class="line">        <span class="keyword">const</span> &#123; shareId, pagePath &#125; = <span class="keyword">this</span>.data</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.qrcode) &#123;</span><br><span class="line">          <span class="keyword">this</span>.qrcode = <span class="keyword">await</span> rGetShareErCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ctx = wx.createCanvasContext(<span class="string">'poster-share'</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvas = ctx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// const &#123; height, orientation, path, type, width &#125; = await wx.wxp.getImageInfo(&#123;</span></span><br><span class="line">        <span class="comment">//   src: imgSrc,</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">path</span>: posterBg &#125; = <span class="keyword">await</span> wx.wxp.getImageInfo(&#123;</span><br><span class="line">          src: <span class="string">'https://hyzmj.oss-cn-shenzhen.aliyuncs.com/jyh/posterBg.png'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">await</span> ctx.drawImage(posterBg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">570</span>, <span class="number">920</span>);</span><br><span class="line">        ctx.save();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// banner</span></span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">path</span>: banner &#125; = <span class="keyword">await</span> wx.wxp.getImageInfo(&#123;</span><br><span class="line">          src: sharePic,</span><br><span class="line">        &#125;);</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(<span class="number">385</span> + <span class="number">45</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">        ctx.closePath();</span><br><span class="line">        ctx.drawImage(banner, <span class="number">45</span>, <span class="number">130</span>, <span class="number">500</span>, <span class="number">470</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维码和提示消息</span></span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(<span class="number">385</span> + <span class="number">45</span>, <span class="number">760</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">        ctx.closePath();</span><br><span class="line"></span><br><span class="line">        ctx.clip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// const [, format, bodyData] = /data:image\/(\w+);base64,(.*)/.exec(`data:image/png;base64,$&#123;this.qrcode.data&#125;`) || [];</span></span><br><span class="line">        <span class="comment">// if (!format || !bodyData) &#123;</span></span><br><span class="line">        <span class="comment">//   throw new Error('base64 错误');</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// const filePath = `$&#123;wx.env.USER_DATA_PATH&#125;/tmp.base64src$&#123;new Date().getTime()&#125;.$&#123;format&#125;`;</span></span><br><span class="line">        <span class="comment">// wx.getFileSystemManager().writeFileSync(filePath, bodyData, 'base64');</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">path</span>: filePath &#125; = <span class="keyword">await</span> wx.wxp.getImageInfo(&#123;</span><br><span class="line">          src: <span class="keyword">this</span>.qrcode.data,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 企业微信二维码</span></span><br><span class="line">        ctx.drawImage(filePath, <span class="number">360</span>, <span class="number">660</span>, <span class="number">190</span>, <span class="number">190</span>);</span><br><span class="line"></span><br><span class="line">        ctx.restore();</span><br><span class="line">        <span class="comment">// 获取头像</span></span><br><span class="line">        <span class="keyword">const</span> &#123; statusCode, tempFilePath &#125; = <span class="keyword">await</span> wx.wxp.downloadFile(&#123;</span><br><span class="line">          url: userInfo.imgPath || <span class="string">'https://hyzmj.oss-cn-shenzhen.aliyuncs.com/zyj-weapp/note/mine_avatar.png'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        ctx.setFontSize(<span class="number">22</span>)</span><br><span class="line">        ctx.setFillStyle(<span class="string">'#000'</span>);</span><br><span class="line">        ctx.fillText(<span class="string">'微信零钱立即到账无需提现'</span>, <span class="number">40</span> + <span class="number">5</span>, <span class="number">640</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> userName = stringLimit(userInfo.userName,<span class="number">12</span>)</span><br><span class="line">          ctx.beginPath();</span><br><span class="line">          ctx.arc(<span class="number">40</span> + <span class="number">45</span>, <span class="number">710</span> + <span class="number">45</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">          ctx.closePath();</span><br><span class="line">          <span class="comment">// 绘制头像和昵称</span></span><br><span class="line">          ctx.setFontSize(<span class="number">22</span>)</span><br><span class="line">          ctx.setFillStyle(<span class="string">'#222'</span>);</span><br><span class="line">          <span class="comment">// ctx.fillText(userName, 140 + 5, 700 + 5)</span></span><br><span class="line">          ctx.fillText(<span class="string">'来自'</span>, <span class="number">140</span> + <span class="number">5</span>, <span class="number">740</span> + <span class="number">5</span>)</span><br><span class="line">          ctx.fillText(mobile.replace(<span class="regexp">/^(\d&#123;3&#125;)\d&#123;4&#125;(\d+)/</span>, <span class="string">"$1****$2"</span>) + <span class="string">'推荐'</span>, <span class="number">140</span> + <span class="number">5</span>, <span class="number">780</span> + <span class="number">5</span>)</span><br><span class="line">          ctx.clip();</span><br><span class="line">          ctx.drawImage(tempFilePath, <span class="number">40</span> + <span class="number">5</span>, <span class="number">710</span> + <span class="number">5</span>, <span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> file = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 开始绘制</span></span><br><span class="line">          ctx.draw(<span class="literal">false</span>, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 生成临时图片文件</span></span><br><span class="line">            wx.canvasToTempFilePath(&#123;</span><br><span class="line">              canvasId: <span class="string">'poster-share'</span>,</span><br><span class="line">              <span class="comment">// width,</span></span><br><span class="line">              <span class="comment">// height,</span></span><br><span class="line">              <span class="comment">// destWidth: width*(wx.getSystemInfoSync().pixelRatio),</span></span><br><span class="line">              <span class="comment">// destHeight: height*(wx.getSystemInfoSync().pixelRatio),</span></span><br><span class="line">              success: resolve,</span><br><span class="line">              fail: reject,</span><br><span class="line">            &#125;, _this);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123; <span class="attr">tempFilePath</span>: file.tempFilePath, <span class="attr">showShare</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(file)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data)</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">        wx.showToast(&#123; <span class="attr">title</span>: <span class="string">'生成海报失败'</span>, <span class="attr">icon</span>: <span class="string">'none'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      wx.hideLoading();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> savePicture() &#123;</span><br><span class="line">      wx.showLoading(&#123; <span class="attr">title</span>: <span class="string">'正在保存...'</span> &#125;);</span><br><span class="line">      <span class="keyword">await</span> wx.wxp.saveImageToPhotosAlbum(&#123; <span class="attr">filePath</span>: <span class="keyword">this</span>.data.tempFilePath &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        wx.hideLoading();</span><br><span class="line">        wx.showToast(&#123; <span class="attr">title</span>: <span class="string">'保存失败'</span>, <span class="attr">icon</span>: <span class="string">'none'</span> &#125;);</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      wx.hideLoading();</span><br><span class="line">      wx.showToast(&#123; <span class="attr">title</span>: <span class="string">'保存成功'</span>, <span class="attr">icon</span>: <span class="string">'none'</span> &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>调用组件</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.selectComponent(<span class="string">'#poster'</span>).sharePoster(&#123;</span><br><span class="line">  sharePic: shareImageUrl</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>效果图</strong></p><p><img src="https://poetries1.gitee.io/img-repo/2021/01/1.jpeg" alt></p><h2 id="封装成组件库"><a href="#封装成组件库" class="headerlink" title="封装成组件库"></a>封装成组件库</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/draw.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(context, canvas, use2dCanvas = false) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx = context;</span><br><span class="line">    <span class="keyword">this</span>.canvas = canvas || <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.use2dCanvas = use2dCanvas;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  roundRect(x, y, w, h, r, fill = <span class="literal">true</span>, stroke = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.ctx;</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(x + r, y + r, r, <span class="built_in">Math</span>.PI, (<span class="built_in">Math</span>.PI * <span class="number">3</span>) / <span class="number">2</span>);</span><br><span class="line">    ctx.arc(x + w - r, y + r, r, (<span class="built_in">Math</span>.PI * <span class="number">3</span>) / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    ctx.arc(x + w - r, y + h - r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">    ctx.arc(x + r, y + h - r, r, <span class="built_in">Math</span>.PI / <span class="number">2</span>, <span class="built_in">Math</span>.PI);</span><br><span class="line">    ctx.lineTo(x, y + r);</span><br><span class="line">    <span class="keyword">if</span> (stroke) ctx.stroke();</span><br><span class="line">    <span class="keyword">if</span> (fill) ctx.fill();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  drawView(box, style = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.ctx;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">left</span>: x, <span class="attr">top</span>: y, <span class="attr">width</span>: w, <span class="attr">height</span>: h &#125; = box;</span><br><span class="line">    <span class="keyword">const</span> &#123; borderRadius = <span class="number">0</span>, borderWidth = <span class="number">0</span>, borderColor, color = <span class="string">'#000'</span>, backgroundColor = <span class="string">'transparent'</span> &#125; = style;</span><br><span class="line">    ctx.save();</span><br><span class="line">    <span class="comment">// 外环</span></span><br><span class="line">    <span class="keyword">if</span> (borderWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ctx.fillStyle = borderColor || color;</span><br><span class="line">      <span class="keyword">this</span>.roundRect(x, y, w, h, borderRadius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内环</span></span><br><span class="line">    ctx.fillStyle = backgroundColor;</span><br><span class="line">    <span class="keyword">const</span> innerWidth = w - <span class="number">2</span> * borderWidth;</span><br><span class="line">    <span class="keyword">const</span> innerHeight = h - <span class="number">2</span> * borderWidth;</span><br><span class="line">    <span class="keyword">const</span> innerRadius = borderRadius - borderWidth &gt;= <span class="number">0</span> ? borderRadius - borderWidth : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.roundRect(x + borderWidth, y + borderWidth, innerWidth, innerHeight, innerRadius);</span><br><span class="line">    ctx.restore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> drawImage(img, box = &#123;&#125;, style = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>.ctx;</span><br><span class="line">      <span class="keyword">const</span> canvas = <span class="keyword">this</span>.canvas;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; borderRadius = <span class="number">0</span> &#125; = style;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">left</span>: x, <span class="attr">top</span>: y, <span class="attr">width</span>: w, <span class="attr">height</span>: h &#125; = box;</span><br><span class="line">      ctx.save();</span><br><span class="line">      <span class="keyword">this</span>.roundRect(x, y, w, h, borderRadius, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">      ctx.clip();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> _drawImage = <span class="function">(<span class="params">img</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.use2dCanvas) &#123;</span><br><span class="line">          <span class="keyword">const</span> Image = canvas.createImage();</span><br><span class="line">          Image.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            ctx.drawImage(Image, x, y, w, h);</span><br><span class="line">            ctx.restore();</span><br><span class="line">            resolve();</span><br><span class="line">          &#125;;</span><br><span class="line">          Image.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`createImage fail: <span class="subst">$&#123;img&#125;</span>`</span>));</span><br><span class="line">          &#125;;</span><br><span class="line">          Image.src = img;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ctx.drawImage(img, x, y, w, h);</span><br><span class="line">          ctx.restore();</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> isTempFile = <span class="regexp">/^wxfile:\/\//</span>.test(img);</span><br><span class="line">      <span class="keyword">const</span> isNetworkFile = <span class="regexp">/^https?:\/\//</span>.test(img);</span><br><span class="line">      <span class="keyword">const</span> isBase64 = <span class="regexp">/^data:image\/(\w+);base64,/</span>.test(img);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isTempFile) &#123;</span><br><span class="line">        _drawImage(img);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBase64) &#123;</span><br><span class="line">        _drawImage(img);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNetworkFile) &#123;</span><br><span class="line">        wx.downloadFile(&#123;</span><br><span class="line">          url: img,</span><br><span class="line">          success(res) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">              _drawImage(res.tempFilePath);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`downloadFile:fail <span class="subst">$&#123;img&#125;</span>`</span>));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          fail() &#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`downloadFile:fail <span class="subst">$&#123;img&#125;</span>`</span>));</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`image format error: <span class="subst">$&#123;img&#125;</span>`</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eslint-disable-next-line complexity</span></span><br><span class="line">  drawText(text, box = &#123;&#125;, style = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.ctx;</span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">left</span>: x, <span class="attr">top</span>: y, <span class="attr">width</span>: w, <span class="attr">height</span>: h &#125; = box;</span><br><span class="line">    <span class="keyword">let</span> &#123; color = <span class="string">'#000'</span>, lineHeight = <span class="string">'1.4em'</span>, fontSize = <span class="number">14</span>, textAlign = <span class="string">'left'</span>, verticalAlign = <span class="string">'top'</span>, backgroundColor = <span class="string">'transparent'</span> &#125; = style;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> lineHeight === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="comment">// 2em</span></span><br><span class="line">      lineHeight = <span class="built_in">Math</span>.ceil(<span class="built_in">parseFloat</span>(lineHeight.replace(<span class="string">'em'</span>)) * fontSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!text || lineHeight &gt; h) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.textBaseline = <span class="string">'top'</span>;</span><br><span class="line">    ctx.font = <span class="string">`<span class="subst">$&#123;fontSize&#125;</span>px sans-serif`</span>;</span><br><span class="line">    ctx.textAlign = textAlign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 背景色</span></span><br><span class="line">    ctx.fillStyle = backgroundColor;</span><br><span class="line">    <span class="keyword">this</span>.roundRect(x, y, w, h, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文字颜色</span></span><br><span class="line">    ctx.fillStyle = color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 水平布局</span></span><br><span class="line">    <span class="keyword">switch</span> (textAlign) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'left'</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'center'</span>:</span><br><span class="line">        x += <span class="number">0.5</span> * w;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'right'</span>:</span><br><span class="line">        x += w;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> textWidth = ctx.measureText(text).width;</span><br><span class="line">    <span class="keyword">const</span> actualHeight = <span class="built_in">Math</span>.ceil(textWidth / w) * lineHeight;</span><br><span class="line">    <span class="keyword">let</span> paddingTop = <span class="built_in">Math</span>.ceil((h - actualHeight) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (paddingTop &lt; <span class="number">0</span>) paddingTop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直布局</span></span><br><span class="line">    <span class="keyword">switch</span> (verticalAlign) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'top'</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'middle'</span>:</span><br><span class="line">        y += paddingTop;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'bottom'</span>:</span><br><span class="line">        y += <span class="number">2</span> * paddingTop;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> inlinePaddingTop = <span class="built_in">Math</span>.ceil((lineHeight - fontSize) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不超过一行</span></span><br><span class="line">    <span class="keyword">if</span> (textWidth &lt;= w) &#123;</span><br><span class="line">      ctx.fillText(text, x, y + inlinePaddingTop);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多行文本</span></span><br><span class="line">    <span class="keyword">const</span> chars = text.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">const</span> _y = y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐行绘制</span></span><br><span class="line">    <span class="keyword">let</span> line = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> chars) &#123;</span><br><span class="line">      <span class="keyword">const</span> testLine = line + ch;</span><br><span class="line">      <span class="keyword">const</span> testWidth = ctx.measureText(testLine).width;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (testWidth &gt; w) &#123;</span><br><span class="line">        ctx.fillText(line, x, y + inlinePaddingTop);</span><br><span class="line">        y += lineHeight;</span><br><span class="line">        line = ch;</span><br><span class="line">        <span class="keyword">if</span> (y + lineHeight &gt; _y + h) <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        line = testLine;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免溢出</span></span><br><span class="line">    <span class="keyword">if</span> (y + lineHeight &lt;= _y + h) &#123;</span><br><span class="line">      ctx.fillText(line, x, y + inlinePaddingTop);</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.restore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> drawNode(element) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; layoutBox, computedStyle, name &#125; = element;</span><br><span class="line">    <span class="keyword">const</span> &#123; src, text &#125; = element.attributes;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'view'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.drawView(layoutBox, computedStyle);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'image'</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.drawImage(src, layoutBox, computedStyle);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'text'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.drawText(text, layoutBox, computedStyle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> childs = <span class="built_in">Object</span>.values(element.children);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> childs) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.drawNode(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Draw;</span><br></pre></td></tr></table></figure><p><strong>使用方式</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;df fxdc h100v&quot;&gt;</span><br><span class="line">  &lt;view class=&quot;df jcc aic fxa posr&quot;&gt;</span><br><span class="line">    &lt;image</span><br><span class="line">      class=&quot;posa t0 l0 w100p h100p blur&quot;</span><br><span class="line">      src=&quot;&#123;&#123; bgImage &#125;&#125;&quot;</span><br><span class="line">      wx:if=&quot;&#123;&#123; bgImage &#125;&#125;&quot;</span><br><span class="line">      mode=&quot;aspectFill&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;canvas type=&quot;2d&quot; id=&quot;poster-canvas&quot; class=&quot;poster&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">  &lt;view class=&quot;fxn h238 bgfff df aic jcc bdrs16t&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;fxa w0 df aic jcc&quot;&gt;</span><br><span class="line">      &lt;view class=&quot;df fxdc posr&quot;&gt;</span><br><span class="line">        &lt;button class=&quot;posa t0 l0 w100p h100p op0&quot; open-type=&quot;share&quot;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;image class=&quot;h108 w108&quot; src=&quot;./assets/ic_fenxiang.svg&quot; /&gt;</span><br><span class="line">        &lt;text class=&quot;mt16 c333 fz28&quot;&gt;分享好友&lt;/text&gt;</span><br><span class="line">      &lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;view class=&quot;fxa w0 df aic jcc&quot;&gt;</span><br><span class="line">      &lt;view class=&quot;df fxdc&quot; bind:tap=&quot;handleSave&quot;&gt;</span><br><span class="line">        &lt;image class=&quot;h108 w108&quot; src=&quot;./assets/ic_baocun.svg&quot; /&gt;</span><br><span class="line">        &lt;text class=&quot;mt16 c333 fz28&quot;&gt;保存图片&lt;/text&gt;</span><br><span class="line">      &lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">page</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#5c5c5c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.poster</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">862</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">558</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.blur</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Draw <span class="keyword">from</span> <span class="string">'../../../utilities/draw'</span>;</span><br><span class="line"><span class="keyword">import</span> bg <span class="keyword">from</span> <span class="string">'./assets/bg.js'</span>;</span><br><span class="line"><span class="keyword">import</span> avatar <span class="keyword">from</span> <span class="string">'./assets/avatar.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; rGetGoodsDetail &#125; <span class="keyword">from</span> <span class="string">'../../../netapi/goods/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; rGetShortQrcode &#125; <span class="keyword">from</span> <span class="string">'../../../netapi/other/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; KEY_APP_ID &#125; <span class="keyword">from</span> <span class="string">'../../../constants/config'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getStorageUserSettingForKey &#125; <span class="keyword">from</span> <span class="string">'../../../utilities/other'</span>;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    bgImage: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  query: &#123;</span><br><span class="line">    goodsId: <span class="string">''</span>,</span><br><span class="line">    shareId: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.query = options;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> onReady() &#123;</span><br><span class="line">    wx.showLoading(&#123; <span class="attr">title</span>: <span class="string">'正在生成海报...'</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> userId = getApp().data.authinfo.userId;</span><br><span class="line">    <span class="keyword">let</span> mobile = getStorageUserSettingForKey(<span class="string">'mobile'</span>);</span><br><span class="line">    mobile = mobile.replace(<span class="regexp">/(\d&#123;3&#125;)\d*(\d&#123;2&#125;)/</span>, <span class="string">'$1****$2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> rGetGoodsDetail(&#123; <span class="attr">id</span>: <span class="keyword">this</span>.query.goodsId &#125;, &#123; <span class="attr">catcher</span>: <span class="keyword">this</span>, <span class="attr">show</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="keyword">const</span> qrcode = <span class="keyword">await</span> rGetShortQrcode(</span><br><span class="line">      &#123;</span><br><span class="line">        appId: KEY_APP_ID,</span><br><span class="line">        page: <span class="string">'pages/packagesOther/transfer/index'</span>,</span><br><span class="line">        scene: <span class="string">`/pages/packagesGoods/goodsDetail/index?goodsId=<span class="subst">$&#123;<span class="keyword">this</span>.query.goodsId&#125;</span>&amp;shareId=<span class="subst">$&#123;userId&#125;</span>`</span>,</span><br><span class="line">        shortScenePrefix: <span class="string">'page-'</span>,</span><br><span class="line">        width: <span class="number">200</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">catcher</span>: <span class="keyword">this</span>, <span class="attr">show</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!response || response.code !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123; <span class="attr">error</span>: response &#125;);</span><br><span class="line">      wx.hideLoading();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!qrcode || qrcode.code !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123; <span class="attr">error</span>: qrcode &#125;);</span><br><span class="line">      wx.hideLoading();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.response = response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123; <span class="attr">bgImage</span>: response.data.goods_image[<span class="number">0</span>].img &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> query = wx.createSelectorQuery();</span><br><span class="line">    query</span><br><span class="line">      .select(<span class="string">'#poster-canvas'</span>)</span><br><span class="line">      .fields(&#123; <span class="attr">node</span>: <span class="literal">true</span>, <span class="attr">size</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">      .exec(<span class="keyword">async</span> (res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 558px*862px</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> canvas = res[<span class="number">0</span>].node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">        canvas.width = <span class="number">558</span>;</span><br><span class="line">        canvas.height = <span class="number">862</span>;</span><br><span class="line">        <span class="keyword">const</span> ratio = canvas.width / <span class="number">558</span>;</span><br><span class="line">        ctx.scale(ratio, ratio);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.canvas = canvas;</span><br><span class="line">        <span class="keyword">this</span>.ratio = ratio;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> draw = <span class="keyword">new</span> Draw(ctx, canvas, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 背景</span></span><br><span class="line">        <span class="keyword">await</span> draw</span><br><span class="line">          .drawImage(bg, &#123;</span><br><span class="line">            left: <span class="number">0</span>,</span><br><span class="line">            top: <span class="number">0</span>,</span><br><span class="line">            width: <span class="number">558</span>,</span><br><span class="line">            height: <span class="number">862</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 商品图片</span></span><br><span class="line">        <span class="keyword">await</span> draw.drawImage(response.data.goods_image[<span class="number">0</span>].img, &#123;</span><br><span class="line">          left: <span class="number">50</span>,</span><br><span class="line">          top: <span class="number">122</span>,</span><br><span class="line">          width: <span class="number">455</span>,</span><br><span class="line">          height: <span class="number">455</span>,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 商品名称</span></span><br><span class="line">        draw.drawText(</span><br><span class="line">          response.data.goods_info.goods_name || <span class="string">''</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            left: <span class="number">50</span>,</span><br><span class="line">            top: <span class="number">608</span>,</span><br><span class="line">            width: <span class="number">455</span>,</span><br><span class="line">            height: <span class="number">96</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            color: <span class="string">'#333'</span>,</span><br><span class="line">            fontSize: <span class="number">28</span>,</span><br><span class="line">            fontWeight: <span class="number">500</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头像</span></span><br><span class="line">        <span class="keyword">await</span> draw.drawImage(</span><br><span class="line">          avatar,</span><br><span class="line">          &#123;</span><br><span class="line">            left: <span class="number">50</span>,</span><br><span class="line">            top: <span class="number">720</span>,</span><br><span class="line">            width: <span class="number">56</span>,</span><br><span class="line">            height: <span class="number">56</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            borderRadius: <span class="number">28</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分享者</span></span><br><span class="line">        draw.drawText(</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;mobile&#125;</span>的分享`</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            left: <span class="number">116</span>,</span><br><span class="line">            top: <span class="number">732</span>,</span><br><span class="line">            width: <span class="number">250</span>,</span><br><span class="line">            height: <span class="number">40</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            color: <span class="string">'#333'</span>,</span><br><span class="line">            fontSize: <span class="number">24</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维码</span></span><br><span class="line">        <span class="keyword">await</span> draw.drawImage(</span><br><span class="line">          <span class="string">`data:image/png;base64,<span class="subst">$&#123;qrcode.data&#125;</span>`</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            left: <span class="number">380</span>,</span><br><span class="line">            top: <span class="number">650</span>,</span><br><span class="line">            width: <span class="number">146</span>,</span><br><span class="line">            height: <span class="number">146</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            borderRadius: <span class="number">78</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 金额</span></span><br><span class="line">        draw.drawText(</span><br><span class="line">          <span class="string">`  ¥ <span class="subst">$&#123;response.data.goods_info.intervalPrice&#125;</span>`</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            left: <span class="number">144</span>,</span><br><span class="line">            top: <span class="number">798</span>,</span><br><span class="line">            width: <span class="number">200</span>,</span><br><span class="line">            height: <span class="number">40</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            color: <span class="string">'#ff6c1e'</span>,</span><br><span class="line">            lineHeigh: <span class="number">24</span>,</span><br><span class="line">            fontSize: <span class="number">26</span>,</span><br><span class="line">            fontWeight: <span class="number">500</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        wx.hideLoading();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onShareAppMessage() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> handleSave() &#123;</span><br><span class="line">    wx.showLoading(&#123; <span class="attr">title</span>: <span class="string">'正在保存...'</span> &#125;);</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> wx.wxp</span><br><span class="line">      .canvasToTempFilePath(&#123;</span><br><span class="line">        canvas: <span class="keyword">this</span>.canvas,</span><br><span class="line">        width: <span class="number">558</span>,</span><br><span class="line">        height: <span class="number">862</span>,</span><br><span class="line">        destWidth: <span class="number">558</span>,</span><br><span class="line">        destHeight: <span class="number">862</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        wx.hideLoading();</span><br><span class="line">        wx.showToast(&#123; <span class="attr">title</span>: <span class="string">'保存失败'</span>, <span class="attr">icon</span>: <span class="string">'none'</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wx.wxp</span><br><span class="line">      .saveImageToPhotosAlbum(&#123;</span><br><span class="line">        filePath: res.tempFilePath,</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        wx.hideLoading();</span><br><span class="line">        wx.showToast(&#123; <span class="attr">title</span>: <span class="string">'保存失败'</span>, <span class="attr">icon</span>: <span class="string">'none'</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">    wx.hideLoading();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>效果预览</strong></p><p><img src="https://poetries1.gitee.io/img-repo/2021/01/2.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生成海报方式一&quot;&gt;&lt;a href=&quot;#生成海报方式一&quot; class=&quot;headerlink&quot; title=&quot;生成海报方式一&quot;&gt;&lt;/a&gt;生成海报方式一&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;封装成组件方便调用&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="小程序" scheme="http://blog.poetries.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="海报" scheme="http://blog.poetries.top/tags/%E6%B5%B7%E6%8A%A5/"/>
    
  </entry>
  
</feed>
